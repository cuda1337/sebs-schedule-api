
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Staff
 * 
 */
export type Staff = $Result.DefaultSelection<Prisma.$StaffPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model ScheduleVersion
 * 
 */
export type ScheduleVersion = $Result.DefaultSelection<Prisma.$ScheduleVersionPayload>
/**
 * Model Assignment
 * 
 */
export type Assignment = $Result.DefaultSelection<Prisma.$AssignmentPayload>
/**
 * Model GroupSession
 * 
 */
export type GroupSession = $Result.DefaultSelection<Prisma.$GroupSessionPayload>
/**
 * Model GroupSessionClient
 * 
 */
export type GroupSessionClient = $Result.DefaultSelection<Prisma.$GroupSessionClientPayload>
/**
 * Model ChangeLog
 * 
 */
export type ChangeLog = $Result.DefaultSelection<Prisma.$ChangeLogPayload>
/**
 * Model DailyOverride
 * 
 */
export type DailyOverride = $Result.DefaultSelection<Prisma.$DailyOverridePayload>
/**
 * Model ClientSupervisor
 * 
 */
export type ClientSupervisor = $Result.DefaultSelection<Prisma.$ClientSupervisorPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Staff
 * const staff = await prisma.staff.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Staff
   * const staff = await prisma.staff.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.staff`: Exposes CRUD operations for the **Staff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff
    * const staff = await prisma.staff.findMany()
    * ```
    */
  get staff(): Prisma.StaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduleVersion`: Exposes CRUD operations for the **ScheduleVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduleVersions
    * const scheduleVersions = await prisma.scheduleVersion.findMany()
    * ```
    */
  get scheduleVersion(): Prisma.ScheduleVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assignment`: Exposes CRUD operations for the **Assignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignments
    * const assignments = await prisma.assignment.findMany()
    * ```
    */
  get assignment(): Prisma.AssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupSession`: Exposes CRUD operations for the **GroupSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupSessions
    * const groupSessions = await prisma.groupSession.findMany()
    * ```
    */
  get groupSession(): Prisma.GroupSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groupSessionClient`: Exposes CRUD operations for the **GroupSessionClient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupSessionClients
    * const groupSessionClients = await prisma.groupSessionClient.findMany()
    * ```
    */
  get groupSessionClient(): Prisma.GroupSessionClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.changeLog`: Exposes CRUD operations for the **ChangeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChangeLogs
    * const changeLogs = await prisma.changeLog.findMany()
    * ```
    */
  get changeLog(): Prisma.ChangeLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyOverride`: Exposes CRUD operations for the **DailyOverride** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyOverrides
    * const dailyOverrides = await prisma.dailyOverride.findMany()
    * ```
    */
  get dailyOverride(): Prisma.DailyOverrideDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientSupervisor`: Exposes CRUD operations for the **ClientSupervisor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientSupervisors
    * const clientSupervisors = await prisma.clientSupervisor.findMany()
    * ```
    */
  get clientSupervisor(): Prisma.ClientSupervisorDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Staff: 'Staff',
    Client: 'Client',
    ScheduleVersion: 'ScheduleVersion',
    Assignment: 'Assignment',
    GroupSession: 'GroupSession',
    GroupSessionClient: 'GroupSessionClient',
    ChangeLog: 'ChangeLog',
    DailyOverride: 'DailyOverride',
    ClientSupervisor: 'ClientSupervisor'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "staff" | "client" | "scheduleVersion" | "assignment" | "groupSession" | "groupSessionClient" | "changeLog" | "dailyOverride" | "clientSupervisor"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Staff: {
        payload: Prisma.$StaffPayload<ExtArgs>
        fields: Prisma.StaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findFirst: {
            args: Prisma.StaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          findMany: {
            args: Prisma.StaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          create: {
            args: Prisma.StaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          createMany: {
            args: Prisma.StaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          delete: {
            args: Prisma.StaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          update: {
            args: Prisma.StaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          deleteMany: {
            args: Prisma.StaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>[]
          }
          upsert: {
            args: Prisma.StaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffPayload>
          }
          aggregate: {
            args: Prisma.StaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaff>
          }
          groupBy: {
            args: Prisma.StaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffCountArgs<ExtArgs>
            result: $Utils.Optional<StaffCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      ScheduleVersion: {
        payload: Prisma.$ScheduleVersionPayload<ExtArgs>
        fields: Prisma.ScheduleVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleVersionPayload>
          }
          findFirst: {
            args: Prisma.ScheduleVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleVersionPayload>
          }
          findMany: {
            args: Prisma.ScheduleVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleVersionPayload>[]
          }
          create: {
            args: Prisma.ScheduleVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleVersionPayload>
          }
          createMany: {
            args: Prisma.ScheduleVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleVersionPayload>[]
          }
          delete: {
            args: Prisma.ScheduleVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleVersionPayload>
          }
          update: {
            args: Prisma.ScheduleVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleVersionPayload>
          }
          deleteMany: {
            args: Prisma.ScheduleVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleVersionPayload>[]
          }
          upsert: {
            args: Prisma.ScheduleVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleVersionPayload>
          }
          aggregate: {
            args: Prisma.ScheduleVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduleVersion>
          }
          groupBy: {
            args: Prisma.ScheduleVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleVersionCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleVersionCountAggregateOutputType> | number
          }
        }
      }
      Assignment: {
        payload: Prisma.$AssignmentPayload<ExtArgs>
        fields: Prisma.AssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findFirst: {
            args: Prisma.AssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findMany: {
            args: Prisma.AssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          create: {
            args: Prisma.AssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          createMany: {
            args: Prisma.AssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          delete: {
            args: Prisma.AssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          update: {
            args: Prisma.AssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          upsert: {
            args: Prisma.AssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          aggregate: {
            args: Prisma.AssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignment>
          }
          groupBy: {
            args: Prisma.AssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentCountAggregateOutputType> | number
          }
        }
      }
      GroupSession: {
        payload: Prisma.$GroupSessionPayload<ExtArgs>
        fields: Prisma.GroupSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionPayload>
          }
          findFirst: {
            args: Prisma.GroupSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionPayload>
          }
          findMany: {
            args: Prisma.GroupSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionPayload>[]
          }
          create: {
            args: Prisma.GroupSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionPayload>
          }
          createMany: {
            args: Prisma.GroupSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionPayload>[]
          }
          delete: {
            args: Prisma.GroupSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionPayload>
          }
          update: {
            args: Prisma.GroupSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionPayload>
          }
          deleteMany: {
            args: Prisma.GroupSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionPayload>[]
          }
          upsert: {
            args: Prisma.GroupSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionPayload>
          }
          aggregate: {
            args: Prisma.GroupSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupSession>
          }
          groupBy: {
            args: Prisma.GroupSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupSessionCountArgs<ExtArgs>
            result: $Utils.Optional<GroupSessionCountAggregateOutputType> | number
          }
        }
      }
      GroupSessionClient: {
        payload: Prisma.$GroupSessionClientPayload<ExtArgs>
        fields: Prisma.GroupSessionClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupSessionClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupSessionClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionClientPayload>
          }
          findFirst: {
            args: Prisma.GroupSessionClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupSessionClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionClientPayload>
          }
          findMany: {
            args: Prisma.GroupSessionClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionClientPayload>[]
          }
          create: {
            args: Prisma.GroupSessionClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionClientPayload>
          }
          createMany: {
            args: Prisma.GroupSessionClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GroupSessionClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionClientPayload>[]
          }
          delete: {
            args: Prisma.GroupSessionClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionClientPayload>
          }
          update: {
            args: Prisma.GroupSessionClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionClientPayload>
          }
          deleteMany: {
            args: Prisma.GroupSessionClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupSessionClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GroupSessionClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionClientPayload>[]
          }
          upsert: {
            args: Prisma.GroupSessionClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupSessionClientPayload>
          }
          aggregate: {
            args: Prisma.GroupSessionClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupSessionClient>
          }
          groupBy: {
            args: Prisma.GroupSessionClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupSessionClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupSessionClientCountArgs<ExtArgs>
            result: $Utils.Optional<GroupSessionClientCountAggregateOutputType> | number
          }
        }
      }
      ChangeLog: {
        payload: Prisma.$ChangeLogPayload<ExtArgs>
        fields: Prisma.ChangeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChangeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChangeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          findFirst: {
            args: Prisma.ChangeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChangeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          findMany: {
            args: Prisma.ChangeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>[]
          }
          create: {
            args: Prisma.ChangeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          createMany: {
            args: Prisma.ChangeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChangeLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>[]
          }
          delete: {
            args: Prisma.ChangeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          update: {
            args: Prisma.ChangeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          deleteMany: {
            args: Prisma.ChangeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChangeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChangeLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>[]
          }
          upsert: {
            args: Prisma.ChangeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeLogPayload>
          }
          aggregate: {
            args: Prisma.ChangeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChangeLog>
          }
          groupBy: {
            args: Prisma.ChangeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChangeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChangeLogCountArgs<ExtArgs>
            result: $Utils.Optional<ChangeLogCountAggregateOutputType> | number
          }
        }
      }
      DailyOverride: {
        payload: Prisma.$DailyOverridePayload<ExtArgs>
        fields: Prisma.DailyOverrideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyOverrideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyOverridePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyOverrideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyOverridePayload>
          }
          findFirst: {
            args: Prisma.DailyOverrideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyOverridePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyOverrideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyOverridePayload>
          }
          findMany: {
            args: Prisma.DailyOverrideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyOverridePayload>[]
          }
          create: {
            args: Prisma.DailyOverrideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyOverridePayload>
          }
          createMany: {
            args: Prisma.DailyOverrideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyOverrideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyOverridePayload>[]
          }
          delete: {
            args: Prisma.DailyOverrideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyOverridePayload>
          }
          update: {
            args: Prisma.DailyOverrideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyOverridePayload>
          }
          deleteMany: {
            args: Prisma.DailyOverrideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyOverrideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyOverrideUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyOverridePayload>[]
          }
          upsert: {
            args: Prisma.DailyOverrideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyOverridePayload>
          }
          aggregate: {
            args: Prisma.DailyOverrideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyOverride>
          }
          groupBy: {
            args: Prisma.DailyOverrideGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyOverrideGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyOverrideCountArgs<ExtArgs>
            result: $Utils.Optional<DailyOverrideCountAggregateOutputType> | number
          }
        }
      }
      ClientSupervisor: {
        payload: Prisma.$ClientSupervisorPayload<ExtArgs>
        fields: Prisma.ClientSupervisorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientSupervisorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSupervisorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientSupervisorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSupervisorPayload>
          }
          findFirst: {
            args: Prisma.ClientSupervisorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSupervisorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientSupervisorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSupervisorPayload>
          }
          findMany: {
            args: Prisma.ClientSupervisorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSupervisorPayload>[]
          }
          create: {
            args: Prisma.ClientSupervisorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSupervisorPayload>
          }
          createMany: {
            args: Prisma.ClientSupervisorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientSupervisorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSupervisorPayload>[]
          }
          delete: {
            args: Prisma.ClientSupervisorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSupervisorPayload>
          }
          update: {
            args: Prisma.ClientSupervisorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSupervisorPayload>
          }
          deleteMany: {
            args: Prisma.ClientSupervisorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientSupervisorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientSupervisorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSupervisorPayload>[]
          }
          upsert: {
            args: Prisma.ClientSupervisorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientSupervisorPayload>
          }
          aggregate: {
            args: Prisma.ClientSupervisorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientSupervisor>
          }
          groupBy: {
            args: Prisma.ClientSupervisorGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientSupervisorGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientSupervisorCountArgs<ExtArgs>
            result: $Utils.Optional<ClientSupervisorCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    staff?: StaffOmit
    client?: ClientOmit
    scheduleVersion?: ScheduleVersionOmit
    assignment?: AssignmentOmit
    groupSession?: GroupSessionOmit
    groupSessionClient?: GroupSessionClientOmit
    changeLog?: ChangeLogOmit
    dailyOverride?: DailyOverrideOmit
    clientSupervisor?: ClientSupervisorOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type StaffCountOutputType
   */

  export type StaffCountOutputType = {
    assignments: number
    groupSessions: number
    changeLogs: number
    originalOverrides: number
    newOverrides: number
  }

  export type StaffCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | StaffCountOutputTypeCountAssignmentsArgs
    groupSessions?: boolean | StaffCountOutputTypeCountGroupSessionsArgs
    changeLogs?: boolean | StaffCountOutputTypeCountChangeLogsArgs
    originalOverrides?: boolean | StaffCountOutputTypeCountOriginalOverridesArgs
    newOverrides?: boolean | StaffCountOutputTypeCountNewOverridesArgs
  }

  // Custom InputTypes
  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffCountOutputType
     */
    select?: StaffCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountGroupSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupSessionWhereInput
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountChangeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeLogWhereInput
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountOriginalOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyOverrideWhereInput
  }

  /**
   * StaffCountOutputType without action
   */
  export type StaffCountOutputTypeCountNewOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyOverrideWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    assignments: number
    groupSessionClients: number
    changeLogs: number
    originalOverrides: number
    newOverrides: number
    supervisorHistory: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | ClientCountOutputTypeCountAssignmentsArgs
    groupSessionClients?: boolean | ClientCountOutputTypeCountGroupSessionClientsArgs
    changeLogs?: boolean | ClientCountOutputTypeCountChangeLogsArgs
    originalOverrides?: boolean | ClientCountOutputTypeCountOriginalOverridesArgs
    newOverrides?: boolean | ClientCountOutputTypeCountNewOverridesArgs
    supervisorHistory?: boolean | ClientCountOutputTypeCountSupervisorHistoryArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountGroupSessionClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupSessionClientWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountChangeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeLogWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountOriginalOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyOverrideWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountNewOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyOverrideWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountSupervisorHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientSupervisorWhereInput
  }


  /**
   * Count Type ScheduleVersionCountOutputType
   */

  export type ScheduleVersionCountOutputType = {
    assignments: number
    groupSessions: number
    changeLogs: number
  }

  export type ScheduleVersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | ScheduleVersionCountOutputTypeCountAssignmentsArgs
    groupSessions?: boolean | ScheduleVersionCountOutputTypeCountGroupSessionsArgs
    changeLogs?: boolean | ScheduleVersionCountOutputTypeCountChangeLogsArgs
  }

  // Custom InputTypes
  /**
   * ScheduleVersionCountOutputType without action
   */
  export type ScheduleVersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleVersionCountOutputType
     */
    select?: ScheduleVersionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScheduleVersionCountOutputType without action
   */
  export type ScheduleVersionCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * ScheduleVersionCountOutputType without action
   */
  export type ScheduleVersionCountOutputTypeCountGroupSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupSessionWhereInput
  }

  /**
   * ScheduleVersionCountOutputType without action
   */
  export type ScheduleVersionCountOutputTypeCountChangeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeLogWhereInput
  }


  /**
   * Count Type GroupSessionCountOutputType
   */

  export type GroupSessionCountOutputType = {
    clients: number
    assignments: number
  }

  export type GroupSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | GroupSessionCountOutputTypeCountClientsArgs
    assignments?: boolean | GroupSessionCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * GroupSessionCountOutputType without action
   */
  export type GroupSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSessionCountOutputType
     */
    select?: GroupSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupSessionCountOutputType without action
   */
  export type GroupSessionCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupSessionClientWhereInput
  }

  /**
   * GroupSessionCountOutputType without action
   */
  export type GroupSessionCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Staff
   */

  export type AggregateStaff = {
    _count: StaffCountAggregateOutputType | null
    _avg: StaffAvgAggregateOutputType | null
    _sum: StaffSumAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  export type StaffAvgAggregateOutputType = {
    id: number | null
  }

  export type StaffSumAggregateOutputType = {
    id: number | null
  }

  export type StaffMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffCountAggregateOutputType = {
    id: number
    name: number
    locations: number
    availability: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffAvgAggregateInputType = {
    id?: true
  }

  export type StaffSumAggregateInputType = {
    id?: true
  }

  export type StaffMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffCountAggregateInputType = {
    id?: true
    name?: true
    locations?: true
    availability?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to aggregate.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Staff
    **/
    _count?: true | StaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StaffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StaffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffMaxAggregateInputType
  }

  export type GetStaffAggregateType<T extends StaffAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff[P]>
      : GetScalarType<T[P], AggregateStaff[P]>
  }




  export type StaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffWhereInput
    orderBy?: StaffOrderByWithAggregationInput | StaffOrderByWithAggregationInput[]
    by: StaffScalarFieldEnum[] | StaffScalarFieldEnum
    having?: StaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffCountAggregateInputType | true
    _avg?: StaffAvgAggregateInputType
    _sum?: StaffSumAggregateInputType
    _min?: StaffMinAggregateInputType
    _max?: StaffMaxAggregateInputType
  }

  export type StaffGroupByOutputType = {
    id: number
    name: string
    locations: string[]
    availability: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: StaffCountAggregateOutputType | null
    _avg: StaffAvgAggregateOutputType | null
    _sum: StaffSumAggregateOutputType | null
    _min: StaffMinAggregateOutputType | null
    _max: StaffMaxAggregateOutputType | null
  }

  type GetStaffGroupByPayload<T extends StaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffGroupByOutputType[P]>
            : GetScalarType<T[P], StaffGroupByOutputType[P]>
        }
      >
    >


  export type StaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    locations?: boolean
    availability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignments?: boolean | Staff$assignmentsArgs<ExtArgs>
    groupSessions?: boolean | Staff$groupSessionsArgs<ExtArgs>
    changeLogs?: boolean | Staff$changeLogsArgs<ExtArgs>
    originalOverrides?: boolean | Staff$originalOverridesArgs<ExtArgs>
    newOverrides?: boolean | Staff$newOverridesArgs<ExtArgs>
    _count?: boolean | StaffCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    locations?: boolean
    availability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    locations?: boolean
    availability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["staff"]>

  export type StaffSelectScalar = {
    id?: boolean
    name?: boolean
    locations?: boolean
    availability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "locations" | "availability" | "createdAt" | "updatedAt", ExtArgs["result"]["staff"]>
  export type StaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | Staff$assignmentsArgs<ExtArgs>
    groupSessions?: boolean | Staff$groupSessionsArgs<ExtArgs>
    changeLogs?: boolean | Staff$changeLogsArgs<ExtArgs>
    originalOverrides?: boolean | Staff$originalOverridesArgs<ExtArgs>
    newOverrides?: boolean | Staff$newOverridesArgs<ExtArgs>
    _count?: boolean | StaffCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Staff"
    objects: {
      assignments: Prisma.$AssignmentPayload<ExtArgs>[]
      groupSessions: Prisma.$GroupSessionPayload<ExtArgs>[]
      changeLogs: Prisma.$ChangeLogPayload<ExtArgs>[]
      originalOverrides: Prisma.$DailyOverridePayload<ExtArgs>[]
      newOverrides: Prisma.$DailyOverridePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      locations: string[]
      availability: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["staff"]>
    composites: {}
  }

  type StaffGetPayload<S extends boolean | null | undefined | StaffDefaultArgs> = $Result.GetResult<Prisma.$StaffPayload, S>

  type StaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaffCountAggregateInputType | true
    }

  export interface StaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Staff'], meta: { name: 'Staff' } }
    /**
     * Find zero or one Staff that matches the filter.
     * @param {StaffFindUniqueArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffFindUniqueArgs>(args: SelectSubset<T, StaffFindUniqueArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Staff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffFindUniqueOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffFindFirstArgs>(args?: SelectSubset<T, StaffFindFirstArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Staff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindFirstOrThrowArgs} args - Arguments to find a Staff
     * @example
     * // Get one Staff
     * const staff = await prisma.staff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Staff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff
     * const staff = await prisma.staff.findMany()
     * 
     * // Get first 10 Staff
     * const staff = await prisma.staff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffWithIdOnly = await prisma.staff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffFindManyArgs>(args?: SelectSubset<T, StaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Staff.
     * @param {StaffCreateArgs} args - Arguments to create a Staff.
     * @example
     * // Create one Staff
     * const Staff = await prisma.staff.create({
     *   data: {
     *     // ... data to create a Staff
     *   }
     * })
     * 
     */
    create<T extends StaffCreateArgs>(args: SelectSubset<T, StaffCreateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Staff.
     * @param {StaffCreateManyArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffCreateManyArgs>(args?: SelectSubset<T, StaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Staff and returns the data saved in the database.
     * @param {StaffCreateManyAndReturnArgs} args - Arguments to create many Staff.
     * @example
     * // Create many Staff
     * const staff = await prisma.staff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Staff.
     * @param {StaffDeleteArgs} args - Arguments to delete one Staff.
     * @example
     * // Delete one Staff
     * const Staff = await prisma.staff.delete({
     *   where: {
     *     // ... filter to delete one Staff
     *   }
     * })
     * 
     */
    delete<T extends StaffDeleteArgs>(args: SelectSubset<T, StaffDeleteArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Staff.
     * @param {StaffUpdateArgs} args - Arguments to update one Staff.
     * @example
     * // Update one Staff
     * const staff = await prisma.staff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffUpdateArgs>(args: SelectSubset<T, StaffUpdateArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Staff.
     * @param {StaffDeleteManyArgs} args - Arguments to filter Staff to delete.
     * @example
     * // Delete a few Staff
     * const { count } = await prisma.staff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffDeleteManyArgs>(args?: SelectSubset<T, StaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffUpdateManyArgs>(args: SelectSubset<T, StaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff and returns the data updated in the database.
     * @param {StaffUpdateManyAndReturnArgs} args - Arguments to update many Staff.
     * @example
     * // Update many Staff
     * const staff = await prisma.staff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Staff and only return the `id`
     * const staffWithIdOnly = await prisma.staff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaffUpdateManyAndReturnArgs>(args: SelectSubset<T, StaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Staff.
     * @param {StaffUpsertArgs} args - Arguments to update or create a Staff.
     * @example
     * // Update or create a Staff
     * const staff = await prisma.staff.upsert({
     *   create: {
     *     // ... data to create a Staff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff we want to update
     *   }
     * })
     */
    upsert<T extends StaffUpsertArgs>(args: SelectSubset<T, StaffUpsertArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffCountArgs} args - Arguments to filter Staff to count.
     * @example
     * // Count the number of Staff
     * const count = await prisma.staff.count({
     *   where: {
     *     // ... the filter for the Staff we want to count
     *   }
     * })
    **/
    count<T extends StaffCountArgs>(
      args?: Subset<T, StaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffAggregateArgs>(args: Subset<T, StaffAggregateArgs>): Prisma.PrismaPromise<GetStaffAggregateType<T>>

    /**
     * Group by Staff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffGroupByArgs['orderBy'] }
        : { orderBy?: StaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Staff model
   */
  readonly fields: StaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Staff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignments<T extends Staff$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Staff$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groupSessions<T extends Staff$groupSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Staff$groupSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    changeLogs<T extends Staff$changeLogsArgs<ExtArgs> = {}>(args?: Subset<T, Staff$changeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    originalOverrides<T extends Staff$originalOverridesArgs<ExtArgs> = {}>(args?: Subset<T, Staff$originalOverridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyOverridePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    newOverrides<T extends Staff$newOverridesArgs<ExtArgs> = {}>(args?: Subset<T, Staff$newOverridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyOverridePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Staff model
   */
  interface StaffFieldRefs {
    readonly id: FieldRef<"Staff", 'Int'>
    readonly name: FieldRef<"Staff", 'String'>
    readonly locations: FieldRef<"Staff", 'String[]'>
    readonly availability: FieldRef<"Staff", 'Json'>
    readonly createdAt: FieldRef<"Staff", 'DateTime'>
    readonly updatedAt: FieldRef<"Staff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Staff findUnique
   */
  export type StaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findUniqueOrThrow
   */
  export type StaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff findFirst
   */
  export type StaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findFirstOrThrow
   */
  export type StaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff.
     */
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff findMany
   */
  export type StaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter, which Staff to fetch.
     */
    where?: StaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff to fetch.
     */
    orderBy?: StaffOrderByWithRelationInput | StaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Staff.
     */
    cursor?: StaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff.
     */
    skip?: number
    distinct?: StaffScalarFieldEnum | StaffScalarFieldEnum[]
  }

  /**
   * Staff create
   */
  export type StaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to create a Staff.
     */
    data: XOR<StaffCreateInput, StaffUncheckedCreateInput>
  }

  /**
   * Staff createMany
   */
  export type StaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Staff createManyAndReturn
   */
  export type StaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The data used to create many Staff.
     */
    data: StaffCreateManyInput | StaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Staff update
   */
  export type StaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The data needed to update a Staff.
     */
    data: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
    /**
     * Choose, which Staff to update.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff updateMany
   */
  export type StaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to update.
     */
    limit?: number
  }

  /**
   * Staff updateManyAndReturn
   */
  export type StaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * The data used to update Staff.
     */
    data: XOR<StaffUpdateManyMutationInput, StaffUncheckedUpdateManyInput>
    /**
     * Filter which Staff to update
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to update.
     */
    limit?: number
  }

  /**
   * Staff upsert
   */
  export type StaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * The filter to search for the Staff to update in case it exists.
     */
    where: StaffWhereUniqueInput
    /**
     * In case the Staff found by the `where` argument doesn't exist, create a new Staff with this data.
     */
    create: XOR<StaffCreateInput, StaffUncheckedCreateInput>
    /**
     * In case the Staff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffUpdateInput, StaffUncheckedUpdateInput>
  }

  /**
   * Staff delete
   */
  export type StaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    /**
     * Filter which Staff to delete.
     */
    where: StaffWhereUniqueInput
  }

  /**
   * Staff deleteMany
   */
  export type StaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff to delete
     */
    where?: StaffWhereInput
    /**
     * Limit how many Staff to delete.
     */
    limit?: number
  }

  /**
   * Staff.assignments
   */
  export type Staff$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Staff.groupSessions
   */
  export type Staff$groupSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSession
     */
    select?: GroupSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSession
     */
    omit?: GroupSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionInclude<ExtArgs> | null
    where?: GroupSessionWhereInput
    orderBy?: GroupSessionOrderByWithRelationInput | GroupSessionOrderByWithRelationInput[]
    cursor?: GroupSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupSessionScalarFieldEnum | GroupSessionScalarFieldEnum[]
  }

  /**
   * Staff.changeLogs
   */
  export type Staff$changeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    where?: ChangeLogWhereInput
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    cursor?: ChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeLogScalarFieldEnum | ChangeLogScalarFieldEnum[]
  }

  /**
   * Staff.originalOverrides
   */
  export type Staff$originalOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyOverride
     */
    select?: DailyOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyOverride
     */
    omit?: DailyOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyOverrideInclude<ExtArgs> | null
    where?: DailyOverrideWhereInput
    orderBy?: DailyOverrideOrderByWithRelationInput | DailyOverrideOrderByWithRelationInput[]
    cursor?: DailyOverrideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyOverrideScalarFieldEnum | DailyOverrideScalarFieldEnum[]
  }

  /**
   * Staff.newOverrides
   */
  export type Staff$newOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyOverride
     */
    select?: DailyOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyOverride
     */
    omit?: DailyOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyOverrideInclude<ExtArgs> | null
    where?: DailyOverrideWhereInput
    orderBy?: DailyOverrideOrderByWithRelationInput | DailyOverrideOrderByWithRelationInput[]
    cursor?: DailyOverrideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyOverrideScalarFieldEnum | DailyOverrideScalarFieldEnum[]
  }

  /**
   * Staff without action
   */
  export type StaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    id: number | null
    authorizedHours: number | null
  }

  export type ClientSumAggregateOutputType = {
    id: number | null
    authorizedHours: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: number | null
    name: string | null
    authorizedHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: number | null
    name: string | null
    authorizedHours: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    locations: number
    authorizedHours: number
    availability: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    id?: true
    authorizedHours?: true
  }

  export type ClientSumAggregateInputType = {
    id?: true
    authorizedHours?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    authorizedHours?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    authorizedHours?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    locations?: true
    authorizedHours?: true
    availability?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: number
    name: string
    locations: string[]
    authorizedHours: number
    availability: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    locations?: boolean
    authorizedHours?: boolean
    availability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignments?: boolean | Client$assignmentsArgs<ExtArgs>
    groupSessionClients?: boolean | Client$groupSessionClientsArgs<ExtArgs>
    changeLogs?: boolean | Client$changeLogsArgs<ExtArgs>
    originalOverrides?: boolean | Client$originalOverridesArgs<ExtArgs>
    newOverrides?: boolean | Client$newOverridesArgs<ExtArgs>
    supervisorHistory?: boolean | Client$supervisorHistoryArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    locations?: boolean
    authorizedHours?: boolean
    availability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    locations?: boolean
    authorizedHours?: boolean
    availability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    name?: boolean
    locations?: boolean
    authorizedHours?: boolean
    availability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "locations" | "authorizedHours" | "availability" | "createdAt" | "updatedAt", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | Client$assignmentsArgs<ExtArgs>
    groupSessionClients?: boolean | Client$groupSessionClientsArgs<ExtArgs>
    changeLogs?: boolean | Client$changeLogsArgs<ExtArgs>
    originalOverrides?: boolean | Client$originalOverridesArgs<ExtArgs>
    newOverrides?: boolean | Client$newOverridesArgs<ExtArgs>
    supervisorHistory?: boolean | Client$supervisorHistoryArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      assignments: Prisma.$AssignmentPayload<ExtArgs>[]
      groupSessionClients: Prisma.$GroupSessionClientPayload<ExtArgs>[]
      changeLogs: Prisma.$ChangeLogPayload<ExtArgs>[]
      originalOverrides: Prisma.$DailyOverridePayload<ExtArgs>[]
      newOverrides: Prisma.$DailyOverridePayload<ExtArgs>[]
      supervisorHistory: Prisma.$ClientSupervisorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      locations: string[]
      authorizedHours: number
      availability: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignments<T extends Client$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Client$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groupSessionClients<T extends Client$groupSessionClientsArgs<ExtArgs> = {}>(args?: Subset<T, Client$groupSessionClientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupSessionClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    changeLogs<T extends Client$changeLogsArgs<ExtArgs> = {}>(args?: Subset<T, Client$changeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    originalOverrides<T extends Client$originalOverridesArgs<ExtArgs> = {}>(args?: Subset<T, Client$originalOverridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyOverridePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    newOverrides<T extends Client$newOverridesArgs<ExtArgs> = {}>(args?: Subset<T, Client$newOverridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyOverridePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    supervisorHistory<T extends Client$supervisorHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Client$supervisorHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSupervisorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'Int'>
    readonly name: FieldRef<"Client", 'String'>
    readonly locations: FieldRef<"Client", 'String[]'>
    readonly authorizedHours: FieldRef<"Client", 'Float'>
    readonly availability: FieldRef<"Client", 'Json'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.assignments
   */
  export type Client$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Client.groupSessionClients
   */
  export type Client$groupSessionClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSessionClient
     */
    select?: GroupSessionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSessionClient
     */
    omit?: GroupSessionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionClientInclude<ExtArgs> | null
    where?: GroupSessionClientWhereInput
    orderBy?: GroupSessionClientOrderByWithRelationInput | GroupSessionClientOrderByWithRelationInput[]
    cursor?: GroupSessionClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupSessionClientScalarFieldEnum | GroupSessionClientScalarFieldEnum[]
  }

  /**
   * Client.changeLogs
   */
  export type Client$changeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    where?: ChangeLogWhereInput
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    cursor?: ChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeLogScalarFieldEnum | ChangeLogScalarFieldEnum[]
  }

  /**
   * Client.originalOverrides
   */
  export type Client$originalOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyOverride
     */
    select?: DailyOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyOverride
     */
    omit?: DailyOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyOverrideInclude<ExtArgs> | null
    where?: DailyOverrideWhereInput
    orderBy?: DailyOverrideOrderByWithRelationInput | DailyOverrideOrderByWithRelationInput[]
    cursor?: DailyOverrideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyOverrideScalarFieldEnum | DailyOverrideScalarFieldEnum[]
  }

  /**
   * Client.newOverrides
   */
  export type Client$newOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyOverride
     */
    select?: DailyOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyOverride
     */
    omit?: DailyOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyOverrideInclude<ExtArgs> | null
    where?: DailyOverrideWhereInput
    orderBy?: DailyOverrideOrderByWithRelationInput | DailyOverrideOrderByWithRelationInput[]
    cursor?: DailyOverrideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyOverrideScalarFieldEnum | DailyOverrideScalarFieldEnum[]
  }

  /**
   * Client.supervisorHistory
   */
  export type Client$supervisorHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSupervisor
     */
    select?: ClientSupervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSupervisor
     */
    omit?: ClientSupervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSupervisorInclude<ExtArgs> | null
    where?: ClientSupervisorWhereInput
    orderBy?: ClientSupervisorOrderByWithRelationInput | ClientSupervisorOrderByWithRelationInput[]
    cursor?: ClientSupervisorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientSupervisorScalarFieldEnum | ClientSupervisorScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model ScheduleVersion
   */

  export type AggregateScheduleVersion = {
    _count: ScheduleVersionCountAggregateOutputType | null
    _avg: ScheduleVersionAvgAggregateOutputType | null
    _sum: ScheduleVersionSumAggregateOutputType | null
    _min: ScheduleVersionMinAggregateOutputType | null
    _max: ScheduleVersionMaxAggregateOutputType | null
  }

  export type ScheduleVersionAvgAggregateOutputType = {
    id: number | null
  }

  export type ScheduleVersionSumAggregateOutputType = {
    id: number | null
  }

  export type ScheduleVersionMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    status: string | null
    startDate: Date | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleVersionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    status: string | null
    startDate: Date | null
    description: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleVersionCountAggregateOutputType = {
    id: number
    name: number
    type: number
    status: number
    startDate: number
    description: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduleVersionAvgAggregateInputType = {
    id?: true
  }

  export type ScheduleVersionSumAggregateInputType = {
    id?: true
  }

  export type ScheduleVersionMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    startDate?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleVersionMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    startDate?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleVersionCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    status?: true
    startDate?: true
    description?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduleVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleVersion to aggregate.
     */
    where?: ScheduleVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleVersions to fetch.
     */
    orderBy?: ScheduleVersionOrderByWithRelationInput | ScheduleVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduleVersions
    **/
    _count?: true | ScheduleVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleVersionMaxAggregateInputType
  }

  export type GetScheduleVersionAggregateType<T extends ScheduleVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduleVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduleVersion[P]>
      : GetScalarType<T[P], AggregateScheduleVersion[P]>
  }




  export type ScheduleVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleVersionWhereInput
    orderBy?: ScheduleVersionOrderByWithAggregationInput | ScheduleVersionOrderByWithAggregationInput[]
    by: ScheduleVersionScalarFieldEnum[] | ScheduleVersionScalarFieldEnum
    having?: ScheduleVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleVersionCountAggregateInputType | true
    _avg?: ScheduleVersionAvgAggregateInputType
    _sum?: ScheduleVersionSumAggregateInputType
    _min?: ScheduleVersionMinAggregateInputType
    _max?: ScheduleVersionMaxAggregateInputType
  }

  export type ScheduleVersionGroupByOutputType = {
    id: number
    name: string
    type: string
    status: string
    startDate: Date | null
    description: string | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: ScheduleVersionCountAggregateOutputType | null
    _avg: ScheduleVersionAvgAggregateOutputType | null
    _sum: ScheduleVersionSumAggregateOutputType | null
    _min: ScheduleVersionMinAggregateOutputType | null
    _max: ScheduleVersionMaxAggregateOutputType | null
  }

  type GetScheduleVersionGroupByPayload<T extends ScheduleVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleVersionGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleVersionGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignments?: boolean | ScheduleVersion$assignmentsArgs<ExtArgs>
    groupSessions?: boolean | ScheduleVersion$groupSessionsArgs<ExtArgs>
    changeLogs?: boolean | ScheduleVersion$changeLogsArgs<ExtArgs>
    _count?: boolean | ScheduleVersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleVersion"]>

  export type ScheduleVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["scheduleVersion"]>

  export type ScheduleVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["scheduleVersion"]>

  export type ScheduleVersionSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    description?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduleVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "status" | "startDate" | "description" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["scheduleVersion"]>
  export type ScheduleVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | ScheduleVersion$assignmentsArgs<ExtArgs>
    groupSessions?: boolean | ScheduleVersion$groupSessionsArgs<ExtArgs>
    changeLogs?: boolean | ScheduleVersion$changeLogsArgs<ExtArgs>
    _count?: boolean | ScheduleVersionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScheduleVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ScheduleVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ScheduleVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduleVersion"
    objects: {
      assignments: Prisma.$AssignmentPayload<ExtArgs>[]
      groupSessions: Prisma.$GroupSessionPayload<ExtArgs>[]
      changeLogs: Prisma.$ChangeLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string
      status: string
      startDate: Date | null
      description: string | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scheduleVersion"]>
    composites: {}
  }

  type ScheduleVersionGetPayload<S extends boolean | null | undefined | ScheduleVersionDefaultArgs> = $Result.GetResult<Prisma.$ScheduleVersionPayload, S>

  type ScheduleVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleVersionCountAggregateInputType | true
    }

  export interface ScheduleVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduleVersion'], meta: { name: 'ScheduleVersion' } }
    /**
     * Find zero or one ScheduleVersion that matches the filter.
     * @param {ScheduleVersionFindUniqueArgs} args - Arguments to find a ScheduleVersion
     * @example
     * // Get one ScheduleVersion
     * const scheduleVersion = await prisma.scheduleVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleVersionFindUniqueArgs>(args: SelectSubset<T, ScheduleVersionFindUniqueArgs<ExtArgs>>): Prisma__ScheduleVersionClient<$Result.GetResult<Prisma.$ScheduleVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduleVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleVersionFindUniqueOrThrowArgs} args - Arguments to find a ScheduleVersion
     * @example
     * // Get one ScheduleVersion
     * const scheduleVersion = await prisma.scheduleVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleVersionClient<$Result.GetResult<Prisma.$ScheduleVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleVersionFindFirstArgs} args - Arguments to find a ScheduleVersion
     * @example
     * // Get one ScheduleVersion
     * const scheduleVersion = await prisma.scheduleVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleVersionFindFirstArgs>(args?: SelectSubset<T, ScheduleVersionFindFirstArgs<ExtArgs>>): Prisma__ScheduleVersionClient<$Result.GetResult<Prisma.$ScheduleVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleVersionFindFirstOrThrowArgs} args - Arguments to find a ScheduleVersion
     * @example
     * // Get one ScheduleVersion
     * const scheduleVersion = await prisma.scheduleVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleVersionClient<$Result.GetResult<Prisma.$ScheduleVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduleVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduleVersions
     * const scheduleVersions = await prisma.scheduleVersion.findMany()
     * 
     * // Get first 10 ScheduleVersions
     * const scheduleVersions = await prisma.scheduleVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleVersionWithIdOnly = await prisma.scheduleVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleVersionFindManyArgs>(args?: SelectSubset<T, ScheduleVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduleVersion.
     * @param {ScheduleVersionCreateArgs} args - Arguments to create a ScheduleVersion.
     * @example
     * // Create one ScheduleVersion
     * const ScheduleVersion = await prisma.scheduleVersion.create({
     *   data: {
     *     // ... data to create a ScheduleVersion
     *   }
     * })
     * 
     */
    create<T extends ScheduleVersionCreateArgs>(args: SelectSubset<T, ScheduleVersionCreateArgs<ExtArgs>>): Prisma__ScheduleVersionClient<$Result.GetResult<Prisma.$ScheduleVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduleVersions.
     * @param {ScheduleVersionCreateManyArgs} args - Arguments to create many ScheduleVersions.
     * @example
     * // Create many ScheduleVersions
     * const scheduleVersion = await prisma.scheduleVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleVersionCreateManyArgs>(args?: SelectSubset<T, ScheduleVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduleVersions and returns the data saved in the database.
     * @param {ScheduleVersionCreateManyAndReturnArgs} args - Arguments to create many ScheduleVersions.
     * @example
     * // Create many ScheduleVersions
     * const scheduleVersion = await prisma.scheduleVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduleVersions and only return the `id`
     * const scheduleVersionWithIdOnly = await prisma.scheduleVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScheduleVersion.
     * @param {ScheduleVersionDeleteArgs} args - Arguments to delete one ScheduleVersion.
     * @example
     * // Delete one ScheduleVersion
     * const ScheduleVersion = await prisma.scheduleVersion.delete({
     *   where: {
     *     // ... filter to delete one ScheduleVersion
     *   }
     * })
     * 
     */
    delete<T extends ScheduleVersionDeleteArgs>(args: SelectSubset<T, ScheduleVersionDeleteArgs<ExtArgs>>): Prisma__ScheduleVersionClient<$Result.GetResult<Prisma.$ScheduleVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduleVersion.
     * @param {ScheduleVersionUpdateArgs} args - Arguments to update one ScheduleVersion.
     * @example
     * // Update one ScheduleVersion
     * const scheduleVersion = await prisma.scheduleVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleVersionUpdateArgs>(args: SelectSubset<T, ScheduleVersionUpdateArgs<ExtArgs>>): Prisma__ScheduleVersionClient<$Result.GetResult<Prisma.$ScheduleVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduleVersions.
     * @param {ScheduleVersionDeleteManyArgs} args - Arguments to filter ScheduleVersions to delete.
     * @example
     * // Delete a few ScheduleVersions
     * const { count } = await prisma.scheduleVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleVersionDeleteManyArgs>(args?: SelectSubset<T, ScheduleVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduleVersions
     * const scheduleVersion = await prisma.scheduleVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleVersionUpdateManyArgs>(args: SelectSubset<T, ScheduleVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleVersions and returns the data updated in the database.
     * @param {ScheduleVersionUpdateManyAndReturnArgs} args - Arguments to update many ScheduleVersions.
     * @example
     * // Update many ScheduleVersions
     * const scheduleVersion = await prisma.scheduleVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScheduleVersions and only return the `id`
     * const scheduleVersionWithIdOnly = await prisma.scheduleVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScheduleVersion.
     * @param {ScheduleVersionUpsertArgs} args - Arguments to update or create a ScheduleVersion.
     * @example
     * // Update or create a ScheduleVersion
     * const scheduleVersion = await prisma.scheduleVersion.upsert({
     *   create: {
     *     // ... data to create a ScheduleVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduleVersion we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleVersionUpsertArgs>(args: SelectSubset<T, ScheduleVersionUpsertArgs<ExtArgs>>): Prisma__ScheduleVersionClient<$Result.GetResult<Prisma.$ScheduleVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScheduleVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleVersionCountArgs} args - Arguments to filter ScheduleVersions to count.
     * @example
     * // Count the number of ScheduleVersions
     * const count = await prisma.scheduleVersion.count({
     *   where: {
     *     // ... the filter for the ScheduleVersions we want to count
     *   }
     * })
    **/
    count<T extends ScheduleVersionCountArgs>(
      args?: Subset<T, ScheduleVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduleVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleVersionAggregateArgs>(args: Subset<T, ScheduleVersionAggregateArgs>): Prisma.PrismaPromise<GetScheduleVersionAggregateType<T>>

    /**
     * Group by ScheduleVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleVersionGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduleVersion model
   */
  readonly fields: ScheduleVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduleVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignments<T extends ScheduleVersion$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleVersion$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groupSessions<T extends ScheduleVersion$groupSessionsArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleVersion$groupSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    changeLogs<T extends ScheduleVersion$changeLogsArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleVersion$changeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduleVersion model
   */
  interface ScheduleVersionFieldRefs {
    readonly id: FieldRef<"ScheduleVersion", 'Int'>
    readonly name: FieldRef<"ScheduleVersion", 'String'>
    readonly type: FieldRef<"ScheduleVersion", 'String'>
    readonly status: FieldRef<"ScheduleVersion", 'String'>
    readonly startDate: FieldRef<"ScheduleVersion", 'DateTime'>
    readonly description: FieldRef<"ScheduleVersion", 'String'>
    readonly createdBy: FieldRef<"ScheduleVersion", 'String'>
    readonly createdAt: FieldRef<"ScheduleVersion", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduleVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduleVersion findUnique
   */
  export type ScheduleVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleVersion
     */
    select?: ScheduleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleVersion
     */
    omit?: ScheduleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleVersionInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleVersion to fetch.
     */
    where: ScheduleVersionWhereUniqueInput
  }

  /**
   * ScheduleVersion findUniqueOrThrow
   */
  export type ScheduleVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleVersion
     */
    select?: ScheduleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleVersion
     */
    omit?: ScheduleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleVersionInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleVersion to fetch.
     */
    where: ScheduleVersionWhereUniqueInput
  }

  /**
   * ScheduleVersion findFirst
   */
  export type ScheduleVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleVersion
     */
    select?: ScheduleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleVersion
     */
    omit?: ScheduleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleVersionInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleVersion to fetch.
     */
    where?: ScheduleVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleVersions to fetch.
     */
    orderBy?: ScheduleVersionOrderByWithRelationInput | ScheduleVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleVersions.
     */
    cursor?: ScheduleVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleVersions.
     */
    distinct?: ScheduleVersionScalarFieldEnum | ScheduleVersionScalarFieldEnum[]
  }

  /**
   * ScheduleVersion findFirstOrThrow
   */
  export type ScheduleVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleVersion
     */
    select?: ScheduleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleVersion
     */
    omit?: ScheduleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleVersionInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleVersion to fetch.
     */
    where?: ScheduleVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleVersions to fetch.
     */
    orderBy?: ScheduleVersionOrderByWithRelationInput | ScheduleVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleVersions.
     */
    cursor?: ScheduleVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleVersions.
     */
    distinct?: ScheduleVersionScalarFieldEnum | ScheduleVersionScalarFieldEnum[]
  }

  /**
   * ScheduleVersion findMany
   */
  export type ScheduleVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleVersion
     */
    select?: ScheduleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleVersion
     */
    omit?: ScheduleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleVersionInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleVersions to fetch.
     */
    where?: ScheduleVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleVersions to fetch.
     */
    orderBy?: ScheduleVersionOrderByWithRelationInput | ScheduleVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduleVersions.
     */
    cursor?: ScheduleVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduleVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleVersions.
     */
    skip?: number
    distinct?: ScheduleVersionScalarFieldEnum | ScheduleVersionScalarFieldEnum[]
  }

  /**
   * ScheduleVersion create
   */
  export type ScheduleVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleVersion
     */
    select?: ScheduleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleVersion
     */
    omit?: ScheduleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduleVersion.
     */
    data: XOR<ScheduleVersionCreateInput, ScheduleVersionUncheckedCreateInput>
  }

  /**
   * ScheduleVersion createMany
   */
  export type ScheduleVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduleVersions.
     */
    data: ScheduleVersionCreateManyInput | ScheduleVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduleVersion createManyAndReturn
   */
  export type ScheduleVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleVersion
     */
    select?: ScheduleVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleVersion
     */
    omit?: ScheduleVersionOmit<ExtArgs> | null
    /**
     * The data used to create many ScheduleVersions.
     */
    data: ScheduleVersionCreateManyInput | ScheduleVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduleVersion update
   */
  export type ScheduleVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleVersion
     */
    select?: ScheduleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleVersion
     */
    omit?: ScheduleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduleVersion.
     */
    data: XOR<ScheduleVersionUpdateInput, ScheduleVersionUncheckedUpdateInput>
    /**
     * Choose, which ScheduleVersion to update.
     */
    where: ScheduleVersionWhereUniqueInput
  }

  /**
   * ScheduleVersion updateMany
   */
  export type ScheduleVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduleVersions.
     */
    data: XOR<ScheduleVersionUpdateManyMutationInput, ScheduleVersionUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleVersions to update
     */
    where?: ScheduleVersionWhereInput
    /**
     * Limit how many ScheduleVersions to update.
     */
    limit?: number
  }

  /**
   * ScheduleVersion updateManyAndReturn
   */
  export type ScheduleVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleVersion
     */
    select?: ScheduleVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleVersion
     */
    omit?: ScheduleVersionOmit<ExtArgs> | null
    /**
     * The data used to update ScheduleVersions.
     */
    data: XOR<ScheduleVersionUpdateManyMutationInput, ScheduleVersionUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleVersions to update
     */
    where?: ScheduleVersionWhereInput
    /**
     * Limit how many ScheduleVersions to update.
     */
    limit?: number
  }

  /**
   * ScheduleVersion upsert
   */
  export type ScheduleVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleVersion
     */
    select?: ScheduleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleVersion
     */
    omit?: ScheduleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduleVersion to update in case it exists.
     */
    where: ScheduleVersionWhereUniqueInput
    /**
     * In case the ScheduleVersion found by the `where` argument doesn't exist, create a new ScheduleVersion with this data.
     */
    create: XOR<ScheduleVersionCreateInput, ScheduleVersionUncheckedCreateInput>
    /**
     * In case the ScheduleVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleVersionUpdateInput, ScheduleVersionUncheckedUpdateInput>
  }

  /**
   * ScheduleVersion delete
   */
  export type ScheduleVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleVersion
     */
    select?: ScheduleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleVersion
     */
    omit?: ScheduleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleVersionInclude<ExtArgs> | null
    /**
     * Filter which ScheduleVersion to delete.
     */
    where: ScheduleVersionWhereUniqueInput
  }

  /**
   * ScheduleVersion deleteMany
   */
  export type ScheduleVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleVersions to delete
     */
    where?: ScheduleVersionWhereInput
    /**
     * Limit how many ScheduleVersions to delete.
     */
    limit?: number
  }

  /**
   * ScheduleVersion.assignments
   */
  export type ScheduleVersion$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * ScheduleVersion.groupSessions
   */
  export type ScheduleVersion$groupSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSession
     */
    select?: GroupSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSession
     */
    omit?: GroupSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionInclude<ExtArgs> | null
    where?: GroupSessionWhereInput
    orderBy?: GroupSessionOrderByWithRelationInput | GroupSessionOrderByWithRelationInput[]
    cursor?: GroupSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupSessionScalarFieldEnum | GroupSessionScalarFieldEnum[]
  }

  /**
   * ScheduleVersion.changeLogs
   */
  export type ScheduleVersion$changeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    where?: ChangeLogWhereInput
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    cursor?: ChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeLogScalarFieldEnum | ChangeLogScalarFieldEnum[]
  }

  /**
   * ScheduleVersion without action
   */
  export type ScheduleVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleVersion
     */
    select?: ScheduleVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleVersion
     */
    omit?: ScheduleVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleVersionInclude<ExtArgs> | null
  }


  /**
   * Model Assignment
   */

  export type AggregateAssignment = {
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  export type AssignmentAvgAggregateOutputType = {
    id: number | null
    staffId: number | null
    clientId: number | null
    versionId: number | null
    groupSessionId: number | null
  }

  export type AssignmentSumAggregateOutputType = {
    id: number | null
    staffId: number | null
    clientId: number | null
    versionId: number | null
    groupSessionId: number | null
  }

  export type AssignmentMinAggregateOutputType = {
    id: number | null
    day: string | null
    block: string | null
    staffId: number | null
    clientId: number | null
    versionId: number | null
    isGroup: boolean | null
    groupSessionId: number | null
    plannedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssignmentMaxAggregateOutputType = {
    id: number | null
    day: string | null
    block: string | null
    staffId: number | null
    clientId: number | null
    versionId: number | null
    isGroup: boolean | null
    groupSessionId: number | null
    plannedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssignmentCountAggregateOutputType = {
    id: number
    day: number
    block: number
    staffId: number
    clientId: number
    versionId: number
    isGroup: number
    groupSessionId: number
    plannedDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssignmentAvgAggregateInputType = {
    id?: true
    staffId?: true
    clientId?: true
    versionId?: true
    groupSessionId?: true
  }

  export type AssignmentSumAggregateInputType = {
    id?: true
    staffId?: true
    clientId?: true
    versionId?: true
    groupSessionId?: true
  }

  export type AssignmentMinAggregateInputType = {
    id?: true
    day?: true
    block?: true
    staffId?: true
    clientId?: true
    versionId?: true
    isGroup?: true
    groupSessionId?: true
    plannedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssignmentMaxAggregateInputType = {
    id?: true
    day?: true
    block?: true
    staffId?: true
    clientId?: true
    versionId?: true
    isGroup?: true
    groupSessionId?: true
    plannedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssignmentCountAggregateInputType = {
    id?: true
    day?: true
    block?: true
    staffId?: true
    clientId?: true
    versionId?: true
    isGroup?: true
    groupSessionId?: true
    plannedDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignment to aggregate.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assignments
    **/
    _count?: true | AssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentMaxAggregateInputType
  }

  export type GetAssignmentAggregateType<T extends AssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignment[P]>
      : GetScalarType<T[P], AggregateAssignment[P]>
  }




  export type AssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithAggregationInput | AssignmentOrderByWithAggregationInput[]
    by: AssignmentScalarFieldEnum[] | AssignmentScalarFieldEnum
    having?: AssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentCountAggregateInputType | true
    _avg?: AssignmentAvgAggregateInputType
    _sum?: AssignmentSumAggregateInputType
    _min?: AssignmentMinAggregateInputType
    _max?: AssignmentMaxAggregateInputType
  }

  export type AssignmentGroupByOutputType = {
    id: number
    day: string
    block: string
    staffId: number
    clientId: number
    versionId: number
    isGroup: boolean
    groupSessionId: number | null
    plannedDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  type GetAssignmentGroupByPayload<T extends AssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    day?: boolean
    block?: boolean
    staffId?: boolean
    clientId?: boolean
    versionId?: boolean
    isGroup?: boolean
    groupSessionId?: boolean
    plannedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    version?: boolean | ScheduleVersionDefaultArgs<ExtArgs>
    groupSession?: boolean | Assignment$groupSessionArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    day?: boolean
    block?: boolean
    staffId?: boolean
    clientId?: boolean
    versionId?: boolean
    isGroup?: boolean
    groupSessionId?: boolean
    plannedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    version?: boolean | ScheduleVersionDefaultArgs<ExtArgs>
    groupSession?: boolean | Assignment$groupSessionArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    day?: boolean
    block?: boolean
    staffId?: boolean
    clientId?: boolean
    versionId?: boolean
    isGroup?: boolean
    groupSessionId?: boolean
    plannedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    version?: boolean | ScheduleVersionDefaultArgs<ExtArgs>
    groupSession?: boolean | Assignment$groupSessionArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectScalar = {
    id?: boolean
    day?: boolean
    block?: boolean
    staffId?: boolean
    clientId?: boolean
    versionId?: boolean
    isGroup?: boolean
    groupSessionId?: boolean
    plannedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "day" | "block" | "staffId" | "clientId" | "versionId" | "isGroup" | "groupSessionId" | "plannedDate" | "createdAt" | "updatedAt", ExtArgs["result"]["assignment"]>
  export type AssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    version?: boolean | ScheduleVersionDefaultArgs<ExtArgs>
    groupSession?: boolean | Assignment$groupSessionArgs<ExtArgs>
  }
  export type AssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    version?: boolean | ScheduleVersionDefaultArgs<ExtArgs>
    groupSession?: boolean | Assignment$groupSessionArgs<ExtArgs>
  }
  export type AssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    version?: boolean | ScheduleVersionDefaultArgs<ExtArgs>
    groupSession?: boolean | Assignment$groupSessionArgs<ExtArgs>
  }

  export type $AssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assignment"
    objects: {
      staff: Prisma.$StaffPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs>
      version: Prisma.$ScheduleVersionPayload<ExtArgs>
      groupSession: Prisma.$GroupSessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      day: string
      block: string
      staffId: number
      clientId: number
      versionId: number
      isGroup: boolean
      groupSessionId: number | null
      plannedDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["assignment"]>
    composites: {}
  }

  type AssignmentGetPayload<S extends boolean | null | undefined | AssignmentDefaultArgs> = $Result.GetResult<Prisma.$AssignmentPayload, S>

  type AssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssignmentCountAggregateInputType | true
    }

  export interface AssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assignment'], meta: { name: 'Assignment' } }
    /**
     * Find zero or one Assignment that matches the filter.
     * @param {AssignmentFindUniqueArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentFindUniqueArgs>(args: SelectSubset<T, AssignmentFindUniqueArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssignmentFindUniqueOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentFindFirstArgs>(args?: SelectSubset<T, AssignmentFindFirstArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignments
     * const assignments = await prisma.assignment.findMany()
     * 
     * // Get first 10 Assignments
     * const assignments = await prisma.assignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentWithIdOnly = await prisma.assignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignmentFindManyArgs>(args?: SelectSubset<T, AssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assignment.
     * @param {AssignmentCreateArgs} args - Arguments to create a Assignment.
     * @example
     * // Create one Assignment
     * const Assignment = await prisma.assignment.create({
     *   data: {
     *     // ... data to create a Assignment
     *   }
     * })
     * 
     */
    create<T extends AssignmentCreateArgs>(args: SelectSubset<T, AssignmentCreateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assignments.
     * @param {AssignmentCreateManyArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentCreateManyArgs>(args?: SelectSubset<T, AssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assignments and returns the data saved in the database.
     * @param {AssignmentCreateManyAndReturnArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assignments and only return the `id`
     * const assignmentWithIdOnly = await prisma.assignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Assignment.
     * @param {AssignmentDeleteArgs} args - Arguments to delete one Assignment.
     * @example
     * // Delete one Assignment
     * const Assignment = await prisma.assignment.delete({
     *   where: {
     *     // ... filter to delete one Assignment
     *   }
     * })
     * 
     */
    delete<T extends AssignmentDeleteArgs>(args: SelectSubset<T, AssignmentDeleteArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assignment.
     * @param {AssignmentUpdateArgs} args - Arguments to update one Assignment.
     * @example
     * // Update one Assignment
     * const assignment = await prisma.assignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentUpdateArgs>(args: SelectSubset<T, AssignmentUpdateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assignments.
     * @param {AssignmentDeleteManyArgs} args - Arguments to filter Assignments to delete.
     * @example
     * // Delete a few Assignments
     * const { count } = await prisma.assignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentDeleteManyArgs>(args?: SelectSubset<T, AssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentUpdateManyArgs>(args: SelectSubset<T, AssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments and returns the data updated in the database.
     * @param {AssignmentUpdateManyAndReturnArgs} args - Arguments to update many Assignments.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assignments and only return the `id`
     * const assignmentWithIdOnly = await prisma.assignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Assignment.
     * @param {AssignmentUpsertArgs} args - Arguments to update or create a Assignment.
     * @example
     * // Update or create a Assignment
     * const assignment = await prisma.assignment.upsert({
     *   create: {
     *     // ... data to create a Assignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignment we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentUpsertArgs>(args: SelectSubset<T, AssignmentUpsertArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentCountArgs} args - Arguments to filter Assignments to count.
     * @example
     * // Count the number of Assignments
     * const count = await prisma.assignment.count({
     *   where: {
     *     // ... the filter for the Assignments we want to count
     *   }
     * })
    **/
    count<T extends AssignmentCountArgs>(
      args?: Subset<T, AssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentAggregateArgs>(args: Subset<T, AssignmentAggregateArgs>): Prisma.PrismaPromise<GetAssignmentAggregateType<T>>

    /**
     * Group by Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assignment model
   */
  readonly fields: AssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staff<T extends StaffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffDefaultArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    version<T extends ScheduleVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleVersionDefaultArgs<ExtArgs>>): Prisma__ScheduleVersionClient<$Result.GetResult<Prisma.$ScheduleVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    groupSession<T extends Assignment$groupSessionArgs<ExtArgs> = {}>(args?: Subset<T, Assignment$groupSessionArgs<ExtArgs>>): Prisma__GroupSessionClient<$Result.GetResult<Prisma.$GroupSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assignment model
   */
  interface AssignmentFieldRefs {
    readonly id: FieldRef<"Assignment", 'Int'>
    readonly day: FieldRef<"Assignment", 'String'>
    readonly block: FieldRef<"Assignment", 'String'>
    readonly staffId: FieldRef<"Assignment", 'Int'>
    readonly clientId: FieldRef<"Assignment", 'Int'>
    readonly versionId: FieldRef<"Assignment", 'Int'>
    readonly isGroup: FieldRef<"Assignment", 'Boolean'>
    readonly groupSessionId: FieldRef<"Assignment", 'Int'>
    readonly plannedDate: FieldRef<"Assignment", 'DateTime'>
    readonly createdAt: FieldRef<"Assignment", 'DateTime'>
    readonly updatedAt: FieldRef<"Assignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Assignment findUnique
   */
  export type AssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findUniqueOrThrow
   */
  export type AssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findFirst
   */
  export type AssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findFirstOrThrow
   */
  export type AssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findMany
   */
  export type AssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignments to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment create
   */
  export type AssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Assignment.
     */
    data: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
  }

  /**
   * Assignment createMany
   */
  export type AssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assignment createManyAndReturn
   */
  export type AssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assignment update
   */
  export type AssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Assignment.
     */
    data: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
    /**
     * Choose, which Assignment to update.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment updateMany
   */
  export type AssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to update.
     */
    limit?: number
  }

  /**
   * Assignment updateManyAndReturn
   */
  export type AssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assignment upsert
   */
  export type AssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Assignment to update in case it exists.
     */
    where: AssignmentWhereUniqueInput
    /**
     * In case the Assignment found by the `where` argument doesn't exist, create a new Assignment with this data.
     */
    create: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
    /**
     * In case the Assignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
  }

  /**
   * Assignment delete
   */
  export type AssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter which Assignment to delete.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment deleteMany
   */
  export type AssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignments to delete
     */
    where?: AssignmentWhereInput
    /**
     * Limit how many Assignments to delete.
     */
    limit?: number
  }

  /**
   * Assignment.groupSession
   */
  export type Assignment$groupSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSession
     */
    select?: GroupSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSession
     */
    omit?: GroupSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionInclude<ExtArgs> | null
    where?: GroupSessionWhereInput
  }

  /**
   * Assignment without action
   */
  export type AssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
  }


  /**
   * Model GroupSession
   */

  export type AggregateGroupSession = {
    _count: GroupSessionCountAggregateOutputType | null
    _avg: GroupSessionAvgAggregateOutputType | null
    _sum: GroupSessionSumAggregateOutputType | null
    _min: GroupSessionMinAggregateOutputType | null
    _max: GroupSessionMaxAggregateOutputType | null
  }

  export type GroupSessionAvgAggregateOutputType = {
    id: number | null
    staffId: number | null
    versionId: number | null
    maxSize: number | null
  }

  export type GroupSessionSumAggregateOutputType = {
    id: number | null
    staffId: number | null
    versionId: number | null
    maxSize: number | null
  }

  export type GroupSessionMinAggregateOutputType = {
    id: number | null
    day: string | null
    block: string | null
    staffId: number | null
    versionId: number | null
    location: string | null
    maxSize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupSessionMaxAggregateOutputType = {
    id: number | null
    day: string | null
    block: string | null
    staffId: number | null
    versionId: number | null
    location: string | null
    maxSize: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupSessionCountAggregateOutputType = {
    id: number
    day: number
    block: number
    staffId: number
    versionId: number
    location: number
    maxSize: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupSessionAvgAggregateInputType = {
    id?: true
    staffId?: true
    versionId?: true
    maxSize?: true
  }

  export type GroupSessionSumAggregateInputType = {
    id?: true
    staffId?: true
    versionId?: true
    maxSize?: true
  }

  export type GroupSessionMinAggregateInputType = {
    id?: true
    day?: true
    block?: true
    staffId?: true
    versionId?: true
    location?: true
    maxSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupSessionMaxAggregateInputType = {
    id?: true
    day?: true
    block?: true
    staffId?: true
    versionId?: true
    location?: true
    maxSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupSessionCountAggregateInputType = {
    id?: true
    day?: true
    block?: true
    staffId?: true
    versionId?: true
    location?: true
    maxSize?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupSession to aggregate.
     */
    where?: GroupSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupSessions to fetch.
     */
    orderBy?: GroupSessionOrderByWithRelationInput | GroupSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupSessions
    **/
    _count?: true | GroupSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupSessionMaxAggregateInputType
  }

  export type GetGroupSessionAggregateType<T extends GroupSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupSession[P]>
      : GetScalarType<T[P], AggregateGroupSession[P]>
  }




  export type GroupSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupSessionWhereInput
    orderBy?: GroupSessionOrderByWithAggregationInput | GroupSessionOrderByWithAggregationInput[]
    by: GroupSessionScalarFieldEnum[] | GroupSessionScalarFieldEnum
    having?: GroupSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupSessionCountAggregateInputType | true
    _avg?: GroupSessionAvgAggregateInputType
    _sum?: GroupSessionSumAggregateInputType
    _min?: GroupSessionMinAggregateInputType
    _max?: GroupSessionMaxAggregateInputType
  }

  export type GroupSessionGroupByOutputType = {
    id: number
    day: string
    block: string
    staffId: number
    versionId: number
    location: string
    maxSize: number
    createdAt: Date
    updatedAt: Date
    _count: GroupSessionCountAggregateOutputType | null
    _avg: GroupSessionAvgAggregateOutputType | null
    _sum: GroupSessionSumAggregateOutputType | null
    _min: GroupSessionMinAggregateOutputType | null
    _max: GroupSessionMaxAggregateOutputType | null
  }

  type GetGroupSessionGroupByPayload<T extends GroupSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupSessionGroupByOutputType[P]>
            : GetScalarType<T[P], GroupSessionGroupByOutputType[P]>
        }
      >
    >


  export type GroupSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    day?: boolean
    block?: boolean
    staffId?: boolean
    versionId?: boolean
    location?: boolean
    maxSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    version?: boolean | ScheduleVersionDefaultArgs<ExtArgs>
    clients?: boolean | GroupSession$clientsArgs<ExtArgs>
    assignments?: boolean | GroupSession$assignmentsArgs<ExtArgs>
    _count?: boolean | GroupSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupSession"]>

  export type GroupSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    day?: boolean
    block?: boolean
    staffId?: boolean
    versionId?: boolean
    location?: boolean
    maxSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    version?: boolean | ScheduleVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupSession"]>

  export type GroupSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    day?: boolean
    block?: boolean
    staffId?: boolean
    versionId?: boolean
    location?: boolean
    maxSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    version?: boolean | ScheduleVersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupSession"]>

  export type GroupSessionSelectScalar = {
    id?: boolean
    day?: boolean
    block?: boolean
    staffId?: boolean
    versionId?: boolean
    location?: boolean
    maxSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GroupSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "day" | "block" | "staffId" | "versionId" | "location" | "maxSize" | "createdAt" | "updatedAt", ExtArgs["result"]["groupSession"]>
  export type GroupSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    version?: boolean | ScheduleVersionDefaultArgs<ExtArgs>
    clients?: boolean | GroupSession$clientsArgs<ExtArgs>
    assignments?: boolean | GroupSession$assignmentsArgs<ExtArgs>
    _count?: boolean | GroupSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GroupSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    version?: boolean | ScheduleVersionDefaultArgs<ExtArgs>
  }
  export type GroupSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffDefaultArgs<ExtArgs>
    version?: boolean | ScheduleVersionDefaultArgs<ExtArgs>
  }

  export type $GroupSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupSession"
    objects: {
      staff: Prisma.$StaffPayload<ExtArgs>
      version: Prisma.$ScheduleVersionPayload<ExtArgs>
      clients: Prisma.$GroupSessionClientPayload<ExtArgs>[]
      assignments: Prisma.$AssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      day: string
      block: string
      staffId: number
      versionId: number
      location: string
      maxSize: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["groupSession"]>
    composites: {}
  }

  type GroupSessionGetPayload<S extends boolean | null | undefined | GroupSessionDefaultArgs> = $Result.GetResult<Prisma.$GroupSessionPayload, S>

  type GroupSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupSessionCountAggregateInputType | true
    }

  export interface GroupSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupSession'], meta: { name: 'GroupSession' } }
    /**
     * Find zero or one GroupSession that matches the filter.
     * @param {GroupSessionFindUniqueArgs} args - Arguments to find a GroupSession
     * @example
     * // Get one GroupSession
     * const groupSession = await prisma.groupSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupSessionFindUniqueArgs>(args: SelectSubset<T, GroupSessionFindUniqueArgs<ExtArgs>>): Prisma__GroupSessionClient<$Result.GetResult<Prisma.$GroupSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupSessionFindUniqueOrThrowArgs} args - Arguments to find a GroupSession
     * @example
     * // Get one GroupSession
     * const groupSession = await prisma.groupSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupSessionClient<$Result.GetResult<Prisma.$GroupSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSessionFindFirstArgs} args - Arguments to find a GroupSession
     * @example
     * // Get one GroupSession
     * const groupSession = await prisma.groupSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupSessionFindFirstArgs>(args?: SelectSubset<T, GroupSessionFindFirstArgs<ExtArgs>>): Prisma__GroupSessionClient<$Result.GetResult<Prisma.$GroupSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSessionFindFirstOrThrowArgs} args - Arguments to find a GroupSession
     * @example
     * // Get one GroupSession
     * const groupSession = await prisma.groupSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupSessionClient<$Result.GetResult<Prisma.$GroupSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupSessions
     * const groupSessions = await prisma.groupSession.findMany()
     * 
     * // Get first 10 GroupSessions
     * const groupSessions = await prisma.groupSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupSessionWithIdOnly = await prisma.groupSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupSessionFindManyArgs>(args?: SelectSubset<T, GroupSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupSession.
     * @param {GroupSessionCreateArgs} args - Arguments to create a GroupSession.
     * @example
     * // Create one GroupSession
     * const GroupSession = await prisma.groupSession.create({
     *   data: {
     *     // ... data to create a GroupSession
     *   }
     * })
     * 
     */
    create<T extends GroupSessionCreateArgs>(args: SelectSubset<T, GroupSessionCreateArgs<ExtArgs>>): Prisma__GroupSessionClient<$Result.GetResult<Prisma.$GroupSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupSessions.
     * @param {GroupSessionCreateManyArgs} args - Arguments to create many GroupSessions.
     * @example
     * // Create many GroupSessions
     * const groupSession = await prisma.groupSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupSessionCreateManyArgs>(args?: SelectSubset<T, GroupSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupSessions and returns the data saved in the database.
     * @param {GroupSessionCreateManyAndReturnArgs} args - Arguments to create many GroupSessions.
     * @example
     * // Create many GroupSessions
     * const groupSession = await prisma.groupSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupSessions and only return the `id`
     * const groupSessionWithIdOnly = await prisma.groupSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupSession.
     * @param {GroupSessionDeleteArgs} args - Arguments to delete one GroupSession.
     * @example
     * // Delete one GroupSession
     * const GroupSession = await prisma.groupSession.delete({
     *   where: {
     *     // ... filter to delete one GroupSession
     *   }
     * })
     * 
     */
    delete<T extends GroupSessionDeleteArgs>(args: SelectSubset<T, GroupSessionDeleteArgs<ExtArgs>>): Prisma__GroupSessionClient<$Result.GetResult<Prisma.$GroupSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupSession.
     * @param {GroupSessionUpdateArgs} args - Arguments to update one GroupSession.
     * @example
     * // Update one GroupSession
     * const groupSession = await prisma.groupSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupSessionUpdateArgs>(args: SelectSubset<T, GroupSessionUpdateArgs<ExtArgs>>): Prisma__GroupSessionClient<$Result.GetResult<Prisma.$GroupSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupSessions.
     * @param {GroupSessionDeleteManyArgs} args - Arguments to filter GroupSessions to delete.
     * @example
     * // Delete a few GroupSessions
     * const { count } = await prisma.groupSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupSessionDeleteManyArgs>(args?: SelectSubset<T, GroupSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupSessions
     * const groupSession = await prisma.groupSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupSessionUpdateManyArgs>(args: SelectSubset<T, GroupSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupSessions and returns the data updated in the database.
     * @param {GroupSessionUpdateManyAndReturnArgs} args - Arguments to update many GroupSessions.
     * @example
     * // Update many GroupSessions
     * const groupSession = await prisma.groupSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupSessions and only return the `id`
     * const groupSessionWithIdOnly = await prisma.groupSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupSession.
     * @param {GroupSessionUpsertArgs} args - Arguments to update or create a GroupSession.
     * @example
     * // Update or create a GroupSession
     * const groupSession = await prisma.groupSession.upsert({
     *   create: {
     *     // ... data to create a GroupSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupSession we want to update
     *   }
     * })
     */
    upsert<T extends GroupSessionUpsertArgs>(args: SelectSubset<T, GroupSessionUpsertArgs<ExtArgs>>): Prisma__GroupSessionClient<$Result.GetResult<Prisma.$GroupSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSessionCountArgs} args - Arguments to filter GroupSessions to count.
     * @example
     * // Count the number of GroupSessions
     * const count = await prisma.groupSession.count({
     *   where: {
     *     // ... the filter for the GroupSessions we want to count
     *   }
     * })
    **/
    count<T extends GroupSessionCountArgs>(
      args?: Subset<T, GroupSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupSessionAggregateArgs>(args: Subset<T, GroupSessionAggregateArgs>): Prisma.PrismaPromise<GetGroupSessionAggregateType<T>>

    /**
     * Group by GroupSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupSessionGroupByArgs['orderBy'] }
        : { orderBy?: GroupSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupSession model
   */
  readonly fields: GroupSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staff<T extends StaffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffDefaultArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    version<T extends ScheduleVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleVersionDefaultArgs<ExtArgs>>): Prisma__ScheduleVersionClient<$Result.GetResult<Prisma.$ScheduleVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clients<T extends GroupSession$clientsArgs<ExtArgs> = {}>(args?: Subset<T, GroupSession$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupSessionClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignments<T extends GroupSession$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, GroupSession$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupSession model
   */
  interface GroupSessionFieldRefs {
    readonly id: FieldRef<"GroupSession", 'Int'>
    readonly day: FieldRef<"GroupSession", 'String'>
    readonly block: FieldRef<"GroupSession", 'String'>
    readonly staffId: FieldRef<"GroupSession", 'Int'>
    readonly versionId: FieldRef<"GroupSession", 'Int'>
    readonly location: FieldRef<"GroupSession", 'String'>
    readonly maxSize: FieldRef<"GroupSession", 'Int'>
    readonly createdAt: FieldRef<"GroupSession", 'DateTime'>
    readonly updatedAt: FieldRef<"GroupSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupSession findUnique
   */
  export type GroupSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSession
     */
    select?: GroupSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSession
     */
    omit?: GroupSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionInclude<ExtArgs> | null
    /**
     * Filter, which GroupSession to fetch.
     */
    where: GroupSessionWhereUniqueInput
  }

  /**
   * GroupSession findUniqueOrThrow
   */
  export type GroupSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSession
     */
    select?: GroupSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSession
     */
    omit?: GroupSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionInclude<ExtArgs> | null
    /**
     * Filter, which GroupSession to fetch.
     */
    where: GroupSessionWhereUniqueInput
  }

  /**
   * GroupSession findFirst
   */
  export type GroupSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSession
     */
    select?: GroupSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSession
     */
    omit?: GroupSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionInclude<ExtArgs> | null
    /**
     * Filter, which GroupSession to fetch.
     */
    where?: GroupSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupSessions to fetch.
     */
    orderBy?: GroupSessionOrderByWithRelationInput | GroupSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupSessions.
     */
    cursor?: GroupSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupSessions.
     */
    distinct?: GroupSessionScalarFieldEnum | GroupSessionScalarFieldEnum[]
  }

  /**
   * GroupSession findFirstOrThrow
   */
  export type GroupSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSession
     */
    select?: GroupSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSession
     */
    omit?: GroupSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionInclude<ExtArgs> | null
    /**
     * Filter, which GroupSession to fetch.
     */
    where?: GroupSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupSessions to fetch.
     */
    orderBy?: GroupSessionOrderByWithRelationInput | GroupSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupSessions.
     */
    cursor?: GroupSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupSessions.
     */
    distinct?: GroupSessionScalarFieldEnum | GroupSessionScalarFieldEnum[]
  }

  /**
   * GroupSession findMany
   */
  export type GroupSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSession
     */
    select?: GroupSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSession
     */
    omit?: GroupSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionInclude<ExtArgs> | null
    /**
     * Filter, which GroupSessions to fetch.
     */
    where?: GroupSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupSessions to fetch.
     */
    orderBy?: GroupSessionOrderByWithRelationInput | GroupSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupSessions.
     */
    cursor?: GroupSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupSessions.
     */
    skip?: number
    distinct?: GroupSessionScalarFieldEnum | GroupSessionScalarFieldEnum[]
  }

  /**
   * GroupSession create
   */
  export type GroupSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSession
     */
    select?: GroupSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSession
     */
    omit?: GroupSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupSession.
     */
    data: XOR<GroupSessionCreateInput, GroupSessionUncheckedCreateInput>
  }

  /**
   * GroupSession createMany
   */
  export type GroupSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupSessions.
     */
    data: GroupSessionCreateManyInput | GroupSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupSession createManyAndReturn
   */
  export type GroupSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSession
     */
    select?: GroupSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSession
     */
    omit?: GroupSessionOmit<ExtArgs> | null
    /**
     * The data used to create many GroupSessions.
     */
    data: GroupSessionCreateManyInput | GroupSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupSession update
   */
  export type GroupSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSession
     */
    select?: GroupSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSession
     */
    omit?: GroupSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupSession.
     */
    data: XOR<GroupSessionUpdateInput, GroupSessionUncheckedUpdateInput>
    /**
     * Choose, which GroupSession to update.
     */
    where: GroupSessionWhereUniqueInput
  }

  /**
   * GroupSession updateMany
   */
  export type GroupSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupSessions.
     */
    data: XOR<GroupSessionUpdateManyMutationInput, GroupSessionUncheckedUpdateManyInput>
    /**
     * Filter which GroupSessions to update
     */
    where?: GroupSessionWhereInput
    /**
     * Limit how many GroupSessions to update.
     */
    limit?: number
  }

  /**
   * GroupSession updateManyAndReturn
   */
  export type GroupSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSession
     */
    select?: GroupSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSession
     */
    omit?: GroupSessionOmit<ExtArgs> | null
    /**
     * The data used to update GroupSessions.
     */
    data: XOR<GroupSessionUpdateManyMutationInput, GroupSessionUncheckedUpdateManyInput>
    /**
     * Filter which GroupSessions to update
     */
    where?: GroupSessionWhereInput
    /**
     * Limit how many GroupSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupSession upsert
   */
  export type GroupSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSession
     */
    select?: GroupSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSession
     */
    omit?: GroupSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupSession to update in case it exists.
     */
    where: GroupSessionWhereUniqueInput
    /**
     * In case the GroupSession found by the `where` argument doesn't exist, create a new GroupSession with this data.
     */
    create: XOR<GroupSessionCreateInput, GroupSessionUncheckedCreateInput>
    /**
     * In case the GroupSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupSessionUpdateInput, GroupSessionUncheckedUpdateInput>
  }

  /**
   * GroupSession delete
   */
  export type GroupSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSession
     */
    select?: GroupSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSession
     */
    omit?: GroupSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionInclude<ExtArgs> | null
    /**
     * Filter which GroupSession to delete.
     */
    where: GroupSessionWhereUniqueInput
  }

  /**
   * GroupSession deleteMany
   */
  export type GroupSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupSessions to delete
     */
    where?: GroupSessionWhereInput
    /**
     * Limit how many GroupSessions to delete.
     */
    limit?: number
  }

  /**
   * GroupSession.clients
   */
  export type GroupSession$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSessionClient
     */
    select?: GroupSessionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSessionClient
     */
    omit?: GroupSessionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionClientInclude<ExtArgs> | null
    where?: GroupSessionClientWhereInput
    orderBy?: GroupSessionClientOrderByWithRelationInput | GroupSessionClientOrderByWithRelationInput[]
    cursor?: GroupSessionClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupSessionClientScalarFieldEnum | GroupSessionClientScalarFieldEnum[]
  }

  /**
   * GroupSession.assignments
   */
  export type GroupSession$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assignment
     */
    omit?: AssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * GroupSession without action
   */
  export type GroupSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSession
     */
    select?: GroupSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSession
     */
    omit?: GroupSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionInclude<ExtArgs> | null
  }


  /**
   * Model GroupSessionClient
   */

  export type AggregateGroupSessionClient = {
    _count: GroupSessionClientCountAggregateOutputType | null
    _avg: GroupSessionClientAvgAggregateOutputType | null
    _sum: GroupSessionClientSumAggregateOutputType | null
    _min: GroupSessionClientMinAggregateOutputType | null
    _max: GroupSessionClientMaxAggregateOutputType | null
  }

  export type GroupSessionClientAvgAggregateOutputType = {
    id: number | null
    groupSessionId: number | null
    clientId: number | null
  }

  export type GroupSessionClientSumAggregateOutputType = {
    id: number | null
    groupSessionId: number | null
    clientId: number | null
  }

  export type GroupSessionClientMinAggregateOutputType = {
    id: number | null
    groupSessionId: number | null
    clientId: number | null
  }

  export type GroupSessionClientMaxAggregateOutputType = {
    id: number | null
    groupSessionId: number | null
    clientId: number | null
  }

  export type GroupSessionClientCountAggregateOutputType = {
    id: number
    groupSessionId: number
    clientId: number
    _all: number
  }


  export type GroupSessionClientAvgAggregateInputType = {
    id?: true
    groupSessionId?: true
    clientId?: true
  }

  export type GroupSessionClientSumAggregateInputType = {
    id?: true
    groupSessionId?: true
    clientId?: true
  }

  export type GroupSessionClientMinAggregateInputType = {
    id?: true
    groupSessionId?: true
    clientId?: true
  }

  export type GroupSessionClientMaxAggregateInputType = {
    id?: true
    groupSessionId?: true
    clientId?: true
  }

  export type GroupSessionClientCountAggregateInputType = {
    id?: true
    groupSessionId?: true
    clientId?: true
    _all?: true
  }

  export type GroupSessionClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupSessionClient to aggregate.
     */
    where?: GroupSessionClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupSessionClients to fetch.
     */
    orderBy?: GroupSessionClientOrderByWithRelationInput | GroupSessionClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupSessionClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupSessionClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupSessionClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupSessionClients
    **/
    _count?: true | GroupSessionClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupSessionClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupSessionClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupSessionClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupSessionClientMaxAggregateInputType
  }

  export type GetGroupSessionClientAggregateType<T extends GroupSessionClientAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupSessionClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupSessionClient[P]>
      : GetScalarType<T[P], AggregateGroupSessionClient[P]>
  }




  export type GroupSessionClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupSessionClientWhereInput
    orderBy?: GroupSessionClientOrderByWithAggregationInput | GroupSessionClientOrderByWithAggregationInput[]
    by: GroupSessionClientScalarFieldEnum[] | GroupSessionClientScalarFieldEnum
    having?: GroupSessionClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupSessionClientCountAggregateInputType | true
    _avg?: GroupSessionClientAvgAggregateInputType
    _sum?: GroupSessionClientSumAggregateInputType
    _min?: GroupSessionClientMinAggregateInputType
    _max?: GroupSessionClientMaxAggregateInputType
  }

  export type GroupSessionClientGroupByOutputType = {
    id: number
    groupSessionId: number
    clientId: number
    _count: GroupSessionClientCountAggregateOutputType | null
    _avg: GroupSessionClientAvgAggregateOutputType | null
    _sum: GroupSessionClientSumAggregateOutputType | null
    _min: GroupSessionClientMinAggregateOutputType | null
    _max: GroupSessionClientMaxAggregateOutputType | null
  }

  type GetGroupSessionClientGroupByPayload<T extends GroupSessionClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupSessionClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupSessionClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupSessionClientGroupByOutputType[P]>
            : GetScalarType<T[P], GroupSessionClientGroupByOutputType[P]>
        }
      >
    >


  export type GroupSessionClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupSessionId?: boolean
    clientId?: boolean
    groupSession?: boolean | GroupSessionDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupSessionClient"]>

  export type GroupSessionClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupSessionId?: boolean
    clientId?: boolean
    groupSession?: boolean | GroupSessionDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupSessionClient"]>

  export type GroupSessionClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupSessionId?: boolean
    clientId?: boolean
    groupSession?: boolean | GroupSessionDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groupSessionClient"]>

  export type GroupSessionClientSelectScalar = {
    id?: boolean
    groupSessionId?: boolean
    clientId?: boolean
  }

  export type GroupSessionClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupSessionId" | "clientId", ExtArgs["result"]["groupSessionClient"]>
  export type GroupSessionClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupSession?: boolean | GroupSessionDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type GroupSessionClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupSession?: boolean | GroupSessionDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type GroupSessionClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupSession?: boolean | GroupSessionDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $GroupSessionClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupSessionClient"
    objects: {
      groupSession: Prisma.$GroupSessionPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      groupSessionId: number
      clientId: number
    }, ExtArgs["result"]["groupSessionClient"]>
    composites: {}
  }

  type GroupSessionClientGetPayload<S extends boolean | null | undefined | GroupSessionClientDefaultArgs> = $Result.GetResult<Prisma.$GroupSessionClientPayload, S>

  type GroupSessionClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GroupSessionClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupSessionClientCountAggregateInputType | true
    }

  export interface GroupSessionClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupSessionClient'], meta: { name: 'GroupSessionClient' } }
    /**
     * Find zero or one GroupSessionClient that matches the filter.
     * @param {GroupSessionClientFindUniqueArgs} args - Arguments to find a GroupSessionClient
     * @example
     * // Get one GroupSessionClient
     * const groupSessionClient = await prisma.groupSessionClient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupSessionClientFindUniqueArgs>(args: SelectSubset<T, GroupSessionClientFindUniqueArgs<ExtArgs>>): Prisma__GroupSessionClientClient<$Result.GetResult<Prisma.$GroupSessionClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GroupSessionClient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GroupSessionClientFindUniqueOrThrowArgs} args - Arguments to find a GroupSessionClient
     * @example
     * // Get one GroupSessionClient
     * const groupSessionClient = await prisma.groupSessionClient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupSessionClientFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupSessionClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupSessionClientClient<$Result.GetResult<Prisma.$GroupSessionClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupSessionClient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSessionClientFindFirstArgs} args - Arguments to find a GroupSessionClient
     * @example
     * // Get one GroupSessionClient
     * const groupSessionClient = await prisma.groupSessionClient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupSessionClientFindFirstArgs>(args?: SelectSubset<T, GroupSessionClientFindFirstArgs<ExtArgs>>): Prisma__GroupSessionClientClient<$Result.GetResult<Prisma.$GroupSessionClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GroupSessionClient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSessionClientFindFirstOrThrowArgs} args - Arguments to find a GroupSessionClient
     * @example
     * // Get one GroupSessionClient
     * const groupSessionClient = await prisma.groupSessionClient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupSessionClientFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupSessionClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupSessionClientClient<$Result.GetResult<Prisma.$GroupSessionClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GroupSessionClients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSessionClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupSessionClients
     * const groupSessionClients = await prisma.groupSessionClient.findMany()
     * 
     * // Get first 10 GroupSessionClients
     * const groupSessionClients = await prisma.groupSessionClient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupSessionClientWithIdOnly = await prisma.groupSessionClient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupSessionClientFindManyArgs>(args?: SelectSubset<T, GroupSessionClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupSessionClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GroupSessionClient.
     * @param {GroupSessionClientCreateArgs} args - Arguments to create a GroupSessionClient.
     * @example
     * // Create one GroupSessionClient
     * const GroupSessionClient = await prisma.groupSessionClient.create({
     *   data: {
     *     // ... data to create a GroupSessionClient
     *   }
     * })
     * 
     */
    create<T extends GroupSessionClientCreateArgs>(args: SelectSubset<T, GroupSessionClientCreateArgs<ExtArgs>>): Prisma__GroupSessionClientClient<$Result.GetResult<Prisma.$GroupSessionClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GroupSessionClients.
     * @param {GroupSessionClientCreateManyArgs} args - Arguments to create many GroupSessionClients.
     * @example
     * // Create many GroupSessionClients
     * const groupSessionClient = await prisma.groupSessionClient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupSessionClientCreateManyArgs>(args?: SelectSubset<T, GroupSessionClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GroupSessionClients and returns the data saved in the database.
     * @param {GroupSessionClientCreateManyAndReturnArgs} args - Arguments to create many GroupSessionClients.
     * @example
     * // Create many GroupSessionClients
     * const groupSessionClient = await prisma.groupSessionClient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GroupSessionClients and only return the `id`
     * const groupSessionClientWithIdOnly = await prisma.groupSessionClient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GroupSessionClientCreateManyAndReturnArgs>(args?: SelectSubset<T, GroupSessionClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupSessionClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GroupSessionClient.
     * @param {GroupSessionClientDeleteArgs} args - Arguments to delete one GroupSessionClient.
     * @example
     * // Delete one GroupSessionClient
     * const GroupSessionClient = await prisma.groupSessionClient.delete({
     *   where: {
     *     // ... filter to delete one GroupSessionClient
     *   }
     * })
     * 
     */
    delete<T extends GroupSessionClientDeleteArgs>(args: SelectSubset<T, GroupSessionClientDeleteArgs<ExtArgs>>): Prisma__GroupSessionClientClient<$Result.GetResult<Prisma.$GroupSessionClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GroupSessionClient.
     * @param {GroupSessionClientUpdateArgs} args - Arguments to update one GroupSessionClient.
     * @example
     * // Update one GroupSessionClient
     * const groupSessionClient = await prisma.groupSessionClient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupSessionClientUpdateArgs>(args: SelectSubset<T, GroupSessionClientUpdateArgs<ExtArgs>>): Prisma__GroupSessionClientClient<$Result.GetResult<Prisma.$GroupSessionClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GroupSessionClients.
     * @param {GroupSessionClientDeleteManyArgs} args - Arguments to filter GroupSessionClients to delete.
     * @example
     * // Delete a few GroupSessionClients
     * const { count } = await prisma.groupSessionClient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupSessionClientDeleteManyArgs>(args?: SelectSubset<T, GroupSessionClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupSessionClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSessionClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupSessionClients
     * const groupSessionClient = await prisma.groupSessionClient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupSessionClientUpdateManyArgs>(args: SelectSubset<T, GroupSessionClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupSessionClients and returns the data updated in the database.
     * @param {GroupSessionClientUpdateManyAndReturnArgs} args - Arguments to update many GroupSessionClients.
     * @example
     * // Update many GroupSessionClients
     * const groupSessionClient = await prisma.groupSessionClient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GroupSessionClients and only return the `id`
     * const groupSessionClientWithIdOnly = await prisma.groupSessionClient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GroupSessionClientUpdateManyAndReturnArgs>(args: SelectSubset<T, GroupSessionClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupSessionClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GroupSessionClient.
     * @param {GroupSessionClientUpsertArgs} args - Arguments to update or create a GroupSessionClient.
     * @example
     * // Update or create a GroupSessionClient
     * const groupSessionClient = await prisma.groupSessionClient.upsert({
     *   create: {
     *     // ... data to create a GroupSessionClient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupSessionClient we want to update
     *   }
     * })
     */
    upsert<T extends GroupSessionClientUpsertArgs>(args: SelectSubset<T, GroupSessionClientUpsertArgs<ExtArgs>>): Prisma__GroupSessionClientClient<$Result.GetResult<Prisma.$GroupSessionClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GroupSessionClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSessionClientCountArgs} args - Arguments to filter GroupSessionClients to count.
     * @example
     * // Count the number of GroupSessionClients
     * const count = await prisma.groupSessionClient.count({
     *   where: {
     *     // ... the filter for the GroupSessionClients we want to count
     *   }
     * })
    **/
    count<T extends GroupSessionClientCountArgs>(
      args?: Subset<T, GroupSessionClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupSessionClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupSessionClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSessionClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupSessionClientAggregateArgs>(args: Subset<T, GroupSessionClientAggregateArgs>): Prisma.PrismaPromise<GetGroupSessionClientAggregateType<T>>

    /**
     * Group by GroupSessionClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupSessionClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupSessionClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupSessionClientGroupByArgs['orderBy'] }
        : { orderBy?: GroupSessionClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupSessionClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupSessionClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupSessionClient model
   */
  readonly fields: GroupSessionClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupSessionClient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupSessionClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    groupSession<T extends GroupSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupSessionDefaultArgs<ExtArgs>>): Prisma__GroupSessionClient<$Result.GetResult<Prisma.$GroupSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupSessionClient model
   */
  interface GroupSessionClientFieldRefs {
    readonly id: FieldRef<"GroupSessionClient", 'Int'>
    readonly groupSessionId: FieldRef<"GroupSessionClient", 'Int'>
    readonly clientId: FieldRef<"GroupSessionClient", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * GroupSessionClient findUnique
   */
  export type GroupSessionClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSessionClient
     */
    select?: GroupSessionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSessionClient
     */
    omit?: GroupSessionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionClientInclude<ExtArgs> | null
    /**
     * Filter, which GroupSessionClient to fetch.
     */
    where: GroupSessionClientWhereUniqueInput
  }

  /**
   * GroupSessionClient findUniqueOrThrow
   */
  export type GroupSessionClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSessionClient
     */
    select?: GroupSessionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSessionClient
     */
    omit?: GroupSessionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionClientInclude<ExtArgs> | null
    /**
     * Filter, which GroupSessionClient to fetch.
     */
    where: GroupSessionClientWhereUniqueInput
  }

  /**
   * GroupSessionClient findFirst
   */
  export type GroupSessionClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSessionClient
     */
    select?: GroupSessionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSessionClient
     */
    omit?: GroupSessionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionClientInclude<ExtArgs> | null
    /**
     * Filter, which GroupSessionClient to fetch.
     */
    where?: GroupSessionClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupSessionClients to fetch.
     */
    orderBy?: GroupSessionClientOrderByWithRelationInput | GroupSessionClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupSessionClients.
     */
    cursor?: GroupSessionClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupSessionClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupSessionClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupSessionClients.
     */
    distinct?: GroupSessionClientScalarFieldEnum | GroupSessionClientScalarFieldEnum[]
  }

  /**
   * GroupSessionClient findFirstOrThrow
   */
  export type GroupSessionClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSessionClient
     */
    select?: GroupSessionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSessionClient
     */
    omit?: GroupSessionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionClientInclude<ExtArgs> | null
    /**
     * Filter, which GroupSessionClient to fetch.
     */
    where?: GroupSessionClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupSessionClients to fetch.
     */
    orderBy?: GroupSessionClientOrderByWithRelationInput | GroupSessionClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupSessionClients.
     */
    cursor?: GroupSessionClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupSessionClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupSessionClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupSessionClients.
     */
    distinct?: GroupSessionClientScalarFieldEnum | GroupSessionClientScalarFieldEnum[]
  }

  /**
   * GroupSessionClient findMany
   */
  export type GroupSessionClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSessionClient
     */
    select?: GroupSessionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSessionClient
     */
    omit?: GroupSessionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionClientInclude<ExtArgs> | null
    /**
     * Filter, which GroupSessionClients to fetch.
     */
    where?: GroupSessionClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupSessionClients to fetch.
     */
    orderBy?: GroupSessionClientOrderByWithRelationInput | GroupSessionClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupSessionClients.
     */
    cursor?: GroupSessionClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupSessionClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupSessionClients.
     */
    skip?: number
    distinct?: GroupSessionClientScalarFieldEnum | GroupSessionClientScalarFieldEnum[]
  }

  /**
   * GroupSessionClient create
   */
  export type GroupSessionClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSessionClient
     */
    select?: GroupSessionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSessionClient
     */
    omit?: GroupSessionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionClientInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupSessionClient.
     */
    data: XOR<GroupSessionClientCreateInput, GroupSessionClientUncheckedCreateInput>
  }

  /**
   * GroupSessionClient createMany
   */
  export type GroupSessionClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupSessionClients.
     */
    data: GroupSessionClientCreateManyInput | GroupSessionClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupSessionClient createManyAndReturn
   */
  export type GroupSessionClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSessionClient
     */
    select?: GroupSessionClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSessionClient
     */
    omit?: GroupSessionClientOmit<ExtArgs> | null
    /**
     * The data used to create many GroupSessionClients.
     */
    data: GroupSessionClientCreateManyInput | GroupSessionClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupSessionClient update
   */
  export type GroupSessionClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSessionClient
     */
    select?: GroupSessionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSessionClient
     */
    omit?: GroupSessionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionClientInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupSessionClient.
     */
    data: XOR<GroupSessionClientUpdateInput, GroupSessionClientUncheckedUpdateInput>
    /**
     * Choose, which GroupSessionClient to update.
     */
    where: GroupSessionClientWhereUniqueInput
  }

  /**
   * GroupSessionClient updateMany
   */
  export type GroupSessionClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupSessionClients.
     */
    data: XOR<GroupSessionClientUpdateManyMutationInput, GroupSessionClientUncheckedUpdateManyInput>
    /**
     * Filter which GroupSessionClients to update
     */
    where?: GroupSessionClientWhereInput
    /**
     * Limit how many GroupSessionClients to update.
     */
    limit?: number
  }

  /**
   * GroupSessionClient updateManyAndReturn
   */
  export type GroupSessionClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSessionClient
     */
    select?: GroupSessionClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSessionClient
     */
    omit?: GroupSessionClientOmit<ExtArgs> | null
    /**
     * The data used to update GroupSessionClients.
     */
    data: XOR<GroupSessionClientUpdateManyMutationInput, GroupSessionClientUncheckedUpdateManyInput>
    /**
     * Filter which GroupSessionClients to update
     */
    where?: GroupSessionClientWhereInput
    /**
     * Limit how many GroupSessionClients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GroupSessionClient upsert
   */
  export type GroupSessionClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSessionClient
     */
    select?: GroupSessionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSessionClient
     */
    omit?: GroupSessionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionClientInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupSessionClient to update in case it exists.
     */
    where: GroupSessionClientWhereUniqueInput
    /**
     * In case the GroupSessionClient found by the `where` argument doesn't exist, create a new GroupSessionClient with this data.
     */
    create: XOR<GroupSessionClientCreateInput, GroupSessionClientUncheckedCreateInput>
    /**
     * In case the GroupSessionClient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupSessionClientUpdateInput, GroupSessionClientUncheckedUpdateInput>
  }

  /**
   * GroupSessionClient delete
   */
  export type GroupSessionClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSessionClient
     */
    select?: GroupSessionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSessionClient
     */
    omit?: GroupSessionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionClientInclude<ExtArgs> | null
    /**
     * Filter which GroupSessionClient to delete.
     */
    where: GroupSessionClientWhereUniqueInput
  }

  /**
   * GroupSessionClient deleteMany
   */
  export type GroupSessionClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupSessionClients to delete
     */
    where?: GroupSessionClientWhereInput
    /**
     * Limit how many GroupSessionClients to delete.
     */
    limit?: number
  }

  /**
   * GroupSessionClient without action
   */
  export type GroupSessionClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupSessionClient
     */
    select?: GroupSessionClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GroupSessionClient
     */
    omit?: GroupSessionClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupSessionClientInclude<ExtArgs> | null
  }


  /**
   * Model ChangeLog
   */

  export type AggregateChangeLog = {
    _count: ChangeLogCountAggregateOutputType | null
    _avg: ChangeLogAvgAggregateOutputType | null
    _sum: ChangeLogSumAggregateOutputType | null
    _min: ChangeLogMinAggregateOutputType | null
    _max: ChangeLogMaxAggregateOutputType | null
  }

  export type ChangeLogAvgAggregateOutputType = {
    id: number | null
    versionId: number | null
    entityId: number | null
    staffId: number | null
    clientId: number | null
  }

  export type ChangeLogSumAggregateOutputType = {
    id: number | null
    versionId: number | null
    entityId: number | null
    staffId: number | null
    clientId: number | null
  }

  export type ChangeLogMinAggregateOutputType = {
    id: number | null
    versionId: number | null
    changeType: string | null
    entityType: string | null
    entityId: number | null
    day: string | null
    block: string | null
    staffId: number | null
    clientId: number | null
    reviewed: boolean | null
    reviewedAt: Date | null
    reviewedBy: string | null
    committedToMain: boolean | null
    committedAt: Date | null
    createdBy: string | null
    createdAt: Date | null
    notes: string | null
  }

  export type ChangeLogMaxAggregateOutputType = {
    id: number | null
    versionId: number | null
    changeType: string | null
    entityType: string | null
    entityId: number | null
    day: string | null
    block: string | null
    staffId: number | null
    clientId: number | null
    reviewed: boolean | null
    reviewedAt: Date | null
    reviewedBy: string | null
    committedToMain: boolean | null
    committedAt: Date | null
    createdBy: string | null
    createdAt: Date | null
    notes: string | null
  }

  export type ChangeLogCountAggregateOutputType = {
    id: number
    versionId: number
    changeType: number
    entityType: number
    entityId: number
    day: number
    block: number
    staffId: number
    clientId: number
    previousValue: number
    newValue: number
    reviewed: number
    reviewedAt: number
    reviewedBy: number
    committedToMain: number
    committedAt: number
    createdBy: number
    createdAt: number
    notes: number
    _all: number
  }


  export type ChangeLogAvgAggregateInputType = {
    id?: true
    versionId?: true
    entityId?: true
    staffId?: true
    clientId?: true
  }

  export type ChangeLogSumAggregateInputType = {
    id?: true
    versionId?: true
    entityId?: true
    staffId?: true
    clientId?: true
  }

  export type ChangeLogMinAggregateInputType = {
    id?: true
    versionId?: true
    changeType?: true
    entityType?: true
    entityId?: true
    day?: true
    block?: true
    staffId?: true
    clientId?: true
    reviewed?: true
    reviewedAt?: true
    reviewedBy?: true
    committedToMain?: true
    committedAt?: true
    createdBy?: true
    createdAt?: true
    notes?: true
  }

  export type ChangeLogMaxAggregateInputType = {
    id?: true
    versionId?: true
    changeType?: true
    entityType?: true
    entityId?: true
    day?: true
    block?: true
    staffId?: true
    clientId?: true
    reviewed?: true
    reviewedAt?: true
    reviewedBy?: true
    committedToMain?: true
    committedAt?: true
    createdBy?: true
    createdAt?: true
    notes?: true
  }

  export type ChangeLogCountAggregateInputType = {
    id?: true
    versionId?: true
    changeType?: true
    entityType?: true
    entityId?: true
    day?: true
    block?: true
    staffId?: true
    clientId?: true
    previousValue?: true
    newValue?: true
    reviewed?: true
    reviewedAt?: true
    reviewedBy?: true
    committedToMain?: true
    committedAt?: true
    createdBy?: true
    createdAt?: true
    notes?: true
    _all?: true
  }

  export type ChangeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeLog to aggregate.
     */
    where?: ChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeLogs to fetch.
     */
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChangeLogs
    **/
    _count?: true | ChangeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChangeLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChangeLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChangeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChangeLogMaxAggregateInputType
  }

  export type GetChangeLogAggregateType<T extends ChangeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateChangeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChangeLog[P]>
      : GetScalarType<T[P], AggregateChangeLog[P]>
  }




  export type ChangeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeLogWhereInput
    orderBy?: ChangeLogOrderByWithAggregationInput | ChangeLogOrderByWithAggregationInput[]
    by: ChangeLogScalarFieldEnum[] | ChangeLogScalarFieldEnum
    having?: ChangeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChangeLogCountAggregateInputType | true
    _avg?: ChangeLogAvgAggregateInputType
    _sum?: ChangeLogSumAggregateInputType
    _min?: ChangeLogMinAggregateInputType
    _max?: ChangeLogMaxAggregateInputType
  }

  export type ChangeLogGroupByOutputType = {
    id: number
    versionId: number
    changeType: string
    entityType: string
    entityId: number | null
    day: string | null
    block: string | null
    staffId: number | null
    clientId: number | null
    previousValue: JsonValue | null
    newValue: JsonValue | null
    reviewed: boolean
    reviewedAt: Date | null
    reviewedBy: string | null
    committedToMain: boolean
    committedAt: Date | null
    createdBy: string
    createdAt: Date
    notes: string | null
    _count: ChangeLogCountAggregateOutputType | null
    _avg: ChangeLogAvgAggregateOutputType | null
    _sum: ChangeLogSumAggregateOutputType | null
    _min: ChangeLogMinAggregateOutputType | null
    _max: ChangeLogMaxAggregateOutputType | null
  }

  type GetChangeLogGroupByPayload<T extends ChangeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChangeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChangeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChangeLogGroupByOutputType[P]>
            : GetScalarType<T[P], ChangeLogGroupByOutputType[P]>
        }
      >
    >


  export type ChangeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    versionId?: boolean
    changeType?: boolean
    entityType?: boolean
    entityId?: boolean
    day?: boolean
    block?: boolean
    staffId?: boolean
    clientId?: boolean
    previousValue?: boolean
    newValue?: boolean
    reviewed?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    committedToMain?: boolean
    committedAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    notes?: boolean
    version?: boolean | ScheduleVersionDefaultArgs<ExtArgs>
    staff?: boolean | ChangeLog$staffArgs<ExtArgs>
    client?: boolean | ChangeLog$clientArgs<ExtArgs>
  }, ExtArgs["result"]["changeLog"]>

  export type ChangeLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    versionId?: boolean
    changeType?: boolean
    entityType?: boolean
    entityId?: boolean
    day?: boolean
    block?: boolean
    staffId?: boolean
    clientId?: boolean
    previousValue?: boolean
    newValue?: boolean
    reviewed?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    committedToMain?: boolean
    committedAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    notes?: boolean
    version?: boolean | ScheduleVersionDefaultArgs<ExtArgs>
    staff?: boolean | ChangeLog$staffArgs<ExtArgs>
    client?: boolean | ChangeLog$clientArgs<ExtArgs>
  }, ExtArgs["result"]["changeLog"]>

  export type ChangeLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    versionId?: boolean
    changeType?: boolean
    entityType?: boolean
    entityId?: boolean
    day?: boolean
    block?: boolean
    staffId?: boolean
    clientId?: boolean
    previousValue?: boolean
    newValue?: boolean
    reviewed?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    committedToMain?: boolean
    committedAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    notes?: boolean
    version?: boolean | ScheduleVersionDefaultArgs<ExtArgs>
    staff?: boolean | ChangeLog$staffArgs<ExtArgs>
    client?: boolean | ChangeLog$clientArgs<ExtArgs>
  }, ExtArgs["result"]["changeLog"]>

  export type ChangeLogSelectScalar = {
    id?: boolean
    versionId?: boolean
    changeType?: boolean
    entityType?: boolean
    entityId?: boolean
    day?: boolean
    block?: boolean
    staffId?: boolean
    clientId?: boolean
    previousValue?: boolean
    newValue?: boolean
    reviewed?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    committedToMain?: boolean
    committedAt?: boolean
    createdBy?: boolean
    createdAt?: boolean
    notes?: boolean
  }

  export type ChangeLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "versionId" | "changeType" | "entityType" | "entityId" | "day" | "block" | "staffId" | "clientId" | "previousValue" | "newValue" | "reviewed" | "reviewedAt" | "reviewedBy" | "committedToMain" | "committedAt" | "createdBy" | "createdAt" | "notes", ExtArgs["result"]["changeLog"]>
  export type ChangeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version?: boolean | ScheduleVersionDefaultArgs<ExtArgs>
    staff?: boolean | ChangeLog$staffArgs<ExtArgs>
    client?: boolean | ChangeLog$clientArgs<ExtArgs>
  }
  export type ChangeLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version?: boolean | ScheduleVersionDefaultArgs<ExtArgs>
    staff?: boolean | ChangeLog$staffArgs<ExtArgs>
    client?: boolean | ChangeLog$clientArgs<ExtArgs>
  }
  export type ChangeLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version?: boolean | ScheduleVersionDefaultArgs<ExtArgs>
    staff?: boolean | ChangeLog$staffArgs<ExtArgs>
    client?: boolean | ChangeLog$clientArgs<ExtArgs>
  }

  export type $ChangeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChangeLog"
    objects: {
      version: Prisma.$ScheduleVersionPayload<ExtArgs>
      staff: Prisma.$StaffPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      versionId: number
      changeType: string
      entityType: string
      entityId: number | null
      day: string | null
      block: string | null
      staffId: number | null
      clientId: number | null
      previousValue: Prisma.JsonValue | null
      newValue: Prisma.JsonValue | null
      reviewed: boolean
      reviewedAt: Date | null
      reviewedBy: string | null
      committedToMain: boolean
      committedAt: Date | null
      createdBy: string
      createdAt: Date
      notes: string | null
    }, ExtArgs["result"]["changeLog"]>
    composites: {}
  }

  type ChangeLogGetPayload<S extends boolean | null | undefined | ChangeLogDefaultArgs> = $Result.GetResult<Prisma.$ChangeLogPayload, S>

  type ChangeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChangeLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChangeLogCountAggregateInputType | true
    }

  export interface ChangeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChangeLog'], meta: { name: 'ChangeLog' } }
    /**
     * Find zero or one ChangeLog that matches the filter.
     * @param {ChangeLogFindUniqueArgs} args - Arguments to find a ChangeLog
     * @example
     * // Get one ChangeLog
     * const changeLog = await prisma.changeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChangeLogFindUniqueArgs>(args: SelectSubset<T, ChangeLogFindUniqueArgs<ExtArgs>>): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChangeLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChangeLogFindUniqueOrThrowArgs} args - Arguments to find a ChangeLog
     * @example
     * // Get one ChangeLog
     * const changeLog = await prisma.changeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChangeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ChangeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChangeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogFindFirstArgs} args - Arguments to find a ChangeLog
     * @example
     * // Get one ChangeLog
     * const changeLog = await prisma.changeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChangeLogFindFirstArgs>(args?: SelectSubset<T, ChangeLogFindFirstArgs<ExtArgs>>): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChangeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogFindFirstOrThrowArgs} args - Arguments to find a ChangeLog
     * @example
     * // Get one ChangeLog
     * const changeLog = await prisma.changeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChangeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ChangeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChangeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChangeLogs
     * const changeLogs = await prisma.changeLog.findMany()
     * 
     * // Get first 10 ChangeLogs
     * const changeLogs = await prisma.changeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const changeLogWithIdOnly = await prisma.changeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChangeLogFindManyArgs>(args?: SelectSubset<T, ChangeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChangeLog.
     * @param {ChangeLogCreateArgs} args - Arguments to create a ChangeLog.
     * @example
     * // Create one ChangeLog
     * const ChangeLog = await prisma.changeLog.create({
     *   data: {
     *     // ... data to create a ChangeLog
     *   }
     * })
     * 
     */
    create<T extends ChangeLogCreateArgs>(args: SelectSubset<T, ChangeLogCreateArgs<ExtArgs>>): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChangeLogs.
     * @param {ChangeLogCreateManyArgs} args - Arguments to create many ChangeLogs.
     * @example
     * // Create many ChangeLogs
     * const changeLog = await prisma.changeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChangeLogCreateManyArgs>(args?: SelectSubset<T, ChangeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChangeLogs and returns the data saved in the database.
     * @param {ChangeLogCreateManyAndReturnArgs} args - Arguments to create many ChangeLogs.
     * @example
     * // Create many ChangeLogs
     * const changeLog = await prisma.changeLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChangeLogs and only return the `id`
     * const changeLogWithIdOnly = await prisma.changeLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChangeLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ChangeLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChangeLog.
     * @param {ChangeLogDeleteArgs} args - Arguments to delete one ChangeLog.
     * @example
     * // Delete one ChangeLog
     * const ChangeLog = await prisma.changeLog.delete({
     *   where: {
     *     // ... filter to delete one ChangeLog
     *   }
     * })
     * 
     */
    delete<T extends ChangeLogDeleteArgs>(args: SelectSubset<T, ChangeLogDeleteArgs<ExtArgs>>): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChangeLog.
     * @param {ChangeLogUpdateArgs} args - Arguments to update one ChangeLog.
     * @example
     * // Update one ChangeLog
     * const changeLog = await prisma.changeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChangeLogUpdateArgs>(args: SelectSubset<T, ChangeLogUpdateArgs<ExtArgs>>): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChangeLogs.
     * @param {ChangeLogDeleteManyArgs} args - Arguments to filter ChangeLogs to delete.
     * @example
     * // Delete a few ChangeLogs
     * const { count } = await prisma.changeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChangeLogDeleteManyArgs>(args?: SelectSubset<T, ChangeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChangeLogs
     * const changeLog = await prisma.changeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChangeLogUpdateManyArgs>(args: SelectSubset<T, ChangeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChangeLogs and returns the data updated in the database.
     * @param {ChangeLogUpdateManyAndReturnArgs} args - Arguments to update many ChangeLogs.
     * @example
     * // Update many ChangeLogs
     * const changeLog = await prisma.changeLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChangeLogs and only return the `id`
     * const changeLogWithIdOnly = await prisma.changeLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChangeLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ChangeLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChangeLog.
     * @param {ChangeLogUpsertArgs} args - Arguments to update or create a ChangeLog.
     * @example
     * // Update or create a ChangeLog
     * const changeLog = await prisma.changeLog.upsert({
     *   create: {
     *     // ... data to create a ChangeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChangeLog we want to update
     *   }
     * })
     */
    upsert<T extends ChangeLogUpsertArgs>(args: SelectSubset<T, ChangeLogUpsertArgs<ExtArgs>>): Prisma__ChangeLogClient<$Result.GetResult<Prisma.$ChangeLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogCountArgs} args - Arguments to filter ChangeLogs to count.
     * @example
     * // Count the number of ChangeLogs
     * const count = await prisma.changeLog.count({
     *   where: {
     *     // ... the filter for the ChangeLogs we want to count
     *   }
     * })
    **/
    count<T extends ChangeLogCountArgs>(
      args?: Subset<T, ChangeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChangeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChangeLogAggregateArgs>(args: Subset<T, ChangeLogAggregateArgs>): Prisma.PrismaPromise<GetChangeLogAggregateType<T>>

    /**
     * Group by ChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChangeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChangeLogGroupByArgs['orderBy'] }
        : { orderBy?: ChangeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChangeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChangeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChangeLog model
   */
  readonly fields: ChangeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChangeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChangeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    version<T extends ScheduleVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleVersionDefaultArgs<ExtArgs>>): Prisma__ScheduleVersionClient<$Result.GetResult<Prisma.$ScheduleVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    staff<T extends ChangeLog$staffArgs<ExtArgs> = {}>(args?: Subset<T, ChangeLog$staffArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends ChangeLog$clientArgs<ExtArgs> = {}>(args?: Subset<T, ChangeLog$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChangeLog model
   */
  interface ChangeLogFieldRefs {
    readonly id: FieldRef<"ChangeLog", 'Int'>
    readonly versionId: FieldRef<"ChangeLog", 'Int'>
    readonly changeType: FieldRef<"ChangeLog", 'String'>
    readonly entityType: FieldRef<"ChangeLog", 'String'>
    readonly entityId: FieldRef<"ChangeLog", 'Int'>
    readonly day: FieldRef<"ChangeLog", 'String'>
    readonly block: FieldRef<"ChangeLog", 'String'>
    readonly staffId: FieldRef<"ChangeLog", 'Int'>
    readonly clientId: FieldRef<"ChangeLog", 'Int'>
    readonly previousValue: FieldRef<"ChangeLog", 'Json'>
    readonly newValue: FieldRef<"ChangeLog", 'Json'>
    readonly reviewed: FieldRef<"ChangeLog", 'Boolean'>
    readonly reviewedAt: FieldRef<"ChangeLog", 'DateTime'>
    readonly reviewedBy: FieldRef<"ChangeLog", 'String'>
    readonly committedToMain: FieldRef<"ChangeLog", 'Boolean'>
    readonly committedAt: FieldRef<"ChangeLog", 'DateTime'>
    readonly createdBy: FieldRef<"ChangeLog", 'String'>
    readonly createdAt: FieldRef<"ChangeLog", 'DateTime'>
    readonly notes: FieldRef<"ChangeLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ChangeLog findUnique
   */
  export type ChangeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLog to fetch.
     */
    where: ChangeLogWhereUniqueInput
  }

  /**
   * ChangeLog findUniqueOrThrow
   */
  export type ChangeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLog to fetch.
     */
    where: ChangeLogWhereUniqueInput
  }

  /**
   * ChangeLog findFirst
   */
  export type ChangeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLog to fetch.
     */
    where?: ChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeLogs to fetch.
     */
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeLogs.
     */
    cursor?: ChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeLogs.
     */
    distinct?: ChangeLogScalarFieldEnum | ChangeLogScalarFieldEnum[]
  }

  /**
   * ChangeLog findFirstOrThrow
   */
  export type ChangeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLog to fetch.
     */
    where?: ChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeLogs to fetch.
     */
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeLogs.
     */
    cursor?: ChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeLogs.
     */
    distinct?: ChangeLogScalarFieldEnum | ChangeLogScalarFieldEnum[]
  }

  /**
   * ChangeLog findMany
   */
  export type ChangeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which ChangeLogs to fetch.
     */
    where?: ChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeLogs to fetch.
     */
    orderBy?: ChangeLogOrderByWithRelationInput | ChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChangeLogs.
     */
    cursor?: ChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeLogs.
     */
    skip?: number
    distinct?: ChangeLogScalarFieldEnum | ChangeLogScalarFieldEnum[]
  }

  /**
   * ChangeLog create
   */
  export type ChangeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ChangeLog.
     */
    data: XOR<ChangeLogCreateInput, ChangeLogUncheckedCreateInput>
  }

  /**
   * ChangeLog createMany
   */
  export type ChangeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChangeLogs.
     */
    data: ChangeLogCreateManyInput | ChangeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChangeLog createManyAndReturn
   */
  export type ChangeLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * The data used to create many ChangeLogs.
     */
    data: ChangeLogCreateManyInput | ChangeLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChangeLog update
   */
  export type ChangeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ChangeLog.
     */
    data: XOR<ChangeLogUpdateInput, ChangeLogUncheckedUpdateInput>
    /**
     * Choose, which ChangeLog to update.
     */
    where: ChangeLogWhereUniqueInput
  }

  /**
   * ChangeLog updateMany
   */
  export type ChangeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChangeLogs.
     */
    data: XOR<ChangeLogUpdateManyMutationInput, ChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which ChangeLogs to update
     */
    where?: ChangeLogWhereInput
    /**
     * Limit how many ChangeLogs to update.
     */
    limit?: number
  }

  /**
   * ChangeLog updateManyAndReturn
   */
  export type ChangeLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * The data used to update ChangeLogs.
     */
    data: XOR<ChangeLogUpdateManyMutationInput, ChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which ChangeLogs to update
     */
    where?: ChangeLogWhereInput
    /**
     * Limit how many ChangeLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChangeLog upsert
   */
  export type ChangeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ChangeLog to update in case it exists.
     */
    where: ChangeLogWhereUniqueInput
    /**
     * In case the ChangeLog found by the `where` argument doesn't exist, create a new ChangeLog with this data.
     */
    create: XOR<ChangeLogCreateInput, ChangeLogUncheckedCreateInput>
    /**
     * In case the ChangeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChangeLogUpdateInput, ChangeLogUncheckedUpdateInput>
  }

  /**
   * ChangeLog delete
   */
  export type ChangeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
    /**
     * Filter which ChangeLog to delete.
     */
    where: ChangeLogWhereUniqueInput
  }

  /**
   * ChangeLog deleteMany
   */
  export type ChangeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeLogs to delete
     */
    where?: ChangeLogWhereInput
    /**
     * Limit how many ChangeLogs to delete.
     */
    limit?: number
  }

  /**
   * ChangeLog.staff
   */
  export type ChangeLog$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
  }

  /**
   * ChangeLog.client
   */
  export type ChangeLog$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * ChangeLog without action
   */
  export type ChangeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeLog
     */
    select?: ChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeLog
     */
    omit?: ChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeLogInclude<ExtArgs> | null
  }


  /**
   * Model DailyOverride
   */

  export type AggregateDailyOverride = {
    _count: DailyOverrideCountAggregateOutputType | null
    _avg: DailyOverrideAvgAggregateOutputType | null
    _sum: DailyOverrideSumAggregateOutputType | null
    _min: DailyOverrideMinAggregateOutputType | null
    _max: DailyOverrideMaxAggregateOutputType | null
  }

  export type DailyOverrideAvgAggregateOutputType = {
    id: number | null
    originalStaffId: number | null
    originalClientId: number | null
    newStaffId: number | null
    newClientId: number | null
    hours: number | null
  }

  export type DailyOverrideSumAggregateOutputType = {
    id: number | null
    originalStaffId: number | null
    originalClientId: number | null
    newStaffId: number | null
    newClientId: number | null
    hours: number | null
  }

  export type DailyOverrideMinAggregateOutputType = {
    id: number | null
    date: Date | null
    type: string | null
    day: string | null
    block: string | null
    originalStaffId: number | null
    originalClientId: number | null
    newStaffId: number | null
    newClientId: number | null
    reason: string | null
    hours: number | null
    status: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyOverrideMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    type: string | null
    day: string | null
    block: string | null
    originalStaffId: number | null
    originalClientId: number | null
    newStaffId: number | null
    newClientId: number | null
    reason: string | null
    hours: number | null
    status: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyOverrideCountAggregateOutputType = {
    id: number
    date: number
    type: number
    day: number
    block: number
    originalStaffId: number
    originalClientId: number
    newStaffId: number
    newClientId: number
    reason: number
    hours: number
    status: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DailyOverrideAvgAggregateInputType = {
    id?: true
    originalStaffId?: true
    originalClientId?: true
    newStaffId?: true
    newClientId?: true
    hours?: true
  }

  export type DailyOverrideSumAggregateInputType = {
    id?: true
    originalStaffId?: true
    originalClientId?: true
    newStaffId?: true
    newClientId?: true
    hours?: true
  }

  export type DailyOverrideMinAggregateInputType = {
    id?: true
    date?: true
    type?: true
    day?: true
    block?: true
    originalStaffId?: true
    originalClientId?: true
    newStaffId?: true
    newClientId?: true
    reason?: true
    hours?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyOverrideMaxAggregateInputType = {
    id?: true
    date?: true
    type?: true
    day?: true
    block?: true
    originalStaffId?: true
    originalClientId?: true
    newStaffId?: true
    newClientId?: true
    reason?: true
    hours?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyOverrideCountAggregateInputType = {
    id?: true
    date?: true
    type?: true
    day?: true
    block?: true
    originalStaffId?: true
    originalClientId?: true
    newStaffId?: true
    newClientId?: true
    reason?: true
    hours?: true
    status?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DailyOverrideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyOverride to aggregate.
     */
    where?: DailyOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyOverrides to fetch.
     */
    orderBy?: DailyOverrideOrderByWithRelationInput | DailyOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyOverrides
    **/
    _count?: true | DailyOverrideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyOverrideAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyOverrideSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyOverrideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyOverrideMaxAggregateInputType
  }

  export type GetDailyOverrideAggregateType<T extends DailyOverrideAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyOverride]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyOverride[P]>
      : GetScalarType<T[P], AggregateDailyOverride[P]>
  }




  export type DailyOverrideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyOverrideWhereInput
    orderBy?: DailyOverrideOrderByWithAggregationInput | DailyOverrideOrderByWithAggregationInput[]
    by: DailyOverrideScalarFieldEnum[] | DailyOverrideScalarFieldEnum
    having?: DailyOverrideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyOverrideCountAggregateInputType | true
    _avg?: DailyOverrideAvgAggregateInputType
    _sum?: DailyOverrideSumAggregateInputType
    _min?: DailyOverrideMinAggregateInputType
    _max?: DailyOverrideMaxAggregateInputType
  }

  export type DailyOverrideGroupByOutputType = {
    id: number
    date: Date
    type: string
    day: string
    block: string
    originalStaffId: number | null
    originalClientId: number | null
    newStaffId: number | null
    newClientId: number | null
    reason: string
    hours: number | null
    status: string
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: DailyOverrideCountAggregateOutputType | null
    _avg: DailyOverrideAvgAggregateOutputType | null
    _sum: DailyOverrideSumAggregateOutputType | null
    _min: DailyOverrideMinAggregateOutputType | null
    _max: DailyOverrideMaxAggregateOutputType | null
  }

  type GetDailyOverrideGroupByPayload<T extends DailyOverrideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyOverrideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyOverrideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyOverrideGroupByOutputType[P]>
            : GetScalarType<T[P], DailyOverrideGroupByOutputType[P]>
        }
      >
    >


  export type DailyOverrideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    type?: boolean
    day?: boolean
    block?: boolean
    originalStaffId?: boolean
    originalClientId?: boolean
    newStaffId?: boolean
    newClientId?: boolean
    reason?: boolean
    hours?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    originalStaff?: boolean | DailyOverride$originalStaffArgs<ExtArgs>
    originalClient?: boolean | DailyOverride$originalClientArgs<ExtArgs>
    newStaff?: boolean | DailyOverride$newStaffArgs<ExtArgs>
    newClient?: boolean | DailyOverride$newClientArgs<ExtArgs>
  }, ExtArgs["result"]["dailyOverride"]>

  export type DailyOverrideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    type?: boolean
    day?: boolean
    block?: boolean
    originalStaffId?: boolean
    originalClientId?: boolean
    newStaffId?: boolean
    newClientId?: boolean
    reason?: boolean
    hours?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    originalStaff?: boolean | DailyOverride$originalStaffArgs<ExtArgs>
    originalClient?: boolean | DailyOverride$originalClientArgs<ExtArgs>
    newStaff?: boolean | DailyOverride$newStaffArgs<ExtArgs>
    newClient?: boolean | DailyOverride$newClientArgs<ExtArgs>
  }, ExtArgs["result"]["dailyOverride"]>

  export type DailyOverrideSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    type?: boolean
    day?: boolean
    block?: boolean
    originalStaffId?: boolean
    originalClientId?: boolean
    newStaffId?: boolean
    newClientId?: boolean
    reason?: boolean
    hours?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    originalStaff?: boolean | DailyOverride$originalStaffArgs<ExtArgs>
    originalClient?: boolean | DailyOverride$originalClientArgs<ExtArgs>
    newStaff?: boolean | DailyOverride$newStaffArgs<ExtArgs>
    newClient?: boolean | DailyOverride$newClientArgs<ExtArgs>
  }, ExtArgs["result"]["dailyOverride"]>

  export type DailyOverrideSelectScalar = {
    id?: boolean
    date?: boolean
    type?: boolean
    day?: boolean
    block?: boolean
    originalStaffId?: boolean
    originalClientId?: boolean
    newStaffId?: boolean
    newClientId?: boolean
    reason?: boolean
    hours?: boolean
    status?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DailyOverrideOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "type" | "day" | "block" | "originalStaffId" | "originalClientId" | "newStaffId" | "newClientId" | "reason" | "hours" | "status" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["dailyOverride"]>
  export type DailyOverrideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalStaff?: boolean | DailyOverride$originalStaffArgs<ExtArgs>
    originalClient?: boolean | DailyOverride$originalClientArgs<ExtArgs>
    newStaff?: boolean | DailyOverride$newStaffArgs<ExtArgs>
    newClient?: boolean | DailyOverride$newClientArgs<ExtArgs>
  }
  export type DailyOverrideIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalStaff?: boolean | DailyOverride$originalStaffArgs<ExtArgs>
    originalClient?: boolean | DailyOverride$originalClientArgs<ExtArgs>
    newStaff?: boolean | DailyOverride$newStaffArgs<ExtArgs>
    newClient?: boolean | DailyOverride$newClientArgs<ExtArgs>
  }
  export type DailyOverrideIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalStaff?: boolean | DailyOverride$originalStaffArgs<ExtArgs>
    originalClient?: boolean | DailyOverride$originalClientArgs<ExtArgs>
    newStaff?: boolean | DailyOverride$newStaffArgs<ExtArgs>
    newClient?: boolean | DailyOverride$newClientArgs<ExtArgs>
  }

  export type $DailyOverridePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyOverride"
    objects: {
      originalStaff: Prisma.$StaffPayload<ExtArgs> | null
      originalClient: Prisma.$ClientPayload<ExtArgs> | null
      newStaff: Prisma.$StaffPayload<ExtArgs> | null
      newClient: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      type: string
      day: string
      block: string
      originalStaffId: number | null
      originalClientId: number | null
      newStaffId: number | null
      newClientId: number | null
      reason: string
      hours: number | null
      status: string
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dailyOverride"]>
    composites: {}
  }

  type DailyOverrideGetPayload<S extends boolean | null | undefined | DailyOverrideDefaultArgs> = $Result.GetResult<Prisma.$DailyOverridePayload, S>

  type DailyOverrideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyOverrideFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyOverrideCountAggregateInputType | true
    }

  export interface DailyOverrideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyOverride'], meta: { name: 'DailyOverride' } }
    /**
     * Find zero or one DailyOverride that matches the filter.
     * @param {DailyOverrideFindUniqueArgs} args - Arguments to find a DailyOverride
     * @example
     * // Get one DailyOverride
     * const dailyOverride = await prisma.dailyOverride.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyOverrideFindUniqueArgs>(args: SelectSubset<T, DailyOverrideFindUniqueArgs<ExtArgs>>): Prisma__DailyOverrideClient<$Result.GetResult<Prisma.$DailyOverridePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyOverride that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyOverrideFindUniqueOrThrowArgs} args - Arguments to find a DailyOverride
     * @example
     * // Get one DailyOverride
     * const dailyOverride = await prisma.dailyOverride.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyOverrideFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyOverrideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyOverrideClient<$Result.GetResult<Prisma.$DailyOverridePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyOverride that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyOverrideFindFirstArgs} args - Arguments to find a DailyOverride
     * @example
     * // Get one DailyOverride
     * const dailyOverride = await prisma.dailyOverride.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyOverrideFindFirstArgs>(args?: SelectSubset<T, DailyOverrideFindFirstArgs<ExtArgs>>): Prisma__DailyOverrideClient<$Result.GetResult<Prisma.$DailyOverridePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyOverride that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyOverrideFindFirstOrThrowArgs} args - Arguments to find a DailyOverride
     * @example
     * // Get one DailyOverride
     * const dailyOverride = await prisma.dailyOverride.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyOverrideFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyOverrideFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyOverrideClient<$Result.GetResult<Prisma.$DailyOverridePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyOverrides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyOverrideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyOverrides
     * const dailyOverrides = await prisma.dailyOverride.findMany()
     * 
     * // Get first 10 DailyOverrides
     * const dailyOverrides = await prisma.dailyOverride.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyOverrideWithIdOnly = await prisma.dailyOverride.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyOverrideFindManyArgs>(args?: SelectSubset<T, DailyOverrideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyOverridePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyOverride.
     * @param {DailyOverrideCreateArgs} args - Arguments to create a DailyOverride.
     * @example
     * // Create one DailyOverride
     * const DailyOverride = await prisma.dailyOverride.create({
     *   data: {
     *     // ... data to create a DailyOverride
     *   }
     * })
     * 
     */
    create<T extends DailyOverrideCreateArgs>(args: SelectSubset<T, DailyOverrideCreateArgs<ExtArgs>>): Prisma__DailyOverrideClient<$Result.GetResult<Prisma.$DailyOverridePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyOverrides.
     * @param {DailyOverrideCreateManyArgs} args - Arguments to create many DailyOverrides.
     * @example
     * // Create many DailyOverrides
     * const dailyOverride = await prisma.dailyOverride.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyOverrideCreateManyArgs>(args?: SelectSubset<T, DailyOverrideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyOverrides and returns the data saved in the database.
     * @param {DailyOverrideCreateManyAndReturnArgs} args - Arguments to create many DailyOverrides.
     * @example
     * // Create many DailyOverrides
     * const dailyOverride = await prisma.dailyOverride.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyOverrides and only return the `id`
     * const dailyOverrideWithIdOnly = await prisma.dailyOverride.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyOverrideCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyOverrideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyOverridePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyOverride.
     * @param {DailyOverrideDeleteArgs} args - Arguments to delete one DailyOverride.
     * @example
     * // Delete one DailyOverride
     * const DailyOverride = await prisma.dailyOverride.delete({
     *   where: {
     *     // ... filter to delete one DailyOverride
     *   }
     * })
     * 
     */
    delete<T extends DailyOverrideDeleteArgs>(args: SelectSubset<T, DailyOverrideDeleteArgs<ExtArgs>>): Prisma__DailyOverrideClient<$Result.GetResult<Prisma.$DailyOverridePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyOverride.
     * @param {DailyOverrideUpdateArgs} args - Arguments to update one DailyOverride.
     * @example
     * // Update one DailyOverride
     * const dailyOverride = await prisma.dailyOverride.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyOverrideUpdateArgs>(args: SelectSubset<T, DailyOverrideUpdateArgs<ExtArgs>>): Prisma__DailyOverrideClient<$Result.GetResult<Prisma.$DailyOverridePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyOverrides.
     * @param {DailyOverrideDeleteManyArgs} args - Arguments to filter DailyOverrides to delete.
     * @example
     * // Delete a few DailyOverrides
     * const { count } = await prisma.dailyOverride.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyOverrideDeleteManyArgs>(args?: SelectSubset<T, DailyOverrideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyOverrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyOverrideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyOverrides
     * const dailyOverride = await prisma.dailyOverride.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyOverrideUpdateManyArgs>(args: SelectSubset<T, DailyOverrideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyOverrides and returns the data updated in the database.
     * @param {DailyOverrideUpdateManyAndReturnArgs} args - Arguments to update many DailyOverrides.
     * @example
     * // Update many DailyOverrides
     * const dailyOverride = await prisma.dailyOverride.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyOverrides and only return the `id`
     * const dailyOverrideWithIdOnly = await prisma.dailyOverride.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyOverrideUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyOverrideUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyOverridePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyOverride.
     * @param {DailyOverrideUpsertArgs} args - Arguments to update or create a DailyOverride.
     * @example
     * // Update or create a DailyOverride
     * const dailyOverride = await prisma.dailyOverride.upsert({
     *   create: {
     *     // ... data to create a DailyOverride
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyOverride we want to update
     *   }
     * })
     */
    upsert<T extends DailyOverrideUpsertArgs>(args: SelectSubset<T, DailyOverrideUpsertArgs<ExtArgs>>): Prisma__DailyOverrideClient<$Result.GetResult<Prisma.$DailyOverridePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyOverrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyOverrideCountArgs} args - Arguments to filter DailyOverrides to count.
     * @example
     * // Count the number of DailyOverrides
     * const count = await prisma.dailyOverride.count({
     *   where: {
     *     // ... the filter for the DailyOverrides we want to count
     *   }
     * })
    **/
    count<T extends DailyOverrideCountArgs>(
      args?: Subset<T, DailyOverrideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyOverrideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyOverride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyOverrideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyOverrideAggregateArgs>(args: Subset<T, DailyOverrideAggregateArgs>): Prisma.PrismaPromise<GetDailyOverrideAggregateType<T>>

    /**
     * Group by DailyOverride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyOverrideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyOverrideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyOverrideGroupByArgs['orderBy'] }
        : { orderBy?: DailyOverrideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyOverrideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyOverrideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyOverride model
   */
  readonly fields: DailyOverrideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyOverride.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyOverrideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    originalStaff<T extends DailyOverride$originalStaffArgs<ExtArgs> = {}>(args?: Subset<T, DailyOverride$originalStaffArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    originalClient<T extends DailyOverride$originalClientArgs<ExtArgs> = {}>(args?: Subset<T, DailyOverride$originalClientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    newStaff<T extends DailyOverride$newStaffArgs<ExtArgs> = {}>(args?: Subset<T, DailyOverride$newStaffArgs<ExtArgs>>): Prisma__StaffClient<$Result.GetResult<Prisma.$StaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    newClient<T extends DailyOverride$newClientArgs<ExtArgs> = {}>(args?: Subset<T, DailyOverride$newClientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyOverride model
   */
  interface DailyOverrideFieldRefs {
    readonly id: FieldRef<"DailyOverride", 'Int'>
    readonly date: FieldRef<"DailyOverride", 'DateTime'>
    readonly type: FieldRef<"DailyOverride", 'String'>
    readonly day: FieldRef<"DailyOverride", 'String'>
    readonly block: FieldRef<"DailyOverride", 'String'>
    readonly originalStaffId: FieldRef<"DailyOverride", 'Int'>
    readonly originalClientId: FieldRef<"DailyOverride", 'Int'>
    readonly newStaffId: FieldRef<"DailyOverride", 'Int'>
    readonly newClientId: FieldRef<"DailyOverride", 'Int'>
    readonly reason: FieldRef<"DailyOverride", 'String'>
    readonly hours: FieldRef<"DailyOverride", 'Float'>
    readonly status: FieldRef<"DailyOverride", 'String'>
    readonly createdBy: FieldRef<"DailyOverride", 'String'>
    readonly createdAt: FieldRef<"DailyOverride", 'DateTime'>
    readonly updatedAt: FieldRef<"DailyOverride", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyOverride findUnique
   */
  export type DailyOverrideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyOverride
     */
    select?: DailyOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyOverride
     */
    omit?: DailyOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyOverrideInclude<ExtArgs> | null
    /**
     * Filter, which DailyOverride to fetch.
     */
    where: DailyOverrideWhereUniqueInput
  }

  /**
   * DailyOverride findUniqueOrThrow
   */
  export type DailyOverrideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyOverride
     */
    select?: DailyOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyOverride
     */
    omit?: DailyOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyOverrideInclude<ExtArgs> | null
    /**
     * Filter, which DailyOverride to fetch.
     */
    where: DailyOverrideWhereUniqueInput
  }

  /**
   * DailyOverride findFirst
   */
  export type DailyOverrideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyOverride
     */
    select?: DailyOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyOverride
     */
    omit?: DailyOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyOverrideInclude<ExtArgs> | null
    /**
     * Filter, which DailyOverride to fetch.
     */
    where?: DailyOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyOverrides to fetch.
     */
    orderBy?: DailyOverrideOrderByWithRelationInput | DailyOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyOverrides.
     */
    cursor?: DailyOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyOverrides.
     */
    distinct?: DailyOverrideScalarFieldEnum | DailyOverrideScalarFieldEnum[]
  }

  /**
   * DailyOverride findFirstOrThrow
   */
  export type DailyOverrideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyOverride
     */
    select?: DailyOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyOverride
     */
    omit?: DailyOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyOverrideInclude<ExtArgs> | null
    /**
     * Filter, which DailyOverride to fetch.
     */
    where?: DailyOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyOverrides to fetch.
     */
    orderBy?: DailyOverrideOrderByWithRelationInput | DailyOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyOverrides.
     */
    cursor?: DailyOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyOverrides.
     */
    distinct?: DailyOverrideScalarFieldEnum | DailyOverrideScalarFieldEnum[]
  }

  /**
   * DailyOverride findMany
   */
  export type DailyOverrideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyOverride
     */
    select?: DailyOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyOverride
     */
    omit?: DailyOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyOverrideInclude<ExtArgs> | null
    /**
     * Filter, which DailyOverrides to fetch.
     */
    where?: DailyOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyOverrides to fetch.
     */
    orderBy?: DailyOverrideOrderByWithRelationInput | DailyOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyOverrides.
     */
    cursor?: DailyOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyOverrides.
     */
    skip?: number
    distinct?: DailyOverrideScalarFieldEnum | DailyOverrideScalarFieldEnum[]
  }

  /**
   * DailyOverride create
   */
  export type DailyOverrideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyOverride
     */
    select?: DailyOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyOverride
     */
    omit?: DailyOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyOverrideInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyOverride.
     */
    data: XOR<DailyOverrideCreateInput, DailyOverrideUncheckedCreateInput>
  }

  /**
   * DailyOverride createMany
   */
  export type DailyOverrideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyOverrides.
     */
    data: DailyOverrideCreateManyInput | DailyOverrideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyOverride createManyAndReturn
   */
  export type DailyOverrideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyOverride
     */
    select?: DailyOverrideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyOverride
     */
    omit?: DailyOverrideOmit<ExtArgs> | null
    /**
     * The data used to create many DailyOverrides.
     */
    data: DailyOverrideCreateManyInput | DailyOverrideCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyOverrideIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyOverride update
   */
  export type DailyOverrideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyOverride
     */
    select?: DailyOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyOverride
     */
    omit?: DailyOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyOverrideInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyOverride.
     */
    data: XOR<DailyOverrideUpdateInput, DailyOverrideUncheckedUpdateInput>
    /**
     * Choose, which DailyOverride to update.
     */
    where: DailyOverrideWhereUniqueInput
  }

  /**
   * DailyOverride updateMany
   */
  export type DailyOverrideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyOverrides.
     */
    data: XOR<DailyOverrideUpdateManyMutationInput, DailyOverrideUncheckedUpdateManyInput>
    /**
     * Filter which DailyOverrides to update
     */
    where?: DailyOverrideWhereInput
    /**
     * Limit how many DailyOverrides to update.
     */
    limit?: number
  }

  /**
   * DailyOverride updateManyAndReturn
   */
  export type DailyOverrideUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyOverride
     */
    select?: DailyOverrideSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyOverride
     */
    omit?: DailyOverrideOmit<ExtArgs> | null
    /**
     * The data used to update DailyOverrides.
     */
    data: XOR<DailyOverrideUpdateManyMutationInput, DailyOverrideUncheckedUpdateManyInput>
    /**
     * Filter which DailyOverrides to update
     */
    where?: DailyOverrideWhereInput
    /**
     * Limit how many DailyOverrides to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyOverrideIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyOverride upsert
   */
  export type DailyOverrideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyOverride
     */
    select?: DailyOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyOverride
     */
    omit?: DailyOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyOverrideInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyOverride to update in case it exists.
     */
    where: DailyOverrideWhereUniqueInput
    /**
     * In case the DailyOverride found by the `where` argument doesn't exist, create a new DailyOverride with this data.
     */
    create: XOR<DailyOverrideCreateInput, DailyOverrideUncheckedCreateInput>
    /**
     * In case the DailyOverride was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyOverrideUpdateInput, DailyOverrideUncheckedUpdateInput>
  }

  /**
   * DailyOverride delete
   */
  export type DailyOverrideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyOverride
     */
    select?: DailyOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyOverride
     */
    omit?: DailyOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyOverrideInclude<ExtArgs> | null
    /**
     * Filter which DailyOverride to delete.
     */
    where: DailyOverrideWhereUniqueInput
  }

  /**
   * DailyOverride deleteMany
   */
  export type DailyOverrideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyOverrides to delete
     */
    where?: DailyOverrideWhereInput
    /**
     * Limit how many DailyOverrides to delete.
     */
    limit?: number
  }

  /**
   * DailyOverride.originalStaff
   */
  export type DailyOverride$originalStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
  }

  /**
   * DailyOverride.originalClient
   */
  export type DailyOverride$originalClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * DailyOverride.newStaff
   */
  export type DailyOverride$newStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff
     */
    select?: StaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Staff
     */
    omit?: StaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffInclude<ExtArgs> | null
    where?: StaffWhereInput
  }

  /**
   * DailyOverride.newClient
   */
  export type DailyOverride$newClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * DailyOverride without action
   */
  export type DailyOverrideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyOverride
     */
    select?: DailyOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyOverride
     */
    omit?: DailyOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyOverrideInclude<ExtArgs> | null
  }


  /**
   * Model ClientSupervisor
   */

  export type AggregateClientSupervisor = {
    _count: ClientSupervisorCountAggregateOutputType | null
    _avg: ClientSupervisorAvgAggregateOutputType | null
    _sum: ClientSupervisorSumAggregateOutputType | null
    _min: ClientSupervisorMinAggregateOutputType | null
    _max: ClientSupervisorMaxAggregateOutputType | null
  }

  export type ClientSupervisorAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type ClientSupervisorSumAggregateOutputType = {
    id: number | null
    clientId: number | null
  }

  export type ClientSupervisorMinAggregateOutputType = {
    id: number | null
    clientId: number | null
    supervisorName: string | null
    effectiveDate: Date | null
    endDate: Date | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientSupervisorMaxAggregateOutputType = {
    id: number | null
    clientId: number | null
    supervisorName: string | null
    effectiveDate: Date | null
    endDate: Date | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientSupervisorCountAggregateOutputType = {
    id: number
    clientId: number
    supervisorName: number
    effectiveDate: number
    endDate: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientSupervisorAvgAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type ClientSupervisorSumAggregateInputType = {
    id?: true
    clientId?: true
  }

  export type ClientSupervisorMinAggregateInputType = {
    id?: true
    clientId?: true
    supervisorName?: true
    effectiveDate?: true
    endDate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientSupervisorMaxAggregateInputType = {
    id?: true
    clientId?: true
    supervisorName?: true
    effectiveDate?: true
    endDate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientSupervisorCountAggregateInputType = {
    id?: true
    clientId?: true
    supervisorName?: true
    effectiveDate?: true
    endDate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientSupervisorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientSupervisor to aggregate.
     */
    where?: ClientSupervisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSupervisors to fetch.
     */
    orderBy?: ClientSupervisorOrderByWithRelationInput | ClientSupervisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientSupervisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSupervisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSupervisors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientSupervisors
    **/
    _count?: true | ClientSupervisorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientSupervisorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSupervisorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientSupervisorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientSupervisorMaxAggregateInputType
  }

  export type GetClientSupervisorAggregateType<T extends ClientSupervisorAggregateArgs> = {
        [P in keyof T & keyof AggregateClientSupervisor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientSupervisor[P]>
      : GetScalarType<T[P], AggregateClientSupervisor[P]>
  }




  export type ClientSupervisorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientSupervisorWhereInput
    orderBy?: ClientSupervisorOrderByWithAggregationInput | ClientSupervisorOrderByWithAggregationInput[]
    by: ClientSupervisorScalarFieldEnum[] | ClientSupervisorScalarFieldEnum
    having?: ClientSupervisorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientSupervisorCountAggregateInputType | true
    _avg?: ClientSupervisorAvgAggregateInputType
    _sum?: ClientSupervisorSumAggregateInputType
    _min?: ClientSupervisorMinAggregateInputType
    _max?: ClientSupervisorMaxAggregateInputType
  }

  export type ClientSupervisorGroupByOutputType = {
    id: number
    clientId: number
    supervisorName: string
    effectiveDate: Date
    endDate: Date | null
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: ClientSupervisorCountAggregateOutputType | null
    _avg: ClientSupervisorAvgAggregateOutputType | null
    _sum: ClientSupervisorSumAggregateOutputType | null
    _min: ClientSupervisorMinAggregateOutputType | null
    _max: ClientSupervisorMaxAggregateOutputType | null
  }

  type GetClientSupervisorGroupByPayload<T extends ClientSupervisorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientSupervisorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientSupervisorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientSupervisorGroupByOutputType[P]>
            : GetScalarType<T[P], ClientSupervisorGroupByOutputType[P]>
        }
      >
    >


  export type ClientSupervisorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    supervisorName?: boolean
    effectiveDate?: boolean
    endDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientSupervisor"]>

  export type ClientSupervisorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    supervisorName?: boolean
    effectiveDate?: boolean
    endDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientSupervisor"]>

  export type ClientSupervisorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    supervisorName?: boolean
    effectiveDate?: boolean
    endDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientSupervisor"]>

  export type ClientSupervisorSelectScalar = {
    id?: boolean
    clientId?: boolean
    supervisorName?: boolean
    effectiveDate?: boolean
    endDate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientSupervisorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "supervisorName" | "effectiveDate" | "endDate" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["clientSupervisor"]>
  export type ClientSupervisorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ClientSupervisorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type ClientSupervisorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $ClientSupervisorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientSupervisor"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clientId: number
      supervisorName: string
      effectiveDate: Date
      endDate: Date | null
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientSupervisor"]>
    composites: {}
  }

  type ClientSupervisorGetPayload<S extends boolean | null | undefined | ClientSupervisorDefaultArgs> = $Result.GetResult<Prisma.$ClientSupervisorPayload, S>

  type ClientSupervisorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientSupervisorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientSupervisorCountAggregateInputType | true
    }

  export interface ClientSupervisorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientSupervisor'], meta: { name: 'ClientSupervisor' } }
    /**
     * Find zero or one ClientSupervisor that matches the filter.
     * @param {ClientSupervisorFindUniqueArgs} args - Arguments to find a ClientSupervisor
     * @example
     * // Get one ClientSupervisor
     * const clientSupervisor = await prisma.clientSupervisor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientSupervisorFindUniqueArgs>(args: SelectSubset<T, ClientSupervisorFindUniqueArgs<ExtArgs>>): Prisma__ClientSupervisorClient<$Result.GetResult<Prisma.$ClientSupervisorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientSupervisor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientSupervisorFindUniqueOrThrowArgs} args - Arguments to find a ClientSupervisor
     * @example
     * // Get one ClientSupervisor
     * const clientSupervisor = await prisma.clientSupervisor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientSupervisorFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientSupervisorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientSupervisorClient<$Result.GetResult<Prisma.$ClientSupervisorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientSupervisor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSupervisorFindFirstArgs} args - Arguments to find a ClientSupervisor
     * @example
     * // Get one ClientSupervisor
     * const clientSupervisor = await prisma.clientSupervisor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientSupervisorFindFirstArgs>(args?: SelectSubset<T, ClientSupervisorFindFirstArgs<ExtArgs>>): Prisma__ClientSupervisorClient<$Result.GetResult<Prisma.$ClientSupervisorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientSupervisor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSupervisorFindFirstOrThrowArgs} args - Arguments to find a ClientSupervisor
     * @example
     * // Get one ClientSupervisor
     * const clientSupervisor = await prisma.clientSupervisor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientSupervisorFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientSupervisorFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientSupervisorClient<$Result.GetResult<Prisma.$ClientSupervisorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientSupervisors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSupervisorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientSupervisors
     * const clientSupervisors = await prisma.clientSupervisor.findMany()
     * 
     * // Get first 10 ClientSupervisors
     * const clientSupervisors = await prisma.clientSupervisor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientSupervisorWithIdOnly = await prisma.clientSupervisor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientSupervisorFindManyArgs>(args?: SelectSubset<T, ClientSupervisorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSupervisorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientSupervisor.
     * @param {ClientSupervisorCreateArgs} args - Arguments to create a ClientSupervisor.
     * @example
     * // Create one ClientSupervisor
     * const ClientSupervisor = await prisma.clientSupervisor.create({
     *   data: {
     *     // ... data to create a ClientSupervisor
     *   }
     * })
     * 
     */
    create<T extends ClientSupervisorCreateArgs>(args: SelectSubset<T, ClientSupervisorCreateArgs<ExtArgs>>): Prisma__ClientSupervisorClient<$Result.GetResult<Prisma.$ClientSupervisorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientSupervisors.
     * @param {ClientSupervisorCreateManyArgs} args - Arguments to create many ClientSupervisors.
     * @example
     * // Create many ClientSupervisors
     * const clientSupervisor = await prisma.clientSupervisor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientSupervisorCreateManyArgs>(args?: SelectSubset<T, ClientSupervisorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientSupervisors and returns the data saved in the database.
     * @param {ClientSupervisorCreateManyAndReturnArgs} args - Arguments to create many ClientSupervisors.
     * @example
     * // Create many ClientSupervisors
     * const clientSupervisor = await prisma.clientSupervisor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientSupervisors and only return the `id`
     * const clientSupervisorWithIdOnly = await prisma.clientSupervisor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientSupervisorCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientSupervisorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSupervisorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientSupervisor.
     * @param {ClientSupervisorDeleteArgs} args - Arguments to delete one ClientSupervisor.
     * @example
     * // Delete one ClientSupervisor
     * const ClientSupervisor = await prisma.clientSupervisor.delete({
     *   where: {
     *     // ... filter to delete one ClientSupervisor
     *   }
     * })
     * 
     */
    delete<T extends ClientSupervisorDeleteArgs>(args: SelectSubset<T, ClientSupervisorDeleteArgs<ExtArgs>>): Prisma__ClientSupervisorClient<$Result.GetResult<Prisma.$ClientSupervisorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientSupervisor.
     * @param {ClientSupervisorUpdateArgs} args - Arguments to update one ClientSupervisor.
     * @example
     * // Update one ClientSupervisor
     * const clientSupervisor = await prisma.clientSupervisor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientSupervisorUpdateArgs>(args: SelectSubset<T, ClientSupervisorUpdateArgs<ExtArgs>>): Prisma__ClientSupervisorClient<$Result.GetResult<Prisma.$ClientSupervisorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientSupervisors.
     * @param {ClientSupervisorDeleteManyArgs} args - Arguments to filter ClientSupervisors to delete.
     * @example
     * // Delete a few ClientSupervisors
     * const { count } = await prisma.clientSupervisor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientSupervisorDeleteManyArgs>(args?: SelectSubset<T, ClientSupervisorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientSupervisors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSupervisorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientSupervisors
     * const clientSupervisor = await prisma.clientSupervisor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientSupervisorUpdateManyArgs>(args: SelectSubset<T, ClientSupervisorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientSupervisors and returns the data updated in the database.
     * @param {ClientSupervisorUpdateManyAndReturnArgs} args - Arguments to update many ClientSupervisors.
     * @example
     * // Update many ClientSupervisors
     * const clientSupervisor = await prisma.clientSupervisor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientSupervisors and only return the `id`
     * const clientSupervisorWithIdOnly = await prisma.clientSupervisor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientSupervisorUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientSupervisorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientSupervisorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientSupervisor.
     * @param {ClientSupervisorUpsertArgs} args - Arguments to update or create a ClientSupervisor.
     * @example
     * // Update or create a ClientSupervisor
     * const clientSupervisor = await prisma.clientSupervisor.upsert({
     *   create: {
     *     // ... data to create a ClientSupervisor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientSupervisor we want to update
     *   }
     * })
     */
    upsert<T extends ClientSupervisorUpsertArgs>(args: SelectSubset<T, ClientSupervisorUpsertArgs<ExtArgs>>): Prisma__ClientSupervisorClient<$Result.GetResult<Prisma.$ClientSupervisorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientSupervisors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSupervisorCountArgs} args - Arguments to filter ClientSupervisors to count.
     * @example
     * // Count the number of ClientSupervisors
     * const count = await prisma.clientSupervisor.count({
     *   where: {
     *     // ... the filter for the ClientSupervisors we want to count
     *   }
     * })
    **/
    count<T extends ClientSupervisorCountArgs>(
      args?: Subset<T, ClientSupervisorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientSupervisorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientSupervisor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSupervisorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientSupervisorAggregateArgs>(args: Subset<T, ClientSupervisorAggregateArgs>): Prisma.PrismaPromise<GetClientSupervisorAggregateType<T>>

    /**
     * Group by ClientSupervisor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientSupervisorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientSupervisorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientSupervisorGroupByArgs['orderBy'] }
        : { orderBy?: ClientSupervisorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientSupervisorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientSupervisorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientSupervisor model
   */
  readonly fields: ClientSupervisorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientSupervisor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientSupervisorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientSupervisor model
   */
  interface ClientSupervisorFieldRefs {
    readonly id: FieldRef<"ClientSupervisor", 'Int'>
    readonly clientId: FieldRef<"ClientSupervisor", 'Int'>
    readonly supervisorName: FieldRef<"ClientSupervisor", 'String'>
    readonly effectiveDate: FieldRef<"ClientSupervisor", 'DateTime'>
    readonly endDate: FieldRef<"ClientSupervisor", 'DateTime'>
    readonly createdBy: FieldRef<"ClientSupervisor", 'String'>
    readonly createdAt: FieldRef<"ClientSupervisor", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientSupervisor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientSupervisor findUnique
   */
  export type ClientSupervisorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSupervisor
     */
    select?: ClientSupervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSupervisor
     */
    omit?: ClientSupervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSupervisorInclude<ExtArgs> | null
    /**
     * Filter, which ClientSupervisor to fetch.
     */
    where: ClientSupervisorWhereUniqueInput
  }

  /**
   * ClientSupervisor findUniqueOrThrow
   */
  export type ClientSupervisorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSupervisor
     */
    select?: ClientSupervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSupervisor
     */
    omit?: ClientSupervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSupervisorInclude<ExtArgs> | null
    /**
     * Filter, which ClientSupervisor to fetch.
     */
    where: ClientSupervisorWhereUniqueInput
  }

  /**
   * ClientSupervisor findFirst
   */
  export type ClientSupervisorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSupervisor
     */
    select?: ClientSupervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSupervisor
     */
    omit?: ClientSupervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSupervisorInclude<ExtArgs> | null
    /**
     * Filter, which ClientSupervisor to fetch.
     */
    where?: ClientSupervisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSupervisors to fetch.
     */
    orderBy?: ClientSupervisorOrderByWithRelationInput | ClientSupervisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientSupervisors.
     */
    cursor?: ClientSupervisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSupervisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSupervisors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientSupervisors.
     */
    distinct?: ClientSupervisorScalarFieldEnum | ClientSupervisorScalarFieldEnum[]
  }

  /**
   * ClientSupervisor findFirstOrThrow
   */
  export type ClientSupervisorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSupervisor
     */
    select?: ClientSupervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSupervisor
     */
    omit?: ClientSupervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSupervisorInclude<ExtArgs> | null
    /**
     * Filter, which ClientSupervisor to fetch.
     */
    where?: ClientSupervisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSupervisors to fetch.
     */
    orderBy?: ClientSupervisorOrderByWithRelationInput | ClientSupervisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientSupervisors.
     */
    cursor?: ClientSupervisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSupervisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSupervisors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientSupervisors.
     */
    distinct?: ClientSupervisorScalarFieldEnum | ClientSupervisorScalarFieldEnum[]
  }

  /**
   * ClientSupervisor findMany
   */
  export type ClientSupervisorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSupervisor
     */
    select?: ClientSupervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSupervisor
     */
    omit?: ClientSupervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSupervisorInclude<ExtArgs> | null
    /**
     * Filter, which ClientSupervisors to fetch.
     */
    where?: ClientSupervisorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientSupervisors to fetch.
     */
    orderBy?: ClientSupervisorOrderByWithRelationInput | ClientSupervisorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientSupervisors.
     */
    cursor?: ClientSupervisorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientSupervisors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientSupervisors.
     */
    skip?: number
    distinct?: ClientSupervisorScalarFieldEnum | ClientSupervisorScalarFieldEnum[]
  }

  /**
   * ClientSupervisor create
   */
  export type ClientSupervisorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSupervisor
     */
    select?: ClientSupervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSupervisor
     */
    omit?: ClientSupervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSupervisorInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientSupervisor.
     */
    data: XOR<ClientSupervisorCreateInput, ClientSupervisorUncheckedCreateInput>
  }

  /**
   * ClientSupervisor createMany
   */
  export type ClientSupervisorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientSupervisors.
     */
    data: ClientSupervisorCreateManyInput | ClientSupervisorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientSupervisor createManyAndReturn
   */
  export type ClientSupervisorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSupervisor
     */
    select?: ClientSupervisorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSupervisor
     */
    omit?: ClientSupervisorOmit<ExtArgs> | null
    /**
     * The data used to create many ClientSupervisors.
     */
    data: ClientSupervisorCreateManyInput | ClientSupervisorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSupervisorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientSupervisor update
   */
  export type ClientSupervisorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSupervisor
     */
    select?: ClientSupervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSupervisor
     */
    omit?: ClientSupervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSupervisorInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientSupervisor.
     */
    data: XOR<ClientSupervisorUpdateInput, ClientSupervisorUncheckedUpdateInput>
    /**
     * Choose, which ClientSupervisor to update.
     */
    where: ClientSupervisorWhereUniqueInput
  }

  /**
   * ClientSupervisor updateMany
   */
  export type ClientSupervisorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientSupervisors.
     */
    data: XOR<ClientSupervisorUpdateManyMutationInput, ClientSupervisorUncheckedUpdateManyInput>
    /**
     * Filter which ClientSupervisors to update
     */
    where?: ClientSupervisorWhereInput
    /**
     * Limit how many ClientSupervisors to update.
     */
    limit?: number
  }

  /**
   * ClientSupervisor updateManyAndReturn
   */
  export type ClientSupervisorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSupervisor
     */
    select?: ClientSupervisorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSupervisor
     */
    omit?: ClientSupervisorOmit<ExtArgs> | null
    /**
     * The data used to update ClientSupervisors.
     */
    data: XOR<ClientSupervisorUpdateManyMutationInput, ClientSupervisorUncheckedUpdateManyInput>
    /**
     * Filter which ClientSupervisors to update
     */
    where?: ClientSupervisorWhereInput
    /**
     * Limit how many ClientSupervisors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSupervisorIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientSupervisor upsert
   */
  export type ClientSupervisorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSupervisor
     */
    select?: ClientSupervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSupervisor
     */
    omit?: ClientSupervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSupervisorInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientSupervisor to update in case it exists.
     */
    where: ClientSupervisorWhereUniqueInput
    /**
     * In case the ClientSupervisor found by the `where` argument doesn't exist, create a new ClientSupervisor with this data.
     */
    create: XOR<ClientSupervisorCreateInput, ClientSupervisorUncheckedCreateInput>
    /**
     * In case the ClientSupervisor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientSupervisorUpdateInput, ClientSupervisorUncheckedUpdateInput>
  }

  /**
   * ClientSupervisor delete
   */
  export type ClientSupervisorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSupervisor
     */
    select?: ClientSupervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSupervisor
     */
    omit?: ClientSupervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSupervisorInclude<ExtArgs> | null
    /**
     * Filter which ClientSupervisor to delete.
     */
    where: ClientSupervisorWhereUniqueInput
  }

  /**
   * ClientSupervisor deleteMany
   */
  export type ClientSupervisorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientSupervisors to delete
     */
    where?: ClientSupervisorWhereInput
    /**
     * Limit how many ClientSupervisors to delete.
     */
    limit?: number
  }

  /**
   * ClientSupervisor without action
   */
  export type ClientSupervisorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientSupervisor
     */
    select?: ClientSupervisorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientSupervisor
     */
    omit?: ClientSupervisorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientSupervisorInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const StaffScalarFieldEnum: {
    id: 'id',
    name: 'name',
    locations: 'locations',
    availability: 'availability',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffScalarFieldEnum = (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    locations: 'locations',
    authorizedHours: 'authorizedHours',
    availability: 'availability',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ScheduleVersionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    status: 'status',
    startDate: 'startDate',
    description: 'description',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduleVersionScalarFieldEnum = (typeof ScheduleVersionScalarFieldEnum)[keyof typeof ScheduleVersionScalarFieldEnum]


  export const AssignmentScalarFieldEnum: {
    id: 'id',
    day: 'day',
    block: 'block',
    staffId: 'staffId',
    clientId: 'clientId',
    versionId: 'versionId',
    isGroup: 'isGroup',
    groupSessionId: 'groupSessionId',
    plannedDate: 'plannedDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssignmentScalarFieldEnum = (typeof AssignmentScalarFieldEnum)[keyof typeof AssignmentScalarFieldEnum]


  export const GroupSessionScalarFieldEnum: {
    id: 'id',
    day: 'day',
    block: 'block',
    staffId: 'staffId',
    versionId: 'versionId',
    location: 'location',
    maxSize: 'maxSize',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupSessionScalarFieldEnum = (typeof GroupSessionScalarFieldEnum)[keyof typeof GroupSessionScalarFieldEnum]


  export const GroupSessionClientScalarFieldEnum: {
    id: 'id',
    groupSessionId: 'groupSessionId',
    clientId: 'clientId'
  };

  export type GroupSessionClientScalarFieldEnum = (typeof GroupSessionClientScalarFieldEnum)[keyof typeof GroupSessionClientScalarFieldEnum]


  export const ChangeLogScalarFieldEnum: {
    id: 'id',
    versionId: 'versionId',
    changeType: 'changeType',
    entityType: 'entityType',
    entityId: 'entityId',
    day: 'day',
    block: 'block',
    staffId: 'staffId',
    clientId: 'clientId',
    previousValue: 'previousValue',
    newValue: 'newValue',
    reviewed: 'reviewed',
    reviewedAt: 'reviewedAt',
    reviewedBy: 'reviewedBy',
    committedToMain: 'committedToMain',
    committedAt: 'committedAt',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    notes: 'notes'
  };

  export type ChangeLogScalarFieldEnum = (typeof ChangeLogScalarFieldEnum)[keyof typeof ChangeLogScalarFieldEnum]


  export const DailyOverrideScalarFieldEnum: {
    id: 'id',
    date: 'date',
    type: 'type',
    day: 'day',
    block: 'block',
    originalStaffId: 'originalStaffId',
    originalClientId: 'originalClientId',
    newStaffId: 'newStaffId',
    newClientId: 'newClientId',
    reason: 'reason',
    hours: 'hours',
    status: 'status',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DailyOverrideScalarFieldEnum = (typeof DailyOverrideScalarFieldEnum)[keyof typeof DailyOverrideScalarFieldEnum]


  export const ClientSupervisorScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    supervisorName: 'supervisorName',
    effectiveDate: 'effectiveDate',
    endDate: 'endDate',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientSupervisorScalarFieldEnum = (typeof ClientSupervisorScalarFieldEnum)[keyof typeof ClientSupervisorScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type StaffWhereInput = {
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    id?: IntFilter<"Staff"> | number
    name?: StringFilter<"Staff"> | string
    locations?: StringNullableListFilter<"Staff">
    availability?: JsonFilter<"Staff">
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
    assignments?: AssignmentListRelationFilter
    groupSessions?: GroupSessionListRelationFilter
    changeLogs?: ChangeLogListRelationFilter
    originalOverrides?: DailyOverrideListRelationFilter
    newOverrides?: DailyOverrideListRelationFilter
  }

  export type StaffOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    locations?: SortOrder
    availability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignments?: AssignmentOrderByRelationAggregateInput
    groupSessions?: GroupSessionOrderByRelationAggregateInput
    changeLogs?: ChangeLogOrderByRelationAggregateInput
    originalOverrides?: DailyOverrideOrderByRelationAggregateInput
    newOverrides?: DailyOverrideOrderByRelationAggregateInput
  }

  export type StaffWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StaffWhereInput | StaffWhereInput[]
    OR?: StaffWhereInput[]
    NOT?: StaffWhereInput | StaffWhereInput[]
    name?: StringFilter<"Staff"> | string
    locations?: StringNullableListFilter<"Staff">
    availability?: JsonFilter<"Staff">
    createdAt?: DateTimeFilter<"Staff"> | Date | string
    updatedAt?: DateTimeFilter<"Staff"> | Date | string
    assignments?: AssignmentListRelationFilter
    groupSessions?: GroupSessionListRelationFilter
    changeLogs?: ChangeLogListRelationFilter
    originalOverrides?: DailyOverrideListRelationFilter
    newOverrides?: DailyOverrideListRelationFilter
  }, "id">

  export type StaffOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    locations?: SortOrder
    availability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffCountOrderByAggregateInput
    _avg?: StaffAvgOrderByAggregateInput
    _max?: StaffMaxOrderByAggregateInput
    _min?: StaffMinOrderByAggregateInput
    _sum?: StaffSumOrderByAggregateInput
  }

  export type StaffScalarWhereWithAggregatesInput = {
    AND?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    OR?: StaffScalarWhereWithAggregatesInput[]
    NOT?: StaffScalarWhereWithAggregatesInput | StaffScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Staff"> | number
    name?: StringWithAggregatesFilter<"Staff"> | string
    locations?: StringNullableListFilter<"Staff">
    availability?: JsonWithAggregatesFilter<"Staff">
    createdAt?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Staff"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: IntFilter<"Client"> | number
    name?: StringFilter<"Client"> | string
    locations?: StringNullableListFilter<"Client">
    authorizedHours?: FloatFilter<"Client"> | number
    availability?: JsonFilter<"Client">
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    assignments?: AssignmentListRelationFilter
    groupSessionClients?: GroupSessionClientListRelationFilter
    changeLogs?: ChangeLogListRelationFilter
    originalOverrides?: DailyOverrideListRelationFilter
    newOverrides?: DailyOverrideListRelationFilter
    supervisorHistory?: ClientSupervisorListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    locations?: SortOrder
    authorizedHours?: SortOrder
    availability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignments?: AssignmentOrderByRelationAggregateInput
    groupSessionClients?: GroupSessionClientOrderByRelationAggregateInput
    changeLogs?: ChangeLogOrderByRelationAggregateInput
    originalOverrides?: DailyOverrideOrderByRelationAggregateInput
    newOverrides?: DailyOverrideOrderByRelationAggregateInput
    supervisorHistory?: ClientSupervisorOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    name?: StringFilter<"Client"> | string
    locations?: StringNullableListFilter<"Client">
    authorizedHours?: FloatFilter<"Client"> | number
    availability?: JsonFilter<"Client">
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    assignments?: AssignmentListRelationFilter
    groupSessionClients?: GroupSessionClientListRelationFilter
    changeLogs?: ChangeLogListRelationFilter
    originalOverrides?: DailyOverrideListRelationFilter
    newOverrides?: DailyOverrideListRelationFilter
    supervisorHistory?: ClientSupervisorListRelationFilter
  }, "id">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    locations?: SortOrder
    authorizedHours?: SortOrder
    availability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Client"> | number
    name?: StringWithAggregatesFilter<"Client"> | string
    locations?: StringNullableListFilter<"Client">
    authorizedHours?: FloatWithAggregatesFilter<"Client"> | number
    availability?: JsonWithAggregatesFilter<"Client">
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type ScheduleVersionWhereInput = {
    AND?: ScheduleVersionWhereInput | ScheduleVersionWhereInput[]
    OR?: ScheduleVersionWhereInput[]
    NOT?: ScheduleVersionWhereInput | ScheduleVersionWhereInput[]
    id?: IntFilter<"ScheduleVersion"> | number
    name?: StringFilter<"ScheduleVersion"> | string
    type?: StringFilter<"ScheduleVersion"> | string
    status?: StringFilter<"ScheduleVersion"> | string
    startDate?: DateTimeNullableFilter<"ScheduleVersion"> | Date | string | null
    description?: StringNullableFilter<"ScheduleVersion"> | string | null
    createdBy?: StringFilter<"ScheduleVersion"> | string
    createdAt?: DateTimeFilter<"ScheduleVersion"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduleVersion"> | Date | string
    assignments?: AssignmentListRelationFilter
    groupSessions?: GroupSessionListRelationFilter
    changeLogs?: ChangeLogListRelationFilter
  }

  export type ScheduleVersionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignments?: AssignmentOrderByRelationAggregateInput
    groupSessions?: GroupSessionOrderByRelationAggregateInput
    changeLogs?: ChangeLogOrderByRelationAggregateInput
  }

  export type ScheduleVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ScheduleVersionWhereInput | ScheduleVersionWhereInput[]
    OR?: ScheduleVersionWhereInput[]
    NOT?: ScheduleVersionWhereInput | ScheduleVersionWhereInput[]
    name?: StringFilter<"ScheduleVersion"> | string
    type?: StringFilter<"ScheduleVersion"> | string
    status?: StringFilter<"ScheduleVersion"> | string
    startDate?: DateTimeNullableFilter<"ScheduleVersion"> | Date | string | null
    description?: StringNullableFilter<"ScheduleVersion"> | string | null
    createdBy?: StringFilter<"ScheduleVersion"> | string
    createdAt?: DateTimeFilter<"ScheduleVersion"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduleVersion"> | Date | string
    assignments?: AssignmentListRelationFilter
    groupSessions?: GroupSessionListRelationFilter
    changeLogs?: ChangeLogListRelationFilter
  }, "id">

  export type ScheduleVersionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduleVersionCountOrderByAggregateInput
    _avg?: ScheduleVersionAvgOrderByAggregateInput
    _max?: ScheduleVersionMaxOrderByAggregateInput
    _min?: ScheduleVersionMinOrderByAggregateInput
    _sum?: ScheduleVersionSumOrderByAggregateInput
  }

  export type ScheduleVersionScalarWhereWithAggregatesInput = {
    AND?: ScheduleVersionScalarWhereWithAggregatesInput | ScheduleVersionScalarWhereWithAggregatesInput[]
    OR?: ScheduleVersionScalarWhereWithAggregatesInput[]
    NOT?: ScheduleVersionScalarWhereWithAggregatesInput | ScheduleVersionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ScheduleVersion"> | number
    name?: StringWithAggregatesFilter<"ScheduleVersion"> | string
    type?: StringWithAggregatesFilter<"ScheduleVersion"> | string
    status?: StringWithAggregatesFilter<"ScheduleVersion"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"ScheduleVersion"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"ScheduleVersion"> | string | null
    createdBy?: StringWithAggregatesFilter<"ScheduleVersion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ScheduleVersion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduleVersion"> | Date | string
  }

  export type AssignmentWhereInput = {
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    id?: IntFilter<"Assignment"> | number
    day?: StringFilter<"Assignment"> | string
    block?: StringFilter<"Assignment"> | string
    staffId?: IntFilter<"Assignment"> | number
    clientId?: IntFilter<"Assignment"> | number
    versionId?: IntFilter<"Assignment"> | number
    isGroup?: BoolFilter<"Assignment"> | boolean
    groupSessionId?: IntNullableFilter<"Assignment"> | number | null
    plannedDate?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    version?: XOR<ScheduleVersionScalarRelationFilter, ScheduleVersionWhereInput>
    groupSession?: XOR<GroupSessionNullableScalarRelationFilter, GroupSessionWhereInput> | null
  }

  export type AssignmentOrderByWithRelationInput = {
    id?: SortOrder
    day?: SortOrder
    block?: SortOrder
    staffId?: SortOrder
    clientId?: SortOrder
    versionId?: SortOrder
    isGroup?: SortOrder
    groupSessionId?: SortOrderInput | SortOrder
    plannedDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    staff?: StaffOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    version?: ScheduleVersionOrderByWithRelationInput
    groupSession?: GroupSessionOrderByWithRelationInput
  }

  export type AssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    day?: StringFilter<"Assignment"> | string
    block?: StringFilter<"Assignment"> | string
    staffId?: IntFilter<"Assignment"> | number
    clientId?: IntFilter<"Assignment"> | number
    versionId?: IntFilter<"Assignment"> | number
    isGroup?: BoolFilter<"Assignment"> | boolean
    groupSessionId?: IntNullableFilter<"Assignment"> | number | null
    plannedDate?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    version?: XOR<ScheduleVersionScalarRelationFilter, ScheduleVersionWhereInput>
    groupSession?: XOR<GroupSessionNullableScalarRelationFilter, GroupSessionWhereInput> | null
  }, "id">

  export type AssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    day?: SortOrder
    block?: SortOrder
    staffId?: SortOrder
    clientId?: SortOrder
    versionId?: SortOrder
    isGroup?: SortOrder
    groupSessionId?: SortOrderInput | SortOrder
    plannedDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssignmentCountOrderByAggregateInput
    _avg?: AssignmentAvgOrderByAggregateInput
    _max?: AssignmentMaxOrderByAggregateInput
    _min?: AssignmentMinOrderByAggregateInput
    _sum?: AssignmentSumOrderByAggregateInput
  }

  export type AssignmentScalarWhereWithAggregatesInput = {
    AND?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    OR?: AssignmentScalarWhereWithAggregatesInput[]
    NOT?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Assignment"> | number
    day?: StringWithAggregatesFilter<"Assignment"> | string
    block?: StringWithAggregatesFilter<"Assignment"> | string
    staffId?: IntWithAggregatesFilter<"Assignment"> | number
    clientId?: IntWithAggregatesFilter<"Assignment"> | number
    versionId?: IntWithAggregatesFilter<"Assignment"> | number
    isGroup?: BoolWithAggregatesFilter<"Assignment"> | boolean
    groupSessionId?: IntNullableWithAggregatesFilter<"Assignment"> | number | null
    plannedDate?: DateTimeNullableWithAggregatesFilter<"Assignment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
  }

  export type GroupSessionWhereInput = {
    AND?: GroupSessionWhereInput | GroupSessionWhereInput[]
    OR?: GroupSessionWhereInput[]
    NOT?: GroupSessionWhereInput | GroupSessionWhereInput[]
    id?: IntFilter<"GroupSession"> | number
    day?: StringFilter<"GroupSession"> | string
    block?: StringFilter<"GroupSession"> | string
    staffId?: IntFilter<"GroupSession"> | number
    versionId?: IntFilter<"GroupSession"> | number
    location?: StringFilter<"GroupSession"> | string
    maxSize?: IntFilter<"GroupSession"> | number
    createdAt?: DateTimeFilter<"GroupSession"> | Date | string
    updatedAt?: DateTimeFilter<"GroupSession"> | Date | string
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
    version?: XOR<ScheduleVersionScalarRelationFilter, ScheduleVersionWhereInput>
    clients?: GroupSessionClientListRelationFilter
    assignments?: AssignmentListRelationFilter
  }

  export type GroupSessionOrderByWithRelationInput = {
    id?: SortOrder
    day?: SortOrder
    block?: SortOrder
    staffId?: SortOrder
    versionId?: SortOrder
    location?: SortOrder
    maxSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    staff?: StaffOrderByWithRelationInput
    version?: ScheduleVersionOrderByWithRelationInput
    clients?: GroupSessionClientOrderByRelationAggregateInput
    assignments?: AssignmentOrderByRelationAggregateInput
  }

  export type GroupSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    versionId_day_block_staffId?: GroupSessionVersionIdDayBlockStaffIdCompoundUniqueInput
    AND?: GroupSessionWhereInput | GroupSessionWhereInput[]
    OR?: GroupSessionWhereInput[]
    NOT?: GroupSessionWhereInput | GroupSessionWhereInput[]
    day?: StringFilter<"GroupSession"> | string
    block?: StringFilter<"GroupSession"> | string
    staffId?: IntFilter<"GroupSession"> | number
    versionId?: IntFilter<"GroupSession"> | number
    location?: StringFilter<"GroupSession"> | string
    maxSize?: IntFilter<"GroupSession"> | number
    createdAt?: DateTimeFilter<"GroupSession"> | Date | string
    updatedAt?: DateTimeFilter<"GroupSession"> | Date | string
    staff?: XOR<StaffScalarRelationFilter, StaffWhereInput>
    version?: XOR<ScheduleVersionScalarRelationFilter, ScheduleVersionWhereInput>
    clients?: GroupSessionClientListRelationFilter
    assignments?: AssignmentListRelationFilter
  }, "id" | "versionId_day_block_staffId">

  export type GroupSessionOrderByWithAggregationInput = {
    id?: SortOrder
    day?: SortOrder
    block?: SortOrder
    staffId?: SortOrder
    versionId?: SortOrder
    location?: SortOrder
    maxSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupSessionCountOrderByAggregateInput
    _avg?: GroupSessionAvgOrderByAggregateInput
    _max?: GroupSessionMaxOrderByAggregateInput
    _min?: GroupSessionMinOrderByAggregateInput
    _sum?: GroupSessionSumOrderByAggregateInput
  }

  export type GroupSessionScalarWhereWithAggregatesInput = {
    AND?: GroupSessionScalarWhereWithAggregatesInput | GroupSessionScalarWhereWithAggregatesInput[]
    OR?: GroupSessionScalarWhereWithAggregatesInput[]
    NOT?: GroupSessionScalarWhereWithAggregatesInput | GroupSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GroupSession"> | number
    day?: StringWithAggregatesFilter<"GroupSession"> | string
    block?: StringWithAggregatesFilter<"GroupSession"> | string
    staffId?: IntWithAggregatesFilter<"GroupSession"> | number
    versionId?: IntWithAggregatesFilter<"GroupSession"> | number
    location?: StringWithAggregatesFilter<"GroupSession"> | string
    maxSize?: IntWithAggregatesFilter<"GroupSession"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GroupSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GroupSession"> | Date | string
  }

  export type GroupSessionClientWhereInput = {
    AND?: GroupSessionClientWhereInput | GroupSessionClientWhereInput[]
    OR?: GroupSessionClientWhereInput[]
    NOT?: GroupSessionClientWhereInput | GroupSessionClientWhereInput[]
    id?: IntFilter<"GroupSessionClient"> | number
    groupSessionId?: IntFilter<"GroupSessionClient"> | number
    clientId?: IntFilter<"GroupSessionClient"> | number
    groupSession?: XOR<GroupSessionScalarRelationFilter, GroupSessionWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type GroupSessionClientOrderByWithRelationInput = {
    id?: SortOrder
    groupSessionId?: SortOrder
    clientId?: SortOrder
    groupSession?: GroupSessionOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
  }

  export type GroupSessionClientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    groupSessionId_clientId?: GroupSessionClientGroupSessionIdClientIdCompoundUniqueInput
    AND?: GroupSessionClientWhereInput | GroupSessionClientWhereInput[]
    OR?: GroupSessionClientWhereInput[]
    NOT?: GroupSessionClientWhereInput | GroupSessionClientWhereInput[]
    groupSessionId?: IntFilter<"GroupSessionClient"> | number
    clientId?: IntFilter<"GroupSessionClient"> | number
    groupSession?: XOR<GroupSessionScalarRelationFilter, GroupSessionWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id" | "groupSessionId_clientId">

  export type GroupSessionClientOrderByWithAggregationInput = {
    id?: SortOrder
    groupSessionId?: SortOrder
    clientId?: SortOrder
    _count?: GroupSessionClientCountOrderByAggregateInput
    _avg?: GroupSessionClientAvgOrderByAggregateInput
    _max?: GroupSessionClientMaxOrderByAggregateInput
    _min?: GroupSessionClientMinOrderByAggregateInput
    _sum?: GroupSessionClientSumOrderByAggregateInput
  }

  export type GroupSessionClientScalarWhereWithAggregatesInput = {
    AND?: GroupSessionClientScalarWhereWithAggregatesInput | GroupSessionClientScalarWhereWithAggregatesInput[]
    OR?: GroupSessionClientScalarWhereWithAggregatesInput[]
    NOT?: GroupSessionClientScalarWhereWithAggregatesInput | GroupSessionClientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GroupSessionClient"> | number
    groupSessionId?: IntWithAggregatesFilter<"GroupSessionClient"> | number
    clientId?: IntWithAggregatesFilter<"GroupSessionClient"> | number
  }

  export type ChangeLogWhereInput = {
    AND?: ChangeLogWhereInput | ChangeLogWhereInput[]
    OR?: ChangeLogWhereInput[]
    NOT?: ChangeLogWhereInput | ChangeLogWhereInput[]
    id?: IntFilter<"ChangeLog"> | number
    versionId?: IntFilter<"ChangeLog"> | number
    changeType?: StringFilter<"ChangeLog"> | string
    entityType?: StringFilter<"ChangeLog"> | string
    entityId?: IntNullableFilter<"ChangeLog"> | number | null
    day?: StringNullableFilter<"ChangeLog"> | string | null
    block?: StringNullableFilter<"ChangeLog"> | string | null
    staffId?: IntNullableFilter<"ChangeLog"> | number | null
    clientId?: IntNullableFilter<"ChangeLog"> | number | null
    previousValue?: JsonNullableFilter<"ChangeLog">
    newValue?: JsonNullableFilter<"ChangeLog">
    reviewed?: BoolFilter<"ChangeLog"> | boolean
    reviewedAt?: DateTimeNullableFilter<"ChangeLog"> | Date | string | null
    reviewedBy?: StringNullableFilter<"ChangeLog"> | string | null
    committedToMain?: BoolFilter<"ChangeLog"> | boolean
    committedAt?: DateTimeNullableFilter<"ChangeLog"> | Date | string | null
    createdBy?: StringFilter<"ChangeLog"> | string
    createdAt?: DateTimeFilter<"ChangeLog"> | Date | string
    notes?: StringNullableFilter<"ChangeLog"> | string | null
    version?: XOR<ScheduleVersionScalarRelationFilter, ScheduleVersionWhereInput>
    staff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }

  export type ChangeLogOrderByWithRelationInput = {
    id?: SortOrder
    versionId?: SortOrder
    changeType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    day?: SortOrderInput | SortOrder
    block?: SortOrderInput | SortOrder
    staffId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    previousValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    reviewed?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    committedToMain?: SortOrder
    committedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    version?: ScheduleVersionOrderByWithRelationInput
    staff?: StaffOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
  }

  export type ChangeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChangeLogWhereInput | ChangeLogWhereInput[]
    OR?: ChangeLogWhereInput[]
    NOT?: ChangeLogWhereInput | ChangeLogWhereInput[]
    versionId?: IntFilter<"ChangeLog"> | number
    changeType?: StringFilter<"ChangeLog"> | string
    entityType?: StringFilter<"ChangeLog"> | string
    entityId?: IntNullableFilter<"ChangeLog"> | number | null
    day?: StringNullableFilter<"ChangeLog"> | string | null
    block?: StringNullableFilter<"ChangeLog"> | string | null
    staffId?: IntNullableFilter<"ChangeLog"> | number | null
    clientId?: IntNullableFilter<"ChangeLog"> | number | null
    previousValue?: JsonNullableFilter<"ChangeLog">
    newValue?: JsonNullableFilter<"ChangeLog">
    reviewed?: BoolFilter<"ChangeLog"> | boolean
    reviewedAt?: DateTimeNullableFilter<"ChangeLog"> | Date | string | null
    reviewedBy?: StringNullableFilter<"ChangeLog"> | string | null
    committedToMain?: BoolFilter<"ChangeLog"> | boolean
    committedAt?: DateTimeNullableFilter<"ChangeLog"> | Date | string | null
    createdBy?: StringFilter<"ChangeLog"> | string
    createdAt?: DateTimeFilter<"ChangeLog"> | Date | string
    notes?: StringNullableFilter<"ChangeLog"> | string | null
    version?: XOR<ScheduleVersionScalarRelationFilter, ScheduleVersionWhereInput>
    staff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }, "id">

  export type ChangeLogOrderByWithAggregationInput = {
    id?: SortOrder
    versionId?: SortOrder
    changeType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    day?: SortOrderInput | SortOrder
    block?: SortOrderInput | SortOrder
    staffId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    previousValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    reviewed?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    committedToMain?: SortOrder
    committedAt?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ChangeLogCountOrderByAggregateInput
    _avg?: ChangeLogAvgOrderByAggregateInput
    _max?: ChangeLogMaxOrderByAggregateInput
    _min?: ChangeLogMinOrderByAggregateInput
    _sum?: ChangeLogSumOrderByAggregateInput
  }

  export type ChangeLogScalarWhereWithAggregatesInput = {
    AND?: ChangeLogScalarWhereWithAggregatesInput | ChangeLogScalarWhereWithAggregatesInput[]
    OR?: ChangeLogScalarWhereWithAggregatesInput[]
    NOT?: ChangeLogScalarWhereWithAggregatesInput | ChangeLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChangeLog"> | number
    versionId?: IntWithAggregatesFilter<"ChangeLog"> | number
    changeType?: StringWithAggregatesFilter<"ChangeLog"> | string
    entityType?: StringWithAggregatesFilter<"ChangeLog"> | string
    entityId?: IntNullableWithAggregatesFilter<"ChangeLog"> | number | null
    day?: StringNullableWithAggregatesFilter<"ChangeLog"> | string | null
    block?: StringNullableWithAggregatesFilter<"ChangeLog"> | string | null
    staffId?: IntNullableWithAggregatesFilter<"ChangeLog"> | number | null
    clientId?: IntNullableWithAggregatesFilter<"ChangeLog"> | number | null
    previousValue?: JsonNullableWithAggregatesFilter<"ChangeLog">
    newValue?: JsonNullableWithAggregatesFilter<"ChangeLog">
    reviewed?: BoolWithAggregatesFilter<"ChangeLog"> | boolean
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"ChangeLog"> | Date | string | null
    reviewedBy?: StringNullableWithAggregatesFilter<"ChangeLog"> | string | null
    committedToMain?: BoolWithAggregatesFilter<"ChangeLog"> | boolean
    committedAt?: DateTimeNullableWithAggregatesFilter<"ChangeLog"> | Date | string | null
    createdBy?: StringWithAggregatesFilter<"ChangeLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChangeLog"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"ChangeLog"> | string | null
  }

  export type DailyOverrideWhereInput = {
    AND?: DailyOverrideWhereInput | DailyOverrideWhereInput[]
    OR?: DailyOverrideWhereInput[]
    NOT?: DailyOverrideWhereInput | DailyOverrideWhereInput[]
    id?: IntFilter<"DailyOverride"> | number
    date?: DateTimeFilter<"DailyOverride"> | Date | string
    type?: StringFilter<"DailyOverride"> | string
    day?: StringFilter<"DailyOverride"> | string
    block?: StringFilter<"DailyOverride"> | string
    originalStaffId?: IntNullableFilter<"DailyOverride"> | number | null
    originalClientId?: IntNullableFilter<"DailyOverride"> | number | null
    newStaffId?: IntNullableFilter<"DailyOverride"> | number | null
    newClientId?: IntNullableFilter<"DailyOverride"> | number | null
    reason?: StringFilter<"DailyOverride"> | string
    hours?: FloatNullableFilter<"DailyOverride"> | number | null
    status?: StringFilter<"DailyOverride"> | string
    createdBy?: StringFilter<"DailyOverride"> | string
    createdAt?: DateTimeFilter<"DailyOverride"> | Date | string
    updatedAt?: DateTimeFilter<"DailyOverride"> | Date | string
    originalStaff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
    originalClient?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    newStaff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
    newClient?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }

  export type DailyOverrideOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    day?: SortOrder
    block?: SortOrder
    originalStaffId?: SortOrderInput | SortOrder
    originalClientId?: SortOrderInput | SortOrder
    newStaffId?: SortOrderInput | SortOrder
    newClientId?: SortOrderInput | SortOrder
    reason?: SortOrder
    hours?: SortOrderInput | SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    originalStaff?: StaffOrderByWithRelationInput
    originalClient?: ClientOrderByWithRelationInput
    newStaff?: StaffOrderByWithRelationInput
    newClient?: ClientOrderByWithRelationInput
  }

  export type DailyOverrideWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DailyOverrideWhereInput | DailyOverrideWhereInput[]
    OR?: DailyOverrideWhereInput[]
    NOT?: DailyOverrideWhereInput | DailyOverrideWhereInput[]
    date?: DateTimeFilter<"DailyOverride"> | Date | string
    type?: StringFilter<"DailyOverride"> | string
    day?: StringFilter<"DailyOverride"> | string
    block?: StringFilter<"DailyOverride"> | string
    originalStaffId?: IntNullableFilter<"DailyOverride"> | number | null
    originalClientId?: IntNullableFilter<"DailyOverride"> | number | null
    newStaffId?: IntNullableFilter<"DailyOverride"> | number | null
    newClientId?: IntNullableFilter<"DailyOverride"> | number | null
    reason?: StringFilter<"DailyOverride"> | string
    hours?: FloatNullableFilter<"DailyOverride"> | number | null
    status?: StringFilter<"DailyOverride"> | string
    createdBy?: StringFilter<"DailyOverride"> | string
    createdAt?: DateTimeFilter<"DailyOverride"> | Date | string
    updatedAt?: DateTimeFilter<"DailyOverride"> | Date | string
    originalStaff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
    originalClient?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    newStaff?: XOR<StaffNullableScalarRelationFilter, StaffWhereInput> | null
    newClient?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }, "id">

  export type DailyOverrideOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    day?: SortOrder
    block?: SortOrder
    originalStaffId?: SortOrderInput | SortOrder
    originalClientId?: SortOrderInput | SortOrder
    newStaffId?: SortOrderInput | SortOrder
    newClientId?: SortOrderInput | SortOrder
    reason?: SortOrder
    hours?: SortOrderInput | SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DailyOverrideCountOrderByAggregateInput
    _avg?: DailyOverrideAvgOrderByAggregateInput
    _max?: DailyOverrideMaxOrderByAggregateInput
    _min?: DailyOverrideMinOrderByAggregateInput
    _sum?: DailyOverrideSumOrderByAggregateInput
  }

  export type DailyOverrideScalarWhereWithAggregatesInput = {
    AND?: DailyOverrideScalarWhereWithAggregatesInput | DailyOverrideScalarWhereWithAggregatesInput[]
    OR?: DailyOverrideScalarWhereWithAggregatesInput[]
    NOT?: DailyOverrideScalarWhereWithAggregatesInput | DailyOverrideScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DailyOverride"> | number
    date?: DateTimeWithAggregatesFilter<"DailyOverride"> | Date | string
    type?: StringWithAggregatesFilter<"DailyOverride"> | string
    day?: StringWithAggregatesFilter<"DailyOverride"> | string
    block?: StringWithAggregatesFilter<"DailyOverride"> | string
    originalStaffId?: IntNullableWithAggregatesFilter<"DailyOverride"> | number | null
    originalClientId?: IntNullableWithAggregatesFilter<"DailyOverride"> | number | null
    newStaffId?: IntNullableWithAggregatesFilter<"DailyOverride"> | number | null
    newClientId?: IntNullableWithAggregatesFilter<"DailyOverride"> | number | null
    reason?: StringWithAggregatesFilter<"DailyOverride"> | string
    hours?: FloatNullableWithAggregatesFilter<"DailyOverride"> | number | null
    status?: StringWithAggregatesFilter<"DailyOverride"> | string
    createdBy?: StringWithAggregatesFilter<"DailyOverride"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DailyOverride"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailyOverride"> | Date | string
  }

  export type ClientSupervisorWhereInput = {
    AND?: ClientSupervisorWhereInput | ClientSupervisorWhereInput[]
    OR?: ClientSupervisorWhereInput[]
    NOT?: ClientSupervisorWhereInput | ClientSupervisorWhereInput[]
    id?: IntFilter<"ClientSupervisor"> | number
    clientId?: IntFilter<"ClientSupervisor"> | number
    supervisorName?: StringFilter<"ClientSupervisor"> | string
    effectiveDate?: DateTimeFilter<"ClientSupervisor"> | Date | string
    endDate?: DateTimeNullableFilter<"ClientSupervisor"> | Date | string | null
    createdBy?: StringFilter<"ClientSupervisor"> | string
    createdAt?: DateTimeFilter<"ClientSupervisor"> | Date | string
    updatedAt?: DateTimeFilter<"ClientSupervisor"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type ClientSupervisorOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    supervisorName?: SortOrder
    effectiveDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type ClientSupervisorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClientSupervisorWhereInput | ClientSupervisorWhereInput[]
    OR?: ClientSupervisorWhereInput[]
    NOT?: ClientSupervisorWhereInput | ClientSupervisorWhereInput[]
    clientId?: IntFilter<"ClientSupervisor"> | number
    supervisorName?: StringFilter<"ClientSupervisor"> | string
    effectiveDate?: DateTimeFilter<"ClientSupervisor"> | Date | string
    endDate?: DateTimeNullableFilter<"ClientSupervisor"> | Date | string | null
    createdBy?: StringFilter<"ClientSupervisor"> | string
    createdAt?: DateTimeFilter<"ClientSupervisor"> | Date | string
    updatedAt?: DateTimeFilter<"ClientSupervisor"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type ClientSupervisorOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    supervisorName?: SortOrder
    effectiveDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientSupervisorCountOrderByAggregateInput
    _avg?: ClientSupervisorAvgOrderByAggregateInput
    _max?: ClientSupervisorMaxOrderByAggregateInput
    _min?: ClientSupervisorMinOrderByAggregateInput
    _sum?: ClientSupervisorSumOrderByAggregateInput
  }

  export type ClientSupervisorScalarWhereWithAggregatesInput = {
    AND?: ClientSupervisorScalarWhereWithAggregatesInput | ClientSupervisorScalarWhereWithAggregatesInput[]
    OR?: ClientSupervisorScalarWhereWithAggregatesInput[]
    NOT?: ClientSupervisorScalarWhereWithAggregatesInput | ClientSupervisorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClientSupervisor"> | number
    clientId?: IntWithAggregatesFilter<"ClientSupervisor"> | number
    supervisorName?: StringWithAggregatesFilter<"ClientSupervisor"> | string
    effectiveDate?: DateTimeWithAggregatesFilter<"ClientSupervisor"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"ClientSupervisor"> | Date | string | null
    createdBy?: StringWithAggregatesFilter<"ClientSupervisor"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClientSupervisor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientSupervisor"> | Date | string
  }

  export type StaffCreateInput = {
    name: string
    locations?: StaffCreatelocationsInput | string[]
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutStaffInput
    groupSessions?: GroupSessionCreateNestedManyWithoutStaffInput
    changeLogs?: ChangeLogCreateNestedManyWithoutStaffInput
    originalOverrides?: DailyOverrideCreateNestedManyWithoutOriginalStaffInput
    newOverrides?: DailyOverrideCreateNestedManyWithoutNewStaffInput
  }

  export type StaffUncheckedCreateInput = {
    id?: number
    name: string
    locations?: StaffCreatelocationsInput | string[]
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutStaffInput
    groupSessions?: GroupSessionUncheckedCreateNestedManyWithoutStaffInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutStaffInput
    originalOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutOriginalStaffInput
    newOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutNewStaffInput
  }

  export type StaffUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    locations?: StaffUpdatelocationsInput | string[]
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutStaffNestedInput
    groupSessions?: GroupSessionUpdateManyWithoutStaffNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutStaffNestedInput
    originalOverrides?: DailyOverrideUpdateManyWithoutOriginalStaffNestedInput
    newOverrides?: DailyOverrideUpdateManyWithoutNewStaffNestedInput
  }

  export type StaffUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: StaffUpdatelocationsInput | string[]
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutStaffNestedInput
    groupSessions?: GroupSessionUncheckedUpdateManyWithoutStaffNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutStaffNestedInput
    originalOverrides?: DailyOverrideUncheckedUpdateManyWithoutOriginalStaffNestedInput
    newOverrides?: DailyOverrideUncheckedUpdateManyWithoutNewStaffNestedInput
  }

  export type StaffCreateManyInput = {
    id?: number
    name: string
    locations?: StaffCreatelocationsInput | string[]
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    locations?: StaffUpdatelocationsInput | string[]
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: StaffUpdatelocationsInput | string[]
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    name: string
    locations?: ClientCreatelocationsInput | string[]
    authorizedHours?: number
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutClientInput
    groupSessionClients?: GroupSessionClientCreateNestedManyWithoutClientInput
    changeLogs?: ChangeLogCreateNestedManyWithoutClientInput
    originalOverrides?: DailyOverrideCreateNestedManyWithoutOriginalClientInput
    newOverrides?: DailyOverrideCreateNestedManyWithoutNewClientInput
    supervisorHistory?: ClientSupervisorCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: number
    name: string
    locations?: ClientCreatelocationsInput | string[]
    authorizedHours?: number
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientInput
    groupSessionClients?: GroupSessionClientUncheckedCreateNestedManyWithoutClientInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutClientInput
    originalOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutOriginalClientInput
    newOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutNewClientInput
    supervisorHistory?: ClientSupervisorUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    locations?: ClientUpdatelocationsInput | string[]
    authorizedHours?: FloatFieldUpdateOperationsInput | number
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutClientNestedInput
    groupSessionClients?: GroupSessionClientUpdateManyWithoutClientNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutClientNestedInput
    originalOverrides?: DailyOverrideUpdateManyWithoutOriginalClientNestedInput
    newOverrides?: DailyOverrideUpdateManyWithoutNewClientNestedInput
    supervisorHistory?: ClientSupervisorUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: ClientUpdatelocationsInput | string[]
    authorizedHours?: FloatFieldUpdateOperationsInput | number
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutClientNestedInput
    groupSessionClients?: GroupSessionClientUncheckedUpdateManyWithoutClientNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutClientNestedInput
    originalOverrides?: DailyOverrideUncheckedUpdateManyWithoutOriginalClientNestedInput
    newOverrides?: DailyOverrideUncheckedUpdateManyWithoutNewClientNestedInput
    supervisorHistory?: ClientSupervisorUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: number
    name: string
    locations?: ClientCreatelocationsInput | string[]
    authorizedHours?: number
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    locations?: ClientUpdatelocationsInput | string[]
    authorizedHours?: FloatFieldUpdateOperationsInput | number
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: ClientUpdatelocationsInput | string[]
    authorizedHours?: FloatFieldUpdateOperationsInput | number
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleVersionCreateInput = {
    name: string
    type: string
    status?: string
    startDate?: Date | string | null
    description?: string | null
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutVersionInput
    groupSessions?: GroupSessionCreateNestedManyWithoutVersionInput
    changeLogs?: ChangeLogCreateNestedManyWithoutVersionInput
  }

  export type ScheduleVersionUncheckedCreateInput = {
    id?: number
    name: string
    type: string
    status?: string
    startDate?: Date | string | null
    description?: string | null
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutVersionInput
    groupSessions?: GroupSessionUncheckedCreateNestedManyWithoutVersionInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutVersionInput
  }

  export type ScheduleVersionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutVersionNestedInput
    groupSessions?: GroupSessionUpdateManyWithoutVersionNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutVersionNestedInput
  }

  export type ScheduleVersionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutVersionNestedInput
    groupSessions?: GroupSessionUncheckedUpdateManyWithoutVersionNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type ScheduleVersionCreateManyInput = {
    id?: number
    name: string
    type: string
    status?: string
    startDate?: Date | string | null
    description?: string | null
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleVersionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleVersionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentCreateInput = {
    day: string
    block: string
    isGroup?: boolean
    plannedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffCreateNestedOneWithoutAssignmentsInput
    client: ClientCreateNestedOneWithoutAssignmentsInput
    version?: ScheduleVersionCreateNestedOneWithoutAssignmentsInput
    groupSession?: GroupSessionCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentUncheckedCreateInput = {
    id?: number
    day: string
    block: string
    staffId: number
    clientId: number
    versionId?: number
    isGroup?: boolean
    groupSessionId?: number | null
    plannedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentUpdateInput = {
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneRequiredWithoutAssignmentsNestedInput
    client?: ClientUpdateOneRequiredWithoutAssignmentsNestedInput
    version?: ScheduleVersionUpdateOneRequiredWithoutAssignmentsNestedInput
    groupSession?: GroupSessionUpdateOneWithoutAssignmentsNestedInput
  }

  export type AssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentCreateManyInput = {
    id?: number
    day: string
    block: string
    staffId: number
    clientId: number
    versionId?: number
    isGroup?: boolean
    groupSessionId?: number | null
    plannedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentUpdateManyMutationInput = {
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupSessionCreateInput = {
    day: string
    block: string
    location: string
    maxSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffCreateNestedOneWithoutGroupSessionsInput
    version?: ScheduleVersionCreateNestedOneWithoutGroupSessionsInput
    clients?: GroupSessionClientCreateNestedManyWithoutGroupSessionInput
    assignments?: AssignmentCreateNestedManyWithoutGroupSessionInput
  }

  export type GroupSessionUncheckedCreateInput = {
    id?: number
    day: string
    block: string
    staffId: number
    versionId?: number
    location: string
    maxSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: GroupSessionClientUncheckedCreateNestedManyWithoutGroupSessionInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutGroupSessionInput
  }

  export type GroupSessionUpdateInput = {
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    maxSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneRequiredWithoutGroupSessionsNestedInput
    version?: ScheduleVersionUpdateOneRequiredWithoutGroupSessionsNestedInput
    clients?: GroupSessionClientUpdateManyWithoutGroupSessionNestedInput
    assignments?: AssignmentUpdateManyWithoutGroupSessionNestedInput
  }

  export type GroupSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    maxSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: GroupSessionClientUncheckedUpdateManyWithoutGroupSessionNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutGroupSessionNestedInput
  }

  export type GroupSessionCreateManyInput = {
    id?: number
    day: string
    block: string
    staffId: number
    versionId?: number
    location: string
    maxSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupSessionUpdateManyMutationInput = {
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    maxSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    maxSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupSessionClientCreateInput = {
    groupSession: GroupSessionCreateNestedOneWithoutClientsInput
    client: ClientCreateNestedOneWithoutGroupSessionClientsInput
  }

  export type GroupSessionClientUncheckedCreateInput = {
    id?: number
    groupSessionId: number
    clientId: number
  }

  export type GroupSessionClientUpdateInput = {
    groupSession?: GroupSessionUpdateOneRequiredWithoutClientsNestedInput
    client?: ClientUpdateOneRequiredWithoutGroupSessionClientsNestedInput
  }

  export type GroupSessionClientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupSessionId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
  }

  export type GroupSessionClientCreateManyInput = {
    id?: number
    groupSessionId: number
    clientId: number
  }

  export type GroupSessionClientUpdateManyMutationInput = {

  }

  export type GroupSessionClientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupSessionId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
  }

  export type ChangeLogCreateInput = {
    changeType: string
    entityType: string
    entityId?: number | null
    day?: string | null
    block?: string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: boolean
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    committedToMain?: boolean
    committedAt?: Date | string | null
    createdBy?: string
    createdAt?: Date | string
    notes?: string | null
    version: ScheduleVersionCreateNestedOneWithoutChangeLogsInput
    staff?: StaffCreateNestedOneWithoutChangeLogsInput
    client?: ClientCreateNestedOneWithoutChangeLogsInput
  }

  export type ChangeLogUncheckedCreateInput = {
    id?: number
    versionId: number
    changeType: string
    entityType: string
    entityId?: number | null
    day?: string | null
    block?: string | null
    staffId?: number | null
    clientId?: number | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: boolean
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    committedToMain?: boolean
    committedAt?: Date | string | null
    createdBy?: string
    createdAt?: Date | string
    notes?: string | null
  }

  export type ChangeLogUpdateInput = {
    changeType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    committedToMain?: BoolFieldUpdateOperationsInput | boolean
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    version?: ScheduleVersionUpdateOneRequiredWithoutChangeLogsNestedInput
    staff?: StaffUpdateOneWithoutChangeLogsNestedInput
    client?: ClientUpdateOneWithoutChangeLogsNestedInput
  }

  export type ChangeLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    changeType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    committedToMain?: BoolFieldUpdateOperationsInput | boolean
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeLogCreateManyInput = {
    id?: number
    versionId: number
    changeType: string
    entityType: string
    entityId?: number | null
    day?: string | null
    block?: string | null
    staffId?: number | null
    clientId?: number | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: boolean
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    committedToMain?: boolean
    committedAt?: Date | string | null
    createdBy?: string
    createdAt?: Date | string
    notes?: string | null
  }

  export type ChangeLogUpdateManyMutationInput = {
    changeType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    committedToMain?: BoolFieldUpdateOperationsInput | boolean
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    changeType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    committedToMain?: BoolFieldUpdateOperationsInput | boolean
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DailyOverrideCreateInput = {
    date: Date | string
    type: string
    day: string
    block: string
    reason: string
    hours?: number | null
    status?: string
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    originalStaff?: StaffCreateNestedOneWithoutOriginalOverridesInput
    originalClient?: ClientCreateNestedOneWithoutOriginalOverridesInput
    newStaff?: StaffCreateNestedOneWithoutNewOverridesInput
    newClient?: ClientCreateNestedOneWithoutNewOverridesInput
  }

  export type DailyOverrideUncheckedCreateInput = {
    id?: number
    date: Date | string
    type: string
    day: string
    block: string
    originalStaffId?: number | null
    originalClientId?: number | null
    newStaffId?: number | null
    newClientId?: number | null
    reason: string
    hours?: number | null
    status?: string
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyOverrideUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalStaff?: StaffUpdateOneWithoutOriginalOverridesNestedInput
    originalClient?: ClientUpdateOneWithoutOriginalOverridesNestedInput
    newStaff?: StaffUpdateOneWithoutNewOverridesNestedInput
    newClient?: ClientUpdateOneWithoutNewOverridesNestedInput
  }

  export type DailyOverrideUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    originalStaffId?: NullableIntFieldUpdateOperationsInput | number | null
    originalClientId?: NullableIntFieldUpdateOperationsInput | number | null
    newStaffId?: NullableIntFieldUpdateOperationsInput | number | null
    newClientId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyOverrideCreateManyInput = {
    id?: number
    date: Date | string
    type: string
    day: string
    block: string
    originalStaffId?: number | null
    originalClientId?: number | null
    newStaffId?: number | null
    newClientId?: number | null
    reason: string
    hours?: number | null
    status?: string
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyOverrideUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyOverrideUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    originalStaffId?: NullableIntFieldUpdateOperationsInput | number | null
    originalClientId?: NullableIntFieldUpdateOperationsInput | number | null
    newStaffId?: NullableIntFieldUpdateOperationsInput | number | null
    newClientId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSupervisorCreateInput = {
    supervisorName: string
    effectiveDate: Date | string
    endDate?: Date | string | null
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutSupervisorHistoryInput
  }

  export type ClientSupervisorUncheckedCreateInput = {
    id?: number
    clientId: number
    supervisorName: string
    effectiveDate: Date | string
    endDate?: Date | string | null
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientSupervisorUpdateInput = {
    supervisorName?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutSupervisorHistoryNestedInput
  }

  export type ClientSupervisorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    supervisorName?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSupervisorCreateManyInput = {
    id?: number
    clientId: number
    supervisorName: string
    effectiveDate: Date | string
    endDate?: Date | string | null
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientSupervisorUpdateManyMutationInput = {
    supervisorName?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSupervisorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    supervisorName?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AssignmentListRelationFilter = {
    every?: AssignmentWhereInput
    some?: AssignmentWhereInput
    none?: AssignmentWhereInput
  }

  export type GroupSessionListRelationFilter = {
    every?: GroupSessionWhereInput
    some?: GroupSessionWhereInput
    none?: GroupSessionWhereInput
  }

  export type ChangeLogListRelationFilter = {
    every?: ChangeLogWhereInput
    some?: ChangeLogWhereInput
    none?: ChangeLogWhereInput
  }

  export type DailyOverrideListRelationFilter = {
    every?: DailyOverrideWhereInput
    some?: DailyOverrideWhereInput
    none?: DailyOverrideWhereInput
  }

  export type AssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChangeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyOverrideOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    locations?: SortOrder
    availability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StaffMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type GroupSessionClientListRelationFilter = {
    every?: GroupSessionClientWhereInput
    some?: GroupSessionClientWhereInput
    none?: GroupSessionClientWhereInput
  }

  export type ClientSupervisorListRelationFilter = {
    every?: ClientSupervisorWhereInput
    some?: ClientSupervisorWhereInput
    none?: ClientSupervisorWhereInput
  }

  export type GroupSessionClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientSupervisorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    locations?: SortOrder
    authorizedHours?: SortOrder
    availability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    id?: SortOrder
    authorizedHours?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    authorizedHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    authorizedHours?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    id?: SortOrder
    authorizedHours?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ScheduleVersionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleVersionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ScheduleVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleVersionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    description?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleVersionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StaffScalarRelationFilter = {
    is?: StaffWhereInput
    isNot?: StaffWhereInput
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type ScheduleVersionScalarRelationFilter = {
    is?: ScheduleVersionWhereInput
    isNot?: ScheduleVersionWhereInput
  }

  export type GroupSessionNullableScalarRelationFilter = {
    is?: GroupSessionWhereInput | null
    isNot?: GroupSessionWhereInput | null
  }

  export type AssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    day?: SortOrder
    block?: SortOrder
    staffId?: SortOrder
    clientId?: SortOrder
    versionId?: SortOrder
    isGroup?: SortOrder
    groupSessionId?: SortOrder
    plannedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    clientId?: SortOrder
    versionId?: SortOrder
    groupSessionId?: SortOrder
  }

  export type AssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    day?: SortOrder
    block?: SortOrder
    staffId?: SortOrder
    clientId?: SortOrder
    versionId?: SortOrder
    isGroup?: SortOrder
    groupSessionId?: SortOrder
    plannedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    day?: SortOrder
    block?: SortOrder
    staffId?: SortOrder
    clientId?: SortOrder
    versionId?: SortOrder
    isGroup?: SortOrder
    groupSessionId?: SortOrder
    plannedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    clientId?: SortOrder
    versionId?: SortOrder
    groupSessionId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type GroupSessionVersionIdDayBlockStaffIdCompoundUniqueInput = {
    versionId: number
    day: string
    block: string
    staffId: number
  }

  export type GroupSessionCountOrderByAggregateInput = {
    id?: SortOrder
    day?: SortOrder
    block?: SortOrder
    staffId?: SortOrder
    versionId?: SortOrder
    location?: SortOrder
    maxSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    versionId?: SortOrder
    maxSize?: SortOrder
  }

  export type GroupSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    day?: SortOrder
    block?: SortOrder
    staffId?: SortOrder
    versionId?: SortOrder
    location?: SortOrder
    maxSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupSessionMinOrderByAggregateInput = {
    id?: SortOrder
    day?: SortOrder
    block?: SortOrder
    staffId?: SortOrder
    versionId?: SortOrder
    location?: SortOrder
    maxSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupSessionSumOrderByAggregateInput = {
    id?: SortOrder
    staffId?: SortOrder
    versionId?: SortOrder
    maxSize?: SortOrder
  }

  export type GroupSessionScalarRelationFilter = {
    is?: GroupSessionWhereInput
    isNot?: GroupSessionWhereInput
  }

  export type GroupSessionClientGroupSessionIdClientIdCompoundUniqueInput = {
    groupSessionId: number
    clientId: number
  }

  export type GroupSessionClientCountOrderByAggregateInput = {
    id?: SortOrder
    groupSessionId?: SortOrder
    clientId?: SortOrder
  }

  export type GroupSessionClientAvgOrderByAggregateInput = {
    id?: SortOrder
    groupSessionId?: SortOrder
    clientId?: SortOrder
  }

  export type GroupSessionClientMaxOrderByAggregateInput = {
    id?: SortOrder
    groupSessionId?: SortOrder
    clientId?: SortOrder
  }

  export type GroupSessionClientMinOrderByAggregateInput = {
    id?: SortOrder
    groupSessionId?: SortOrder
    clientId?: SortOrder
  }

  export type GroupSessionClientSumOrderByAggregateInput = {
    id?: SortOrder
    groupSessionId?: SortOrder
    clientId?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StaffNullableScalarRelationFilter = {
    is?: StaffWhereInput | null
    isNot?: StaffWhereInput | null
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type ChangeLogCountOrderByAggregateInput = {
    id?: SortOrder
    versionId?: SortOrder
    changeType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    day?: SortOrder
    block?: SortOrder
    staffId?: SortOrder
    clientId?: SortOrder
    previousValue?: SortOrder
    newValue?: SortOrder
    reviewed?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    committedToMain?: SortOrder
    committedAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    notes?: SortOrder
  }

  export type ChangeLogAvgOrderByAggregateInput = {
    id?: SortOrder
    versionId?: SortOrder
    entityId?: SortOrder
    staffId?: SortOrder
    clientId?: SortOrder
  }

  export type ChangeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    versionId?: SortOrder
    changeType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    day?: SortOrder
    block?: SortOrder
    staffId?: SortOrder
    clientId?: SortOrder
    reviewed?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    committedToMain?: SortOrder
    committedAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    notes?: SortOrder
  }

  export type ChangeLogMinOrderByAggregateInput = {
    id?: SortOrder
    versionId?: SortOrder
    changeType?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    day?: SortOrder
    block?: SortOrder
    staffId?: SortOrder
    clientId?: SortOrder
    reviewed?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    committedToMain?: SortOrder
    committedAt?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    notes?: SortOrder
  }

  export type ChangeLogSumOrderByAggregateInput = {
    id?: SortOrder
    versionId?: SortOrder
    entityId?: SortOrder
    staffId?: SortOrder
    clientId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DailyOverrideCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    day?: SortOrder
    block?: SortOrder
    originalStaffId?: SortOrder
    originalClientId?: SortOrder
    newStaffId?: SortOrder
    newClientId?: SortOrder
    reason?: SortOrder
    hours?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyOverrideAvgOrderByAggregateInput = {
    id?: SortOrder
    originalStaffId?: SortOrder
    originalClientId?: SortOrder
    newStaffId?: SortOrder
    newClientId?: SortOrder
    hours?: SortOrder
  }

  export type DailyOverrideMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    day?: SortOrder
    block?: SortOrder
    originalStaffId?: SortOrder
    originalClientId?: SortOrder
    newStaffId?: SortOrder
    newClientId?: SortOrder
    reason?: SortOrder
    hours?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyOverrideMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    type?: SortOrder
    day?: SortOrder
    block?: SortOrder
    originalStaffId?: SortOrder
    originalClientId?: SortOrder
    newStaffId?: SortOrder
    newClientId?: SortOrder
    reason?: SortOrder
    hours?: SortOrder
    status?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyOverrideSumOrderByAggregateInput = {
    id?: SortOrder
    originalStaffId?: SortOrder
    originalClientId?: SortOrder
    newStaffId?: SortOrder
    newClientId?: SortOrder
    hours?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ClientSupervisorCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    supervisorName?: SortOrder
    effectiveDate?: SortOrder
    endDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientSupervisorAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type ClientSupervisorMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    supervisorName?: SortOrder
    effectiveDate?: SortOrder
    endDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientSupervisorMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    supervisorName?: SortOrder
    effectiveDate?: SortOrder
    endDate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientSupervisorSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
  }

  export type StaffCreatelocationsInput = {
    set: string[]
  }

  export type AssignmentCreateNestedManyWithoutStaffInput = {
    create?: XOR<AssignmentCreateWithoutStaffInput, AssignmentUncheckedCreateWithoutStaffInput> | AssignmentCreateWithoutStaffInput[] | AssignmentUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutStaffInput | AssignmentCreateOrConnectWithoutStaffInput[]
    createMany?: AssignmentCreateManyStaffInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type GroupSessionCreateNestedManyWithoutStaffInput = {
    create?: XOR<GroupSessionCreateWithoutStaffInput, GroupSessionUncheckedCreateWithoutStaffInput> | GroupSessionCreateWithoutStaffInput[] | GroupSessionUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: GroupSessionCreateOrConnectWithoutStaffInput | GroupSessionCreateOrConnectWithoutStaffInput[]
    createMany?: GroupSessionCreateManyStaffInputEnvelope
    connect?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
  }

  export type ChangeLogCreateNestedManyWithoutStaffInput = {
    create?: XOR<ChangeLogCreateWithoutStaffInput, ChangeLogUncheckedCreateWithoutStaffInput> | ChangeLogCreateWithoutStaffInput[] | ChangeLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutStaffInput | ChangeLogCreateOrConnectWithoutStaffInput[]
    createMany?: ChangeLogCreateManyStaffInputEnvelope
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
  }

  export type DailyOverrideCreateNestedManyWithoutOriginalStaffInput = {
    create?: XOR<DailyOverrideCreateWithoutOriginalStaffInput, DailyOverrideUncheckedCreateWithoutOriginalStaffInput> | DailyOverrideCreateWithoutOriginalStaffInput[] | DailyOverrideUncheckedCreateWithoutOriginalStaffInput[]
    connectOrCreate?: DailyOverrideCreateOrConnectWithoutOriginalStaffInput | DailyOverrideCreateOrConnectWithoutOriginalStaffInput[]
    createMany?: DailyOverrideCreateManyOriginalStaffInputEnvelope
    connect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
  }

  export type DailyOverrideCreateNestedManyWithoutNewStaffInput = {
    create?: XOR<DailyOverrideCreateWithoutNewStaffInput, DailyOverrideUncheckedCreateWithoutNewStaffInput> | DailyOverrideCreateWithoutNewStaffInput[] | DailyOverrideUncheckedCreateWithoutNewStaffInput[]
    connectOrCreate?: DailyOverrideCreateOrConnectWithoutNewStaffInput | DailyOverrideCreateOrConnectWithoutNewStaffInput[]
    createMany?: DailyOverrideCreateManyNewStaffInputEnvelope
    connect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<AssignmentCreateWithoutStaffInput, AssignmentUncheckedCreateWithoutStaffInput> | AssignmentCreateWithoutStaffInput[] | AssignmentUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutStaffInput | AssignmentCreateOrConnectWithoutStaffInput[]
    createMany?: AssignmentCreateManyStaffInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type GroupSessionUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<GroupSessionCreateWithoutStaffInput, GroupSessionUncheckedCreateWithoutStaffInput> | GroupSessionCreateWithoutStaffInput[] | GroupSessionUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: GroupSessionCreateOrConnectWithoutStaffInput | GroupSessionCreateOrConnectWithoutStaffInput[]
    createMany?: GroupSessionCreateManyStaffInputEnvelope
    connect?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
  }

  export type ChangeLogUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<ChangeLogCreateWithoutStaffInput, ChangeLogUncheckedCreateWithoutStaffInput> | ChangeLogCreateWithoutStaffInput[] | ChangeLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutStaffInput | ChangeLogCreateOrConnectWithoutStaffInput[]
    createMany?: ChangeLogCreateManyStaffInputEnvelope
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
  }

  export type DailyOverrideUncheckedCreateNestedManyWithoutOriginalStaffInput = {
    create?: XOR<DailyOverrideCreateWithoutOriginalStaffInput, DailyOverrideUncheckedCreateWithoutOriginalStaffInput> | DailyOverrideCreateWithoutOriginalStaffInput[] | DailyOverrideUncheckedCreateWithoutOriginalStaffInput[]
    connectOrCreate?: DailyOverrideCreateOrConnectWithoutOriginalStaffInput | DailyOverrideCreateOrConnectWithoutOriginalStaffInput[]
    createMany?: DailyOverrideCreateManyOriginalStaffInputEnvelope
    connect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
  }

  export type DailyOverrideUncheckedCreateNestedManyWithoutNewStaffInput = {
    create?: XOR<DailyOverrideCreateWithoutNewStaffInput, DailyOverrideUncheckedCreateWithoutNewStaffInput> | DailyOverrideCreateWithoutNewStaffInput[] | DailyOverrideUncheckedCreateWithoutNewStaffInput[]
    connectOrCreate?: DailyOverrideCreateOrConnectWithoutNewStaffInput | DailyOverrideCreateOrConnectWithoutNewStaffInput[]
    createMany?: DailyOverrideCreateManyNewStaffInputEnvelope
    connect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type StaffUpdatelocationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AssignmentUpdateManyWithoutStaffNestedInput = {
    create?: XOR<AssignmentCreateWithoutStaffInput, AssignmentUncheckedCreateWithoutStaffInput> | AssignmentCreateWithoutStaffInput[] | AssignmentUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutStaffInput | AssignmentCreateOrConnectWithoutStaffInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutStaffInput | AssignmentUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: AssignmentCreateManyStaffInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutStaffInput | AssignmentUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutStaffInput | AssignmentUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type GroupSessionUpdateManyWithoutStaffNestedInput = {
    create?: XOR<GroupSessionCreateWithoutStaffInput, GroupSessionUncheckedCreateWithoutStaffInput> | GroupSessionCreateWithoutStaffInput[] | GroupSessionUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: GroupSessionCreateOrConnectWithoutStaffInput | GroupSessionCreateOrConnectWithoutStaffInput[]
    upsert?: GroupSessionUpsertWithWhereUniqueWithoutStaffInput | GroupSessionUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: GroupSessionCreateManyStaffInputEnvelope
    set?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
    disconnect?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
    delete?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
    connect?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
    update?: GroupSessionUpdateWithWhereUniqueWithoutStaffInput | GroupSessionUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: GroupSessionUpdateManyWithWhereWithoutStaffInput | GroupSessionUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: GroupSessionScalarWhereInput | GroupSessionScalarWhereInput[]
  }

  export type ChangeLogUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ChangeLogCreateWithoutStaffInput, ChangeLogUncheckedCreateWithoutStaffInput> | ChangeLogCreateWithoutStaffInput[] | ChangeLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutStaffInput | ChangeLogCreateOrConnectWithoutStaffInput[]
    upsert?: ChangeLogUpsertWithWhereUniqueWithoutStaffInput | ChangeLogUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ChangeLogCreateManyStaffInputEnvelope
    set?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    disconnect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    delete?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    update?: ChangeLogUpdateWithWhereUniqueWithoutStaffInput | ChangeLogUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ChangeLogUpdateManyWithWhereWithoutStaffInput | ChangeLogUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
  }

  export type DailyOverrideUpdateManyWithoutOriginalStaffNestedInput = {
    create?: XOR<DailyOverrideCreateWithoutOriginalStaffInput, DailyOverrideUncheckedCreateWithoutOriginalStaffInput> | DailyOverrideCreateWithoutOriginalStaffInput[] | DailyOverrideUncheckedCreateWithoutOriginalStaffInput[]
    connectOrCreate?: DailyOverrideCreateOrConnectWithoutOriginalStaffInput | DailyOverrideCreateOrConnectWithoutOriginalStaffInput[]
    upsert?: DailyOverrideUpsertWithWhereUniqueWithoutOriginalStaffInput | DailyOverrideUpsertWithWhereUniqueWithoutOriginalStaffInput[]
    createMany?: DailyOverrideCreateManyOriginalStaffInputEnvelope
    set?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    disconnect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    delete?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    connect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    update?: DailyOverrideUpdateWithWhereUniqueWithoutOriginalStaffInput | DailyOverrideUpdateWithWhereUniqueWithoutOriginalStaffInput[]
    updateMany?: DailyOverrideUpdateManyWithWhereWithoutOriginalStaffInput | DailyOverrideUpdateManyWithWhereWithoutOriginalStaffInput[]
    deleteMany?: DailyOverrideScalarWhereInput | DailyOverrideScalarWhereInput[]
  }

  export type DailyOverrideUpdateManyWithoutNewStaffNestedInput = {
    create?: XOR<DailyOverrideCreateWithoutNewStaffInput, DailyOverrideUncheckedCreateWithoutNewStaffInput> | DailyOverrideCreateWithoutNewStaffInput[] | DailyOverrideUncheckedCreateWithoutNewStaffInput[]
    connectOrCreate?: DailyOverrideCreateOrConnectWithoutNewStaffInput | DailyOverrideCreateOrConnectWithoutNewStaffInput[]
    upsert?: DailyOverrideUpsertWithWhereUniqueWithoutNewStaffInput | DailyOverrideUpsertWithWhereUniqueWithoutNewStaffInput[]
    createMany?: DailyOverrideCreateManyNewStaffInputEnvelope
    set?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    disconnect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    delete?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    connect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    update?: DailyOverrideUpdateWithWhereUniqueWithoutNewStaffInput | DailyOverrideUpdateWithWhereUniqueWithoutNewStaffInput[]
    updateMany?: DailyOverrideUpdateManyWithWhereWithoutNewStaffInput | DailyOverrideUpdateManyWithWhereWithoutNewStaffInput[]
    deleteMany?: DailyOverrideScalarWhereInput | DailyOverrideScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AssignmentUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<AssignmentCreateWithoutStaffInput, AssignmentUncheckedCreateWithoutStaffInput> | AssignmentCreateWithoutStaffInput[] | AssignmentUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutStaffInput | AssignmentCreateOrConnectWithoutStaffInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutStaffInput | AssignmentUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: AssignmentCreateManyStaffInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutStaffInput | AssignmentUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutStaffInput | AssignmentUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type GroupSessionUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<GroupSessionCreateWithoutStaffInput, GroupSessionUncheckedCreateWithoutStaffInput> | GroupSessionCreateWithoutStaffInput[] | GroupSessionUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: GroupSessionCreateOrConnectWithoutStaffInput | GroupSessionCreateOrConnectWithoutStaffInput[]
    upsert?: GroupSessionUpsertWithWhereUniqueWithoutStaffInput | GroupSessionUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: GroupSessionCreateManyStaffInputEnvelope
    set?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
    disconnect?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
    delete?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
    connect?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
    update?: GroupSessionUpdateWithWhereUniqueWithoutStaffInput | GroupSessionUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: GroupSessionUpdateManyWithWhereWithoutStaffInput | GroupSessionUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: GroupSessionScalarWhereInput | GroupSessionScalarWhereInput[]
  }

  export type ChangeLogUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ChangeLogCreateWithoutStaffInput, ChangeLogUncheckedCreateWithoutStaffInput> | ChangeLogCreateWithoutStaffInput[] | ChangeLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutStaffInput | ChangeLogCreateOrConnectWithoutStaffInput[]
    upsert?: ChangeLogUpsertWithWhereUniqueWithoutStaffInput | ChangeLogUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ChangeLogCreateManyStaffInputEnvelope
    set?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    disconnect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    delete?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    update?: ChangeLogUpdateWithWhereUniqueWithoutStaffInput | ChangeLogUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ChangeLogUpdateManyWithWhereWithoutStaffInput | ChangeLogUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
  }

  export type DailyOverrideUncheckedUpdateManyWithoutOriginalStaffNestedInput = {
    create?: XOR<DailyOverrideCreateWithoutOriginalStaffInput, DailyOverrideUncheckedCreateWithoutOriginalStaffInput> | DailyOverrideCreateWithoutOriginalStaffInput[] | DailyOverrideUncheckedCreateWithoutOriginalStaffInput[]
    connectOrCreate?: DailyOverrideCreateOrConnectWithoutOriginalStaffInput | DailyOverrideCreateOrConnectWithoutOriginalStaffInput[]
    upsert?: DailyOverrideUpsertWithWhereUniqueWithoutOriginalStaffInput | DailyOverrideUpsertWithWhereUniqueWithoutOriginalStaffInput[]
    createMany?: DailyOverrideCreateManyOriginalStaffInputEnvelope
    set?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    disconnect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    delete?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    connect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    update?: DailyOverrideUpdateWithWhereUniqueWithoutOriginalStaffInput | DailyOverrideUpdateWithWhereUniqueWithoutOriginalStaffInput[]
    updateMany?: DailyOverrideUpdateManyWithWhereWithoutOriginalStaffInput | DailyOverrideUpdateManyWithWhereWithoutOriginalStaffInput[]
    deleteMany?: DailyOverrideScalarWhereInput | DailyOverrideScalarWhereInput[]
  }

  export type DailyOverrideUncheckedUpdateManyWithoutNewStaffNestedInput = {
    create?: XOR<DailyOverrideCreateWithoutNewStaffInput, DailyOverrideUncheckedCreateWithoutNewStaffInput> | DailyOverrideCreateWithoutNewStaffInput[] | DailyOverrideUncheckedCreateWithoutNewStaffInput[]
    connectOrCreate?: DailyOverrideCreateOrConnectWithoutNewStaffInput | DailyOverrideCreateOrConnectWithoutNewStaffInput[]
    upsert?: DailyOverrideUpsertWithWhereUniqueWithoutNewStaffInput | DailyOverrideUpsertWithWhereUniqueWithoutNewStaffInput[]
    createMany?: DailyOverrideCreateManyNewStaffInputEnvelope
    set?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    disconnect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    delete?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    connect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    update?: DailyOverrideUpdateWithWhereUniqueWithoutNewStaffInput | DailyOverrideUpdateWithWhereUniqueWithoutNewStaffInput[]
    updateMany?: DailyOverrideUpdateManyWithWhereWithoutNewStaffInput | DailyOverrideUpdateManyWithWhereWithoutNewStaffInput[]
    deleteMany?: DailyOverrideScalarWhereInput | DailyOverrideScalarWhereInput[]
  }

  export type ClientCreatelocationsInput = {
    set: string[]
  }

  export type AssignmentCreateNestedManyWithoutClientInput = {
    create?: XOR<AssignmentCreateWithoutClientInput, AssignmentUncheckedCreateWithoutClientInput> | AssignmentCreateWithoutClientInput[] | AssignmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClientInput | AssignmentCreateOrConnectWithoutClientInput[]
    createMany?: AssignmentCreateManyClientInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type GroupSessionClientCreateNestedManyWithoutClientInput = {
    create?: XOR<GroupSessionClientCreateWithoutClientInput, GroupSessionClientUncheckedCreateWithoutClientInput> | GroupSessionClientCreateWithoutClientInput[] | GroupSessionClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: GroupSessionClientCreateOrConnectWithoutClientInput | GroupSessionClientCreateOrConnectWithoutClientInput[]
    createMany?: GroupSessionClientCreateManyClientInputEnvelope
    connect?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
  }

  export type ChangeLogCreateNestedManyWithoutClientInput = {
    create?: XOR<ChangeLogCreateWithoutClientInput, ChangeLogUncheckedCreateWithoutClientInput> | ChangeLogCreateWithoutClientInput[] | ChangeLogUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutClientInput | ChangeLogCreateOrConnectWithoutClientInput[]
    createMany?: ChangeLogCreateManyClientInputEnvelope
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
  }

  export type DailyOverrideCreateNestedManyWithoutOriginalClientInput = {
    create?: XOR<DailyOverrideCreateWithoutOriginalClientInput, DailyOverrideUncheckedCreateWithoutOriginalClientInput> | DailyOverrideCreateWithoutOriginalClientInput[] | DailyOverrideUncheckedCreateWithoutOriginalClientInput[]
    connectOrCreate?: DailyOverrideCreateOrConnectWithoutOriginalClientInput | DailyOverrideCreateOrConnectWithoutOriginalClientInput[]
    createMany?: DailyOverrideCreateManyOriginalClientInputEnvelope
    connect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
  }

  export type DailyOverrideCreateNestedManyWithoutNewClientInput = {
    create?: XOR<DailyOverrideCreateWithoutNewClientInput, DailyOverrideUncheckedCreateWithoutNewClientInput> | DailyOverrideCreateWithoutNewClientInput[] | DailyOverrideUncheckedCreateWithoutNewClientInput[]
    connectOrCreate?: DailyOverrideCreateOrConnectWithoutNewClientInput | DailyOverrideCreateOrConnectWithoutNewClientInput[]
    createMany?: DailyOverrideCreateManyNewClientInputEnvelope
    connect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
  }

  export type ClientSupervisorCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientSupervisorCreateWithoutClientInput, ClientSupervisorUncheckedCreateWithoutClientInput> | ClientSupervisorCreateWithoutClientInput[] | ClientSupervisorUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientSupervisorCreateOrConnectWithoutClientInput | ClientSupervisorCreateOrConnectWithoutClientInput[]
    createMany?: ClientSupervisorCreateManyClientInputEnvelope
    connect?: ClientSupervisorWhereUniqueInput | ClientSupervisorWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<AssignmentCreateWithoutClientInput, AssignmentUncheckedCreateWithoutClientInput> | AssignmentCreateWithoutClientInput[] | AssignmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClientInput | AssignmentCreateOrConnectWithoutClientInput[]
    createMany?: AssignmentCreateManyClientInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type GroupSessionClientUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<GroupSessionClientCreateWithoutClientInput, GroupSessionClientUncheckedCreateWithoutClientInput> | GroupSessionClientCreateWithoutClientInput[] | GroupSessionClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: GroupSessionClientCreateOrConnectWithoutClientInput | GroupSessionClientCreateOrConnectWithoutClientInput[]
    createMany?: GroupSessionClientCreateManyClientInputEnvelope
    connect?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
  }

  export type ChangeLogUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ChangeLogCreateWithoutClientInput, ChangeLogUncheckedCreateWithoutClientInput> | ChangeLogCreateWithoutClientInput[] | ChangeLogUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutClientInput | ChangeLogCreateOrConnectWithoutClientInput[]
    createMany?: ChangeLogCreateManyClientInputEnvelope
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
  }

  export type DailyOverrideUncheckedCreateNestedManyWithoutOriginalClientInput = {
    create?: XOR<DailyOverrideCreateWithoutOriginalClientInput, DailyOverrideUncheckedCreateWithoutOriginalClientInput> | DailyOverrideCreateWithoutOriginalClientInput[] | DailyOverrideUncheckedCreateWithoutOriginalClientInput[]
    connectOrCreate?: DailyOverrideCreateOrConnectWithoutOriginalClientInput | DailyOverrideCreateOrConnectWithoutOriginalClientInput[]
    createMany?: DailyOverrideCreateManyOriginalClientInputEnvelope
    connect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
  }

  export type DailyOverrideUncheckedCreateNestedManyWithoutNewClientInput = {
    create?: XOR<DailyOverrideCreateWithoutNewClientInput, DailyOverrideUncheckedCreateWithoutNewClientInput> | DailyOverrideCreateWithoutNewClientInput[] | DailyOverrideUncheckedCreateWithoutNewClientInput[]
    connectOrCreate?: DailyOverrideCreateOrConnectWithoutNewClientInput | DailyOverrideCreateOrConnectWithoutNewClientInput[]
    createMany?: DailyOverrideCreateManyNewClientInputEnvelope
    connect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
  }

  export type ClientSupervisorUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientSupervisorCreateWithoutClientInput, ClientSupervisorUncheckedCreateWithoutClientInput> | ClientSupervisorCreateWithoutClientInput[] | ClientSupervisorUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientSupervisorCreateOrConnectWithoutClientInput | ClientSupervisorCreateOrConnectWithoutClientInput[]
    createMany?: ClientSupervisorCreateManyClientInputEnvelope
    connect?: ClientSupervisorWhereUniqueInput | ClientSupervisorWhereUniqueInput[]
  }

  export type ClientUpdatelocationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AssignmentUpdateManyWithoutClientNestedInput = {
    create?: XOR<AssignmentCreateWithoutClientInput, AssignmentUncheckedCreateWithoutClientInput> | AssignmentCreateWithoutClientInput[] | AssignmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClientInput | AssignmentCreateOrConnectWithoutClientInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutClientInput | AssignmentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AssignmentCreateManyClientInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutClientInput | AssignmentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutClientInput | AssignmentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type GroupSessionClientUpdateManyWithoutClientNestedInput = {
    create?: XOR<GroupSessionClientCreateWithoutClientInput, GroupSessionClientUncheckedCreateWithoutClientInput> | GroupSessionClientCreateWithoutClientInput[] | GroupSessionClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: GroupSessionClientCreateOrConnectWithoutClientInput | GroupSessionClientCreateOrConnectWithoutClientInput[]
    upsert?: GroupSessionClientUpsertWithWhereUniqueWithoutClientInput | GroupSessionClientUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: GroupSessionClientCreateManyClientInputEnvelope
    set?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
    disconnect?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
    delete?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
    connect?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
    update?: GroupSessionClientUpdateWithWhereUniqueWithoutClientInput | GroupSessionClientUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: GroupSessionClientUpdateManyWithWhereWithoutClientInput | GroupSessionClientUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: GroupSessionClientScalarWhereInput | GroupSessionClientScalarWhereInput[]
  }

  export type ChangeLogUpdateManyWithoutClientNestedInput = {
    create?: XOR<ChangeLogCreateWithoutClientInput, ChangeLogUncheckedCreateWithoutClientInput> | ChangeLogCreateWithoutClientInput[] | ChangeLogUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutClientInput | ChangeLogCreateOrConnectWithoutClientInput[]
    upsert?: ChangeLogUpsertWithWhereUniqueWithoutClientInput | ChangeLogUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ChangeLogCreateManyClientInputEnvelope
    set?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    disconnect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    delete?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    update?: ChangeLogUpdateWithWhereUniqueWithoutClientInput | ChangeLogUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ChangeLogUpdateManyWithWhereWithoutClientInput | ChangeLogUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
  }

  export type DailyOverrideUpdateManyWithoutOriginalClientNestedInput = {
    create?: XOR<DailyOverrideCreateWithoutOriginalClientInput, DailyOverrideUncheckedCreateWithoutOriginalClientInput> | DailyOverrideCreateWithoutOriginalClientInput[] | DailyOverrideUncheckedCreateWithoutOriginalClientInput[]
    connectOrCreate?: DailyOverrideCreateOrConnectWithoutOriginalClientInput | DailyOverrideCreateOrConnectWithoutOriginalClientInput[]
    upsert?: DailyOverrideUpsertWithWhereUniqueWithoutOriginalClientInput | DailyOverrideUpsertWithWhereUniqueWithoutOriginalClientInput[]
    createMany?: DailyOverrideCreateManyOriginalClientInputEnvelope
    set?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    disconnect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    delete?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    connect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    update?: DailyOverrideUpdateWithWhereUniqueWithoutOriginalClientInput | DailyOverrideUpdateWithWhereUniqueWithoutOriginalClientInput[]
    updateMany?: DailyOverrideUpdateManyWithWhereWithoutOriginalClientInput | DailyOverrideUpdateManyWithWhereWithoutOriginalClientInput[]
    deleteMany?: DailyOverrideScalarWhereInput | DailyOverrideScalarWhereInput[]
  }

  export type DailyOverrideUpdateManyWithoutNewClientNestedInput = {
    create?: XOR<DailyOverrideCreateWithoutNewClientInput, DailyOverrideUncheckedCreateWithoutNewClientInput> | DailyOverrideCreateWithoutNewClientInput[] | DailyOverrideUncheckedCreateWithoutNewClientInput[]
    connectOrCreate?: DailyOverrideCreateOrConnectWithoutNewClientInput | DailyOverrideCreateOrConnectWithoutNewClientInput[]
    upsert?: DailyOverrideUpsertWithWhereUniqueWithoutNewClientInput | DailyOverrideUpsertWithWhereUniqueWithoutNewClientInput[]
    createMany?: DailyOverrideCreateManyNewClientInputEnvelope
    set?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    disconnect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    delete?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    connect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    update?: DailyOverrideUpdateWithWhereUniqueWithoutNewClientInput | DailyOverrideUpdateWithWhereUniqueWithoutNewClientInput[]
    updateMany?: DailyOverrideUpdateManyWithWhereWithoutNewClientInput | DailyOverrideUpdateManyWithWhereWithoutNewClientInput[]
    deleteMany?: DailyOverrideScalarWhereInput | DailyOverrideScalarWhereInput[]
  }

  export type ClientSupervisorUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientSupervisorCreateWithoutClientInput, ClientSupervisorUncheckedCreateWithoutClientInput> | ClientSupervisorCreateWithoutClientInput[] | ClientSupervisorUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientSupervisorCreateOrConnectWithoutClientInput | ClientSupervisorCreateOrConnectWithoutClientInput[]
    upsert?: ClientSupervisorUpsertWithWhereUniqueWithoutClientInput | ClientSupervisorUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientSupervisorCreateManyClientInputEnvelope
    set?: ClientSupervisorWhereUniqueInput | ClientSupervisorWhereUniqueInput[]
    disconnect?: ClientSupervisorWhereUniqueInput | ClientSupervisorWhereUniqueInput[]
    delete?: ClientSupervisorWhereUniqueInput | ClientSupervisorWhereUniqueInput[]
    connect?: ClientSupervisorWhereUniqueInput | ClientSupervisorWhereUniqueInput[]
    update?: ClientSupervisorUpdateWithWhereUniqueWithoutClientInput | ClientSupervisorUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientSupervisorUpdateManyWithWhereWithoutClientInput | ClientSupervisorUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientSupervisorScalarWhereInput | ClientSupervisorScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<AssignmentCreateWithoutClientInput, AssignmentUncheckedCreateWithoutClientInput> | AssignmentCreateWithoutClientInput[] | AssignmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutClientInput | AssignmentCreateOrConnectWithoutClientInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutClientInput | AssignmentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AssignmentCreateManyClientInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutClientInput | AssignmentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutClientInput | AssignmentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type GroupSessionClientUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<GroupSessionClientCreateWithoutClientInput, GroupSessionClientUncheckedCreateWithoutClientInput> | GroupSessionClientCreateWithoutClientInput[] | GroupSessionClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: GroupSessionClientCreateOrConnectWithoutClientInput | GroupSessionClientCreateOrConnectWithoutClientInput[]
    upsert?: GroupSessionClientUpsertWithWhereUniqueWithoutClientInput | GroupSessionClientUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: GroupSessionClientCreateManyClientInputEnvelope
    set?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
    disconnect?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
    delete?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
    connect?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
    update?: GroupSessionClientUpdateWithWhereUniqueWithoutClientInput | GroupSessionClientUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: GroupSessionClientUpdateManyWithWhereWithoutClientInput | GroupSessionClientUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: GroupSessionClientScalarWhereInput | GroupSessionClientScalarWhereInput[]
  }

  export type ChangeLogUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ChangeLogCreateWithoutClientInput, ChangeLogUncheckedCreateWithoutClientInput> | ChangeLogCreateWithoutClientInput[] | ChangeLogUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutClientInput | ChangeLogCreateOrConnectWithoutClientInput[]
    upsert?: ChangeLogUpsertWithWhereUniqueWithoutClientInput | ChangeLogUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ChangeLogCreateManyClientInputEnvelope
    set?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    disconnect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    delete?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    update?: ChangeLogUpdateWithWhereUniqueWithoutClientInput | ChangeLogUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ChangeLogUpdateManyWithWhereWithoutClientInput | ChangeLogUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
  }

  export type DailyOverrideUncheckedUpdateManyWithoutOriginalClientNestedInput = {
    create?: XOR<DailyOverrideCreateWithoutOriginalClientInput, DailyOverrideUncheckedCreateWithoutOriginalClientInput> | DailyOverrideCreateWithoutOriginalClientInput[] | DailyOverrideUncheckedCreateWithoutOriginalClientInput[]
    connectOrCreate?: DailyOverrideCreateOrConnectWithoutOriginalClientInput | DailyOverrideCreateOrConnectWithoutOriginalClientInput[]
    upsert?: DailyOverrideUpsertWithWhereUniqueWithoutOriginalClientInput | DailyOverrideUpsertWithWhereUniqueWithoutOriginalClientInput[]
    createMany?: DailyOverrideCreateManyOriginalClientInputEnvelope
    set?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    disconnect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    delete?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    connect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    update?: DailyOverrideUpdateWithWhereUniqueWithoutOriginalClientInput | DailyOverrideUpdateWithWhereUniqueWithoutOriginalClientInput[]
    updateMany?: DailyOverrideUpdateManyWithWhereWithoutOriginalClientInput | DailyOverrideUpdateManyWithWhereWithoutOriginalClientInput[]
    deleteMany?: DailyOverrideScalarWhereInput | DailyOverrideScalarWhereInput[]
  }

  export type DailyOverrideUncheckedUpdateManyWithoutNewClientNestedInput = {
    create?: XOR<DailyOverrideCreateWithoutNewClientInput, DailyOverrideUncheckedCreateWithoutNewClientInput> | DailyOverrideCreateWithoutNewClientInput[] | DailyOverrideUncheckedCreateWithoutNewClientInput[]
    connectOrCreate?: DailyOverrideCreateOrConnectWithoutNewClientInput | DailyOverrideCreateOrConnectWithoutNewClientInput[]
    upsert?: DailyOverrideUpsertWithWhereUniqueWithoutNewClientInput | DailyOverrideUpsertWithWhereUniqueWithoutNewClientInput[]
    createMany?: DailyOverrideCreateManyNewClientInputEnvelope
    set?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    disconnect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    delete?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    connect?: DailyOverrideWhereUniqueInput | DailyOverrideWhereUniqueInput[]
    update?: DailyOverrideUpdateWithWhereUniqueWithoutNewClientInput | DailyOverrideUpdateWithWhereUniqueWithoutNewClientInput[]
    updateMany?: DailyOverrideUpdateManyWithWhereWithoutNewClientInput | DailyOverrideUpdateManyWithWhereWithoutNewClientInput[]
    deleteMany?: DailyOverrideScalarWhereInput | DailyOverrideScalarWhereInput[]
  }

  export type ClientSupervisorUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientSupervisorCreateWithoutClientInput, ClientSupervisorUncheckedCreateWithoutClientInput> | ClientSupervisorCreateWithoutClientInput[] | ClientSupervisorUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientSupervisorCreateOrConnectWithoutClientInput | ClientSupervisorCreateOrConnectWithoutClientInput[]
    upsert?: ClientSupervisorUpsertWithWhereUniqueWithoutClientInput | ClientSupervisorUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientSupervisorCreateManyClientInputEnvelope
    set?: ClientSupervisorWhereUniqueInput | ClientSupervisorWhereUniqueInput[]
    disconnect?: ClientSupervisorWhereUniqueInput | ClientSupervisorWhereUniqueInput[]
    delete?: ClientSupervisorWhereUniqueInput | ClientSupervisorWhereUniqueInput[]
    connect?: ClientSupervisorWhereUniqueInput | ClientSupervisorWhereUniqueInput[]
    update?: ClientSupervisorUpdateWithWhereUniqueWithoutClientInput | ClientSupervisorUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientSupervisorUpdateManyWithWhereWithoutClientInput | ClientSupervisorUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientSupervisorScalarWhereInput | ClientSupervisorScalarWhereInput[]
  }

  export type AssignmentCreateNestedManyWithoutVersionInput = {
    create?: XOR<AssignmentCreateWithoutVersionInput, AssignmentUncheckedCreateWithoutVersionInput> | AssignmentCreateWithoutVersionInput[] | AssignmentUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutVersionInput | AssignmentCreateOrConnectWithoutVersionInput[]
    createMany?: AssignmentCreateManyVersionInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type GroupSessionCreateNestedManyWithoutVersionInput = {
    create?: XOR<GroupSessionCreateWithoutVersionInput, GroupSessionUncheckedCreateWithoutVersionInput> | GroupSessionCreateWithoutVersionInput[] | GroupSessionUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: GroupSessionCreateOrConnectWithoutVersionInput | GroupSessionCreateOrConnectWithoutVersionInput[]
    createMany?: GroupSessionCreateManyVersionInputEnvelope
    connect?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
  }

  export type ChangeLogCreateNestedManyWithoutVersionInput = {
    create?: XOR<ChangeLogCreateWithoutVersionInput, ChangeLogUncheckedCreateWithoutVersionInput> | ChangeLogCreateWithoutVersionInput[] | ChangeLogUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutVersionInput | ChangeLogCreateOrConnectWithoutVersionInput[]
    createMany?: ChangeLogCreateManyVersionInputEnvelope
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutVersionInput = {
    create?: XOR<AssignmentCreateWithoutVersionInput, AssignmentUncheckedCreateWithoutVersionInput> | AssignmentCreateWithoutVersionInput[] | AssignmentUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutVersionInput | AssignmentCreateOrConnectWithoutVersionInput[]
    createMany?: AssignmentCreateManyVersionInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type GroupSessionUncheckedCreateNestedManyWithoutVersionInput = {
    create?: XOR<GroupSessionCreateWithoutVersionInput, GroupSessionUncheckedCreateWithoutVersionInput> | GroupSessionCreateWithoutVersionInput[] | GroupSessionUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: GroupSessionCreateOrConnectWithoutVersionInput | GroupSessionCreateOrConnectWithoutVersionInput[]
    createMany?: GroupSessionCreateManyVersionInputEnvelope
    connect?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
  }

  export type ChangeLogUncheckedCreateNestedManyWithoutVersionInput = {
    create?: XOR<ChangeLogCreateWithoutVersionInput, ChangeLogUncheckedCreateWithoutVersionInput> | ChangeLogCreateWithoutVersionInput[] | ChangeLogUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutVersionInput | ChangeLogCreateOrConnectWithoutVersionInput[]
    createMany?: ChangeLogCreateManyVersionInputEnvelope
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AssignmentUpdateManyWithoutVersionNestedInput = {
    create?: XOR<AssignmentCreateWithoutVersionInput, AssignmentUncheckedCreateWithoutVersionInput> | AssignmentCreateWithoutVersionInput[] | AssignmentUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutVersionInput | AssignmentCreateOrConnectWithoutVersionInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutVersionInput | AssignmentUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: AssignmentCreateManyVersionInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutVersionInput | AssignmentUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutVersionInput | AssignmentUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type GroupSessionUpdateManyWithoutVersionNestedInput = {
    create?: XOR<GroupSessionCreateWithoutVersionInput, GroupSessionUncheckedCreateWithoutVersionInput> | GroupSessionCreateWithoutVersionInput[] | GroupSessionUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: GroupSessionCreateOrConnectWithoutVersionInput | GroupSessionCreateOrConnectWithoutVersionInput[]
    upsert?: GroupSessionUpsertWithWhereUniqueWithoutVersionInput | GroupSessionUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: GroupSessionCreateManyVersionInputEnvelope
    set?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
    disconnect?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
    delete?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
    connect?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
    update?: GroupSessionUpdateWithWhereUniqueWithoutVersionInput | GroupSessionUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: GroupSessionUpdateManyWithWhereWithoutVersionInput | GroupSessionUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: GroupSessionScalarWhereInput | GroupSessionScalarWhereInput[]
  }

  export type ChangeLogUpdateManyWithoutVersionNestedInput = {
    create?: XOR<ChangeLogCreateWithoutVersionInput, ChangeLogUncheckedCreateWithoutVersionInput> | ChangeLogCreateWithoutVersionInput[] | ChangeLogUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutVersionInput | ChangeLogCreateOrConnectWithoutVersionInput[]
    upsert?: ChangeLogUpsertWithWhereUniqueWithoutVersionInput | ChangeLogUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: ChangeLogCreateManyVersionInputEnvelope
    set?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    disconnect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    delete?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    update?: ChangeLogUpdateWithWhereUniqueWithoutVersionInput | ChangeLogUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: ChangeLogUpdateManyWithWhereWithoutVersionInput | ChangeLogUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutVersionNestedInput = {
    create?: XOR<AssignmentCreateWithoutVersionInput, AssignmentUncheckedCreateWithoutVersionInput> | AssignmentCreateWithoutVersionInput[] | AssignmentUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutVersionInput | AssignmentCreateOrConnectWithoutVersionInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutVersionInput | AssignmentUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: AssignmentCreateManyVersionInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutVersionInput | AssignmentUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutVersionInput | AssignmentUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type GroupSessionUncheckedUpdateManyWithoutVersionNestedInput = {
    create?: XOR<GroupSessionCreateWithoutVersionInput, GroupSessionUncheckedCreateWithoutVersionInput> | GroupSessionCreateWithoutVersionInput[] | GroupSessionUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: GroupSessionCreateOrConnectWithoutVersionInput | GroupSessionCreateOrConnectWithoutVersionInput[]
    upsert?: GroupSessionUpsertWithWhereUniqueWithoutVersionInput | GroupSessionUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: GroupSessionCreateManyVersionInputEnvelope
    set?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
    disconnect?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
    delete?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
    connect?: GroupSessionWhereUniqueInput | GroupSessionWhereUniqueInput[]
    update?: GroupSessionUpdateWithWhereUniqueWithoutVersionInput | GroupSessionUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: GroupSessionUpdateManyWithWhereWithoutVersionInput | GroupSessionUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: GroupSessionScalarWhereInput | GroupSessionScalarWhereInput[]
  }

  export type ChangeLogUncheckedUpdateManyWithoutVersionNestedInput = {
    create?: XOR<ChangeLogCreateWithoutVersionInput, ChangeLogUncheckedCreateWithoutVersionInput> | ChangeLogCreateWithoutVersionInput[] | ChangeLogUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: ChangeLogCreateOrConnectWithoutVersionInput | ChangeLogCreateOrConnectWithoutVersionInput[]
    upsert?: ChangeLogUpsertWithWhereUniqueWithoutVersionInput | ChangeLogUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: ChangeLogCreateManyVersionInputEnvelope
    set?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    disconnect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    delete?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    connect?: ChangeLogWhereUniqueInput | ChangeLogWhereUniqueInput[]
    update?: ChangeLogUpdateWithWhereUniqueWithoutVersionInput | ChangeLogUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: ChangeLogUpdateManyWithWhereWithoutVersionInput | ChangeLogUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
  }

  export type StaffCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<StaffCreateWithoutAssignmentsInput, StaffUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutAssignmentsInput
    connect?: StaffWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<ClientCreateWithoutAssignmentsInput, ClientUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAssignmentsInput
    connect?: ClientWhereUniqueInput
  }

  export type ScheduleVersionCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<ScheduleVersionCreateWithoutAssignmentsInput, ScheduleVersionUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ScheduleVersionCreateOrConnectWithoutAssignmentsInput
    connect?: ScheduleVersionWhereUniqueInput
  }

  export type GroupSessionCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<GroupSessionCreateWithoutAssignmentsInput, GroupSessionUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: GroupSessionCreateOrConnectWithoutAssignmentsInput
    connect?: GroupSessionWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type StaffUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<StaffCreateWithoutAssignmentsInput, StaffUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutAssignmentsInput
    upsert?: StaffUpsertWithoutAssignmentsInput
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutAssignmentsInput, StaffUpdateWithoutAssignmentsInput>, StaffUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ClientUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<ClientCreateWithoutAssignmentsInput, ClientUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAssignmentsInput
    upsert?: ClientUpsertWithoutAssignmentsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutAssignmentsInput, ClientUpdateWithoutAssignmentsInput>, ClientUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ScheduleVersionUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<ScheduleVersionCreateWithoutAssignmentsInput, ScheduleVersionUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ScheduleVersionCreateOrConnectWithoutAssignmentsInput
    upsert?: ScheduleVersionUpsertWithoutAssignmentsInput
    connect?: ScheduleVersionWhereUniqueInput
    update?: XOR<XOR<ScheduleVersionUpdateToOneWithWhereWithoutAssignmentsInput, ScheduleVersionUpdateWithoutAssignmentsInput>, ScheduleVersionUncheckedUpdateWithoutAssignmentsInput>
  }

  export type GroupSessionUpdateOneWithoutAssignmentsNestedInput = {
    create?: XOR<GroupSessionCreateWithoutAssignmentsInput, GroupSessionUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: GroupSessionCreateOrConnectWithoutAssignmentsInput
    upsert?: GroupSessionUpsertWithoutAssignmentsInput
    disconnect?: GroupSessionWhereInput | boolean
    delete?: GroupSessionWhereInput | boolean
    connect?: GroupSessionWhereUniqueInput
    update?: XOR<XOR<GroupSessionUpdateToOneWithWhereWithoutAssignmentsInput, GroupSessionUpdateWithoutAssignmentsInput>, GroupSessionUncheckedUpdateWithoutAssignmentsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StaffCreateNestedOneWithoutGroupSessionsInput = {
    create?: XOR<StaffCreateWithoutGroupSessionsInput, StaffUncheckedCreateWithoutGroupSessionsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutGroupSessionsInput
    connect?: StaffWhereUniqueInput
  }

  export type ScheduleVersionCreateNestedOneWithoutGroupSessionsInput = {
    create?: XOR<ScheduleVersionCreateWithoutGroupSessionsInput, ScheduleVersionUncheckedCreateWithoutGroupSessionsInput>
    connectOrCreate?: ScheduleVersionCreateOrConnectWithoutGroupSessionsInput
    connect?: ScheduleVersionWhereUniqueInput
  }

  export type GroupSessionClientCreateNestedManyWithoutGroupSessionInput = {
    create?: XOR<GroupSessionClientCreateWithoutGroupSessionInput, GroupSessionClientUncheckedCreateWithoutGroupSessionInput> | GroupSessionClientCreateWithoutGroupSessionInput[] | GroupSessionClientUncheckedCreateWithoutGroupSessionInput[]
    connectOrCreate?: GroupSessionClientCreateOrConnectWithoutGroupSessionInput | GroupSessionClientCreateOrConnectWithoutGroupSessionInput[]
    createMany?: GroupSessionClientCreateManyGroupSessionInputEnvelope
    connect?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
  }

  export type AssignmentCreateNestedManyWithoutGroupSessionInput = {
    create?: XOR<AssignmentCreateWithoutGroupSessionInput, AssignmentUncheckedCreateWithoutGroupSessionInput> | AssignmentCreateWithoutGroupSessionInput[] | AssignmentUncheckedCreateWithoutGroupSessionInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutGroupSessionInput | AssignmentCreateOrConnectWithoutGroupSessionInput[]
    createMany?: AssignmentCreateManyGroupSessionInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type GroupSessionClientUncheckedCreateNestedManyWithoutGroupSessionInput = {
    create?: XOR<GroupSessionClientCreateWithoutGroupSessionInput, GroupSessionClientUncheckedCreateWithoutGroupSessionInput> | GroupSessionClientCreateWithoutGroupSessionInput[] | GroupSessionClientUncheckedCreateWithoutGroupSessionInput[]
    connectOrCreate?: GroupSessionClientCreateOrConnectWithoutGroupSessionInput | GroupSessionClientCreateOrConnectWithoutGroupSessionInput[]
    createMany?: GroupSessionClientCreateManyGroupSessionInputEnvelope
    connect?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutGroupSessionInput = {
    create?: XOR<AssignmentCreateWithoutGroupSessionInput, AssignmentUncheckedCreateWithoutGroupSessionInput> | AssignmentCreateWithoutGroupSessionInput[] | AssignmentUncheckedCreateWithoutGroupSessionInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutGroupSessionInput | AssignmentCreateOrConnectWithoutGroupSessionInput[]
    createMany?: AssignmentCreateManyGroupSessionInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type StaffUpdateOneRequiredWithoutGroupSessionsNestedInput = {
    create?: XOR<StaffCreateWithoutGroupSessionsInput, StaffUncheckedCreateWithoutGroupSessionsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutGroupSessionsInput
    upsert?: StaffUpsertWithoutGroupSessionsInput
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutGroupSessionsInput, StaffUpdateWithoutGroupSessionsInput>, StaffUncheckedUpdateWithoutGroupSessionsInput>
  }

  export type ScheduleVersionUpdateOneRequiredWithoutGroupSessionsNestedInput = {
    create?: XOR<ScheduleVersionCreateWithoutGroupSessionsInput, ScheduleVersionUncheckedCreateWithoutGroupSessionsInput>
    connectOrCreate?: ScheduleVersionCreateOrConnectWithoutGroupSessionsInput
    upsert?: ScheduleVersionUpsertWithoutGroupSessionsInput
    connect?: ScheduleVersionWhereUniqueInput
    update?: XOR<XOR<ScheduleVersionUpdateToOneWithWhereWithoutGroupSessionsInput, ScheduleVersionUpdateWithoutGroupSessionsInput>, ScheduleVersionUncheckedUpdateWithoutGroupSessionsInput>
  }

  export type GroupSessionClientUpdateManyWithoutGroupSessionNestedInput = {
    create?: XOR<GroupSessionClientCreateWithoutGroupSessionInput, GroupSessionClientUncheckedCreateWithoutGroupSessionInput> | GroupSessionClientCreateWithoutGroupSessionInput[] | GroupSessionClientUncheckedCreateWithoutGroupSessionInput[]
    connectOrCreate?: GroupSessionClientCreateOrConnectWithoutGroupSessionInput | GroupSessionClientCreateOrConnectWithoutGroupSessionInput[]
    upsert?: GroupSessionClientUpsertWithWhereUniqueWithoutGroupSessionInput | GroupSessionClientUpsertWithWhereUniqueWithoutGroupSessionInput[]
    createMany?: GroupSessionClientCreateManyGroupSessionInputEnvelope
    set?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
    disconnect?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
    delete?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
    connect?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
    update?: GroupSessionClientUpdateWithWhereUniqueWithoutGroupSessionInput | GroupSessionClientUpdateWithWhereUniqueWithoutGroupSessionInput[]
    updateMany?: GroupSessionClientUpdateManyWithWhereWithoutGroupSessionInput | GroupSessionClientUpdateManyWithWhereWithoutGroupSessionInput[]
    deleteMany?: GroupSessionClientScalarWhereInput | GroupSessionClientScalarWhereInput[]
  }

  export type AssignmentUpdateManyWithoutGroupSessionNestedInput = {
    create?: XOR<AssignmentCreateWithoutGroupSessionInput, AssignmentUncheckedCreateWithoutGroupSessionInput> | AssignmentCreateWithoutGroupSessionInput[] | AssignmentUncheckedCreateWithoutGroupSessionInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutGroupSessionInput | AssignmentCreateOrConnectWithoutGroupSessionInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutGroupSessionInput | AssignmentUpsertWithWhereUniqueWithoutGroupSessionInput[]
    createMany?: AssignmentCreateManyGroupSessionInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutGroupSessionInput | AssignmentUpdateWithWhereUniqueWithoutGroupSessionInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutGroupSessionInput | AssignmentUpdateManyWithWhereWithoutGroupSessionInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type GroupSessionClientUncheckedUpdateManyWithoutGroupSessionNestedInput = {
    create?: XOR<GroupSessionClientCreateWithoutGroupSessionInput, GroupSessionClientUncheckedCreateWithoutGroupSessionInput> | GroupSessionClientCreateWithoutGroupSessionInput[] | GroupSessionClientUncheckedCreateWithoutGroupSessionInput[]
    connectOrCreate?: GroupSessionClientCreateOrConnectWithoutGroupSessionInput | GroupSessionClientCreateOrConnectWithoutGroupSessionInput[]
    upsert?: GroupSessionClientUpsertWithWhereUniqueWithoutGroupSessionInput | GroupSessionClientUpsertWithWhereUniqueWithoutGroupSessionInput[]
    createMany?: GroupSessionClientCreateManyGroupSessionInputEnvelope
    set?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
    disconnect?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
    delete?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
    connect?: GroupSessionClientWhereUniqueInput | GroupSessionClientWhereUniqueInput[]
    update?: GroupSessionClientUpdateWithWhereUniqueWithoutGroupSessionInput | GroupSessionClientUpdateWithWhereUniqueWithoutGroupSessionInput[]
    updateMany?: GroupSessionClientUpdateManyWithWhereWithoutGroupSessionInput | GroupSessionClientUpdateManyWithWhereWithoutGroupSessionInput[]
    deleteMany?: GroupSessionClientScalarWhereInput | GroupSessionClientScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutGroupSessionNestedInput = {
    create?: XOR<AssignmentCreateWithoutGroupSessionInput, AssignmentUncheckedCreateWithoutGroupSessionInput> | AssignmentCreateWithoutGroupSessionInput[] | AssignmentUncheckedCreateWithoutGroupSessionInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutGroupSessionInput | AssignmentCreateOrConnectWithoutGroupSessionInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutGroupSessionInput | AssignmentUpsertWithWhereUniqueWithoutGroupSessionInput[]
    createMany?: AssignmentCreateManyGroupSessionInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutGroupSessionInput | AssignmentUpdateWithWhereUniqueWithoutGroupSessionInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutGroupSessionInput | AssignmentUpdateManyWithWhereWithoutGroupSessionInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type GroupSessionCreateNestedOneWithoutClientsInput = {
    create?: XOR<GroupSessionCreateWithoutClientsInput, GroupSessionUncheckedCreateWithoutClientsInput>
    connectOrCreate?: GroupSessionCreateOrConnectWithoutClientsInput
    connect?: GroupSessionWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutGroupSessionClientsInput = {
    create?: XOR<ClientCreateWithoutGroupSessionClientsInput, ClientUncheckedCreateWithoutGroupSessionClientsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutGroupSessionClientsInput
    connect?: ClientWhereUniqueInput
  }

  export type GroupSessionUpdateOneRequiredWithoutClientsNestedInput = {
    create?: XOR<GroupSessionCreateWithoutClientsInput, GroupSessionUncheckedCreateWithoutClientsInput>
    connectOrCreate?: GroupSessionCreateOrConnectWithoutClientsInput
    upsert?: GroupSessionUpsertWithoutClientsInput
    connect?: GroupSessionWhereUniqueInput
    update?: XOR<XOR<GroupSessionUpdateToOneWithWhereWithoutClientsInput, GroupSessionUpdateWithoutClientsInput>, GroupSessionUncheckedUpdateWithoutClientsInput>
  }

  export type ClientUpdateOneRequiredWithoutGroupSessionClientsNestedInput = {
    create?: XOR<ClientCreateWithoutGroupSessionClientsInput, ClientUncheckedCreateWithoutGroupSessionClientsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutGroupSessionClientsInput
    upsert?: ClientUpsertWithoutGroupSessionClientsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutGroupSessionClientsInput, ClientUpdateWithoutGroupSessionClientsInput>, ClientUncheckedUpdateWithoutGroupSessionClientsInput>
  }

  export type ScheduleVersionCreateNestedOneWithoutChangeLogsInput = {
    create?: XOR<ScheduleVersionCreateWithoutChangeLogsInput, ScheduleVersionUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: ScheduleVersionCreateOrConnectWithoutChangeLogsInput
    connect?: ScheduleVersionWhereUniqueInput
  }

  export type StaffCreateNestedOneWithoutChangeLogsInput = {
    create?: XOR<StaffCreateWithoutChangeLogsInput, StaffUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutChangeLogsInput
    connect?: StaffWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutChangeLogsInput = {
    create?: XOR<ClientCreateWithoutChangeLogsInput, ClientUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutChangeLogsInput
    connect?: ClientWhereUniqueInput
  }

  export type ScheduleVersionUpdateOneRequiredWithoutChangeLogsNestedInput = {
    create?: XOR<ScheduleVersionCreateWithoutChangeLogsInput, ScheduleVersionUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: ScheduleVersionCreateOrConnectWithoutChangeLogsInput
    upsert?: ScheduleVersionUpsertWithoutChangeLogsInput
    connect?: ScheduleVersionWhereUniqueInput
    update?: XOR<XOR<ScheduleVersionUpdateToOneWithWhereWithoutChangeLogsInput, ScheduleVersionUpdateWithoutChangeLogsInput>, ScheduleVersionUncheckedUpdateWithoutChangeLogsInput>
  }

  export type StaffUpdateOneWithoutChangeLogsNestedInput = {
    create?: XOR<StaffCreateWithoutChangeLogsInput, StaffUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: StaffCreateOrConnectWithoutChangeLogsInput
    upsert?: StaffUpsertWithoutChangeLogsInput
    disconnect?: StaffWhereInput | boolean
    delete?: StaffWhereInput | boolean
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutChangeLogsInput, StaffUpdateWithoutChangeLogsInput>, StaffUncheckedUpdateWithoutChangeLogsInput>
  }

  export type ClientUpdateOneWithoutChangeLogsNestedInput = {
    create?: XOR<ClientCreateWithoutChangeLogsInput, ClientUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutChangeLogsInput
    upsert?: ClientUpsertWithoutChangeLogsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutChangeLogsInput, ClientUpdateWithoutChangeLogsInput>, ClientUncheckedUpdateWithoutChangeLogsInput>
  }

  export type StaffCreateNestedOneWithoutOriginalOverridesInput = {
    create?: XOR<StaffCreateWithoutOriginalOverridesInput, StaffUncheckedCreateWithoutOriginalOverridesInput>
    connectOrCreate?: StaffCreateOrConnectWithoutOriginalOverridesInput
    connect?: StaffWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutOriginalOverridesInput = {
    create?: XOR<ClientCreateWithoutOriginalOverridesInput, ClientUncheckedCreateWithoutOriginalOverridesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutOriginalOverridesInput
    connect?: ClientWhereUniqueInput
  }

  export type StaffCreateNestedOneWithoutNewOverridesInput = {
    create?: XOR<StaffCreateWithoutNewOverridesInput, StaffUncheckedCreateWithoutNewOverridesInput>
    connectOrCreate?: StaffCreateOrConnectWithoutNewOverridesInput
    connect?: StaffWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutNewOverridesInput = {
    create?: XOR<ClientCreateWithoutNewOverridesInput, ClientUncheckedCreateWithoutNewOverridesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutNewOverridesInput
    connect?: ClientWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StaffUpdateOneWithoutOriginalOverridesNestedInput = {
    create?: XOR<StaffCreateWithoutOriginalOverridesInput, StaffUncheckedCreateWithoutOriginalOverridesInput>
    connectOrCreate?: StaffCreateOrConnectWithoutOriginalOverridesInput
    upsert?: StaffUpsertWithoutOriginalOverridesInput
    disconnect?: StaffWhereInput | boolean
    delete?: StaffWhereInput | boolean
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutOriginalOverridesInput, StaffUpdateWithoutOriginalOverridesInput>, StaffUncheckedUpdateWithoutOriginalOverridesInput>
  }

  export type ClientUpdateOneWithoutOriginalOverridesNestedInput = {
    create?: XOR<ClientCreateWithoutOriginalOverridesInput, ClientUncheckedCreateWithoutOriginalOverridesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutOriginalOverridesInput
    upsert?: ClientUpsertWithoutOriginalOverridesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutOriginalOverridesInput, ClientUpdateWithoutOriginalOverridesInput>, ClientUncheckedUpdateWithoutOriginalOverridesInput>
  }

  export type StaffUpdateOneWithoutNewOverridesNestedInput = {
    create?: XOR<StaffCreateWithoutNewOverridesInput, StaffUncheckedCreateWithoutNewOverridesInput>
    connectOrCreate?: StaffCreateOrConnectWithoutNewOverridesInput
    upsert?: StaffUpsertWithoutNewOverridesInput
    disconnect?: StaffWhereInput | boolean
    delete?: StaffWhereInput | boolean
    connect?: StaffWhereUniqueInput
    update?: XOR<XOR<StaffUpdateToOneWithWhereWithoutNewOverridesInput, StaffUpdateWithoutNewOverridesInput>, StaffUncheckedUpdateWithoutNewOverridesInput>
  }

  export type ClientUpdateOneWithoutNewOverridesNestedInput = {
    create?: XOR<ClientCreateWithoutNewOverridesInput, ClientUncheckedCreateWithoutNewOverridesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutNewOverridesInput
    upsert?: ClientUpsertWithoutNewOverridesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutNewOverridesInput, ClientUpdateWithoutNewOverridesInput>, ClientUncheckedUpdateWithoutNewOverridesInput>
  }

  export type ClientCreateNestedOneWithoutSupervisorHistoryInput = {
    create?: XOR<ClientCreateWithoutSupervisorHistoryInput, ClientUncheckedCreateWithoutSupervisorHistoryInput>
    connectOrCreate?: ClientCreateOrConnectWithoutSupervisorHistoryInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutSupervisorHistoryNestedInput = {
    create?: XOR<ClientCreateWithoutSupervisorHistoryInput, ClientUncheckedCreateWithoutSupervisorHistoryInput>
    connectOrCreate?: ClientCreateOrConnectWithoutSupervisorHistoryInput
    upsert?: ClientUpsertWithoutSupervisorHistoryInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutSupervisorHistoryInput, ClientUpdateWithoutSupervisorHistoryInput>, ClientUncheckedUpdateWithoutSupervisorHistoryInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AssignmentCreateWithoutStaffInput = {
    day: string
    block: string
    isGroup?: boolean
    plannedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutAssignmentsInput
    version?: ScheduleVersionCreateNestedOneWithoutAssignmentsInput
    groupSession?: GroupSessionCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentUncheckedCreateWithoutStaffInput = {
    id?: number
    day: string
    block: string
    clientId: number
    versionId?: number
    isGroup?: boolean
    groupSessionId?: number | null
    plannedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateOrConnectWithoutStaffInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutStaffInput, AssignmentUncheckedCreateWithoutStaffInput>
  }

  export type AssignmentCreateManyStaffInputEnvelope = {
    data: AssignmentCreateManyStaffInput | AssignmentCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type GroupSessionCreateWithoutStaffInput = {
    day: string
    block: string
    location: string
    maxSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: ScheduleVersionCreateNestedOneWithoutGroupSessionsInput
    clients?: GroupSessionClientCreateNestedManyWithoutGroupSessionInput
    assignments?: AssignmentCreateNestedManyWithoutGroupSessionInput
  }

  export type GroupSessionUncheckedCreateWithoutStaffInput = {
    id?: number
    day: string
    block: string
    versionId?: number
    location: string
    maxSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: GroupSessionClientUncheckedCreateNestedManyWithoutGroupSessionInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutGroupSessionInput
  }

  export type GroupSessionCreateOrConnectWithoutStaffInput = {
    where: GroupSessionWhereUniqueInput
    create: XOR<GroupSessionCreateWithoutStaffInput, GroupSessionUncheckedCreateWithoutStaffInput>
  }

  export type GroupSessionCreateManyStaffInputEnvelope = {
    data: GroupSessionCreateManyStaffInput | GroupSessionCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type ChangeLogCreateWithoutStaffInput = {
    changeType: string
    entityType: string
    entityId?: number | null
    day?: string | null
    block?: string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: boolean
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    committedToMain?: boolean
    committedAt?: Date | string | null
    createdBy?: string
    createdAt?: Date | string
    notes?: string | null
    version: ScheduleVersionCreateNestedOneWithoutChangeLogsInput
    client?: ClientCreateNestedOneWithoutChangeLogsInput
  }

  export type ChangeLogUncheckedCreateWithoutStaffInput = {
    id?: number
    versionId: number
    changeType: string
    entityType: string
    entityId?: number | null
    day?: string | null
    block?: string | null
    clientId?: number | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: boolean
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    committedToMain?: boolean
    committedAt?: Date | string | null
    createdBy?: string
    createdAt?: Date | string
    notes?: string | null
  }

  export type ChangeLogCreateOrConnectWithoutStaffInput = {
    where: ChangeLogWhereUniqueInput
    create: XOR<ChangeLogCreateWithoutStaffInput, ChangeLogUncheckedCreateWithoutStaffInput>
  }

  export type ChangeLogCreateManyStaffInputEnvelope = {
    data: ChangeLogCreateManyStaffInput | ChangeLogCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type DailyOverrideCreateWithoutOriginalStaffInput = {
    date: Date | string
    type: string
    day: string
    block: string
    reason: string
    hours?: number | null
    status?: string
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    originalClient?: ClientCreateNestedOneWithoutOriginalOverridesInput
    newStaff?: StaffCreateNestedOneWithoutNewOverridesInput
    newClient?: ClientCreateNestedOneWithoutNewOverridesInput
  }

  export type DailyOverrideUncheckedCreateWithoutOriginalStaffInput = {
    id?: number
    date: Date | string
    type: string
    day: string
    block: string
    originalClientId?: number | null
    newStaffId?: number | null
    newClientId?: number | null
    reason: string
    hours?: number | null
    status?: string
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyOverrideCreateOrConnectWithoutOriginalStaffInput = {
    where: DailyOverrideWhereUniqueInput
    create: XOR<DailyOverrideCreateWithoutOriginalStaffInput, DailyOverrideUncheckedCreateWithoutOriginalStaffInput>
  }

  export type DailyOverrideCreateManyOriginalStaffInputEnvelope = {
    data: DailyOverrideCreateManyOriginalStaffInput | DailyOverrideCreateManyOriginalStaffInput[]
    skipDuplicates?: boolean
  }

  export type DailyOverrideCreateWithoutNewStaffInput = {
    date: Date | string
    type: string
    day: string
    block: string
    reason: string
    hours?: number | null
    status?: string
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    originalStaff?: StaffCreateNestedOneWithoutOriginalOverridesInput
    originalClient?: ClientCreateNestedOneWithoutOriginalOverridesInput
    newClient?: ClientCreateNestedOneWithoutNewOverridesInput
  }

  export type DailyOverrideUncheckedCreateWithoutNewStaffInput = {
    id?: number
    date: Date | string
    type: string
    day: string
    block: string
    originalStaffId?: number | null
    originalClientId?: number | null
    newClientId?: number | null
    reason: string
    hours?: number | null
    status?: string
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyOverrideCreateOrConnectWithoutNewStaffInput = {
    where: DailyOverrideWhereUniqueInput
    create: XOR<DailyOverrideCreateWithoutNewStaffInput, DailyOverrideUncheckedCreateWithoutNewStaffInput>
  }

  export type DailyOverrideCreateManyNewStaffInputEnvelope = {
    data: DailyOverrideCreateManyNewStaffInput | DailyOverrideCreateManyNewStaffInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentUpsertWithWhereUniqueWithoutStaffInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutStaffInput, AssignmentUncheckedUpdateWithoutStaffInput>
    create: XOR<AssignmentCreateWithoutStaffInput, AssignmentUncheckedCreateWithoutStaffInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutStaffInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutStaffInput, AssignmentUncheckedUpdateWithoutStaffInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutStaffInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutStaffInput>
  }

  export type AssignmentScalarWhereInput = {
    AND?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    OR?: AssignmentScalarWhereInput[]
    NOT?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    id?: IntFilter<"Assignment"> | number
    day?: StringFilter<"Assignment"> | string
    block?: StringFilter<"Assignment"> | string
    staffId?: IntFilter<"Assignment"> | number
    clientId?: IntFilter<"Assignment"> | number
    versionId?: IntFilter<"Assignment"> | number
    isGroup?: BoolFilter<"Assignment"> | boolean
    groupSessionId?: IntNullableFilter<"Assignment"> | number | null
    plannedDate?: DateTimeNullableFilter<"Assignment"> | Date | string | null
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
  }

  export type GroupSessionUpsertWithWhereUniqueWithoutStaffInput = {
    where: GroupSessionWhereUniqueInput
    update: XOR<GroupSessionUpdateWithoutStaffInput, GroupSessionUncheckedUpdateWithoutStaffInput>
    create: XOR<GroupSessionCreateWithoutStaffInput, GroupSessionUncheckedCreateWithoutStaffInput>
  }

  export type GroupSessionUpdateWithWhereUniqueWithoutStaffInput = {
    where: GroupSessionWhereUniqueInput
    data: XOR<GroupSessionUpdateWithoutStaffInput, GroupSessionUncheckedUpdateWithoutStaffInput>
  }

  export type GroupSessionUpdateManyWithWhereWithoutStaffInput = {
    where: GroupSessionScalarWhereInput
    data: XOR<GroupSessionUpdateManyMutationInput, GroupSessionUncheckedUpdateManyWithoutStaffInput>
  }

  export type GroupSessionScalarWhereInput = {
    AND?: GroupSessionScalarWhereInput | GroupSessionScalarWhereInput[]
    OR?: GroupSessionScalarWhereInput[]
    NOT?: GroupSessionScalarWhereInput | GroupSessionScalarWhereInput[]
    id?: IntFilter<"GroupSession"> | number
    day?: StringFilter<"GroupSession"> | string
    block?: StringFilter<"GroupSession"> | string
    staffId?: IntFilter<"GroupSession"> | number
    versionId?: IntFilter<"GroupSession"> | number
    location?: StringFilter<"GroupSession"> | string
    maxSize?: IntFilter<"GroupSession"> | number
    createdAt?: DateTimeFilter<"GroupSession"> | Date | string
    updatedAt?: DateTimeFilter<"GroupSession"> | Date | string
  }

  export type ChangeLogUpsertWithWhereUniqueWithoutStaffInput = {
    where: ChangeLogWhereUniqueInput
    update: XOR<ChangeLogUpdateWithoutStaffInput, ChangeLogUncheckedUpdateWithoutStaffInput>
    create: XOR<ChangeLogCreateWithoutStaffInput, ChangeLogUncheckedCreateWithoutStaffInput>
  }

  export type ChangeLogUpdateWithWhereUniqueWithoutStaffInput = {
    where: ChangeLogWhereUniqueInput
    data: XOR<ChangeLogUpdateWithoutStaffInput, ChangeLogUncheckedUpdateWithoutStaffInput>
  }

  export type ChangeLogUpdateManyWithWhereWithoutStaffInput = {
    where: ChangeLogScalarWhereInput
    data: XOR<ChangeLogUpdateManyMutationInput, ChangeLogUncheckedUpdateManyWithoutStaffInput>
  }

  export type ChangeLogScalarWhereInput = {
    AND?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
    OR?: ChangeLogScalarWhereInput[]
    NOT?: ChangeLogScalarWhereInput | ChangeLogScalarWhereInput[]
    id?: IntFilter<"ChangeLog"> | number
    versionId?: IntFilter<"ChangeLog"> | number
    changeType?: StringFilter<"ChangeLog"> | string
    entityType?: StringFilter<"ChangeLog"> | string
    entityId?: IntNullableFilter<"ChangeLog"> | number | null
    day?: StringNullableFilter<"ChangeLog"> | string | null
    block?: StringNullableFilter<"ChangeLog"> | string | null
    staffId?: IntNullableFilter<"ChangeLog"> | number | null
    clientId?: IntNullableFilter<"ChangeLog"> | number | null
    previousValue?: JsonNullableFilter<"ChangeLog">
    newValue?: JsonNullableFilter<"ChangeLog">
    reviewed?: BoolFilter<"ChangeLog"> | boolean
    reviewedAt?: DateTimeNullableFilter<"ChangeLog"> | Date | string | null
    reviewedBy?: StringNullableFilter<"ChangeLog"> | string | null
    committedToMain?: BoolFilter<"ChangeLog"> | boolean
    committedAt?: DateTimeNullableFilter<"ChangeLog"> | Date | string | null
    createdBy?: StringFilter<"ChangeLog"> | string
    createdAt?: DateTimeFilter<"ChangeLog"> | Date | string
    notes?: StringNullableFilter<"ChangeLog"> | string | null
  }

  export type DailyOverrideUpsertWithWhereUniqueWithoutOriginalStaffInput = {
    where: DailyOverrideWhereUniqueInput
    update: XOR<DailyOverrideUpdateWithoutOriginalStaffInput, DailyOverrideUncheckedUpdateWithoutOriginalStaffInput>
    create: XOR<DailyOverrideCreateWithoutOriginalStaffInput, DailyOverrideUncheckedCreateWithoutOriginalStaffInput>
  }

  export type DailyOverrideUpdateWithWhereUniqueWithoutOriginalStaffInput = {
    where: DailyOverrideWhereUniqueInput
    data: XOR<DailyOverrideUpdateWithoutOriginalStaffInput, DailyOverrideUncheckedUpdateWithoutOriginalStaffInput>
  }

  export type DailyOverrideUpdateManyWithWhereWithoutOriginalStaffInput = {
    where: DailyOverrideScalarWhereInput
    data: XOR<DailyOverrideUpdateManyMutationInput, DailyOverrideUncheckedUpdateManyWithoutOriginalStaffInput>
  }

  export type DailyOverrideScalarWhereInput = {
    AND?: DailyOverrideScalarWhereInput | DailyOverrideScalarWhereInput[]
    OR?: DailyOverrideScalarWhereInput[]
    NOT?: DailyOverrideScalarWhereInput | DailyOverrideScalarWhereInput[]
    id?: IntFilter<"DailyOverride"> | number
    date?: DateTimeFilter<"DailyOverride"> | Date | string
    type?: StringFilter<"DailyOverride"> | string
    day?: StringFilter<"DailyOverride"> | string
    block?: StringFilter<"DailyOverride"> | string
    originalStaffId?: IntNullableFilter<"DailyOverride"> | number | null
    originalClientId?: IntNullableFilter<"DailyOverride"> | number | null
    newStaffId?: IntNullableFilter<"DailyOverride"> | number | null
    newClientId?: IntNullableFilter<"DailyOverride"> | number | null
    reason?: StringFilter<"DailyOverride"> | string
    hours?: FloatNullableFilter<"DailyOverride"> | number | null
    status?: StringFilter<"DailyOverride"> | string
    createdBy?: StringFilter<"DailyOverride"> | string
    createdAt?: DateTimeFilter<"DailyOverride"> | Date | string
    updatedAt?: DateTimeFilter<"DailyOverride"> | Date | string
  }

  export type DailyOverrideUpsertWithWhereUniqueWithoutNewStaffInput = {
    where: DailyOverrideWhereUniqueInput
    update: XOR<DailyOverrideUpdateWithoutNewStaffInput, DailyOverrideUncheckedUpdateWithoutNewStaffInput>
    create: XOR<DailyOverrideCreateWithoutNewStaffInput, DailyOverrideUncheckedCreateWithoutNewStaffInput>
  }

  export type DailyOverrideUpdateWithWhereUniqueWithoutNewStaffInput = {
    where: DailyOverrideWhereUniqueInput
    data: XOR<DailyOverrideUpdateWithoutNewStaffInput, DailyOverrideUncheckedUpdateWithoutNewStaffInput>
  }

  export type DailyOverrideUpdateManyWithWhereWithoutNewStaffInput = {
    where: DailyOverrideScalarWhereInput
    data: XOR<DailyOverrideUpdateManyMutationInput, DailyOverrideUncheckedUpdateManyWithoutNewStaffInput>
  }

  export type AssignmentCreateWithoutClientInput = {
    day: string
    block: string
    isGroup?: boolean
    plannedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffCreateNestedOneWithoutAssignmentsInput
    version?: ScheduleVersionCreateNestedOneWithoutAssignmentsInput
    groupSession?: GroupSessionCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentUncheckedCreateWithoutClientInput = {
    id?: number
    day: string
    block: string
    staffId: number
    versionId?: number
    isGroup?: boolean
    groupSessionId?: number | null
    plannedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateOrConnectWithoutClientInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutClientInput, AssignmentUncheckedCreateWithoutClientInput>
  }

  export type AssignmentCreateManyClientInputEnvelope = {
    data: AssignmentCreateManyClientInput | AssignmentCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type GroupSessionClientCreateWithoutClientInput = {
    groupSession: GroupSessionCreateNestedOneWithoutClientsInput
  }

  export type GroupSessionClientUncheckedCreateWithoutClientInput = {
    id?: number
    groupSessionId: number
  }

  export type GroupSessionClientCreateOrConnectWithoutClientInput = {
    where: GroupSessionClientWhereUniqueInput
    create: XOR<GroupSessionClientCreateWithoutClientInput, GroupSessionClientUncheckedCreateWithoutClientInput>
  }

  export type GroupSessionClientCreateManyClientInputEnvelope = {
    data: GroupSessionClientCreateManyClientInput | GroupSessionClientCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ChangeLogCreateWithoutClientInput = {
    changeType: string
    entityType: string
    entityId?: number | null
    day?: string | null
    block?: string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: boolean
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    committedToMain?: boolean
    committedAt?: Date | string | null
    createdBy?: string
    createdAt?: Date | string
    notes?: string | null
    version: ScheduleVersionCreateNestedOneWithoutChangeLogsInput
    staff?: StaffCreateNestedOneWithoutChangeLogsInput
  }

  export type ChangeLogUncheckedCreateWithoutClientInput = {
    id?: number
    versionId: number
    changeType: string
    entityType: string
    entityId?: number | null
    day?: string | null
    block?: string | null
    staffId?: number | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: boolean
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    committedToMain?: boolean
    committedAt?: Date | string | null
    createdBy?: string
    createdAt?: Date | string
    notes?: string | null
  }

  export type ChangeLogCreateOrConnectWithoutClientInput = {
    where: ChangeLogWhereUniqueInput
    create: XOR<ChangeLogCreateWithoutClientInput, ChangeLogUncheckedCreateWithoutClientInput>
  }

  export type ChangeLogCreateManyClientInputEnvelope = {
    data: ChangeLogCreateManyClientInput | ChangeLogCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type DailyOverrideCreateWithoutOriginalClientInput = {
    date: Date | string
    type: string
    day: string
    block: string
    reason: string
    hours?: number | null
    status?: string
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    originalStaff?: StaffCreateNestedOneWithoutOriginalOverridesInput
    newStaff?: StaffCreateNestedOneWithoutNewOverridesInput
    newClient?: ClientCreateNestedOneWithoutNewOverridesInput
  }

  export type DailyOverrideUncheckedCreateWithoutOriginalClientInput = {
    id?: number
    date: Date | string
    type: string
    day: string
    block: string
    originalStaffId?: number | null
    newStaffId?: number | null
    newClientId?: number | null
    reason: string
    hours?: number | null
    status?: string
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyOverrideCreateOrConnectWithoutOriginalClientInput = {
    where: DailyOverrideWhereUniqueInput
    create: XOR<DailyOverrideCreateWithoutOriginalClientInput, DailyOverrideUncheckedCreateWithoutOriginalClientInput>
  }

  export type DailyOverrideCreateManyOriginalClientInputEnvelope = {
    data: DailyOverrideCreateManyOriginalClientInput | DailyOverrideCreateManyOriginalClientInput[]
    skipDuplicates?: boolean
  }

  export type DailyOverrideCreateWithoutNewClientInput = {
    date: Date | string
    type: string
    day: string
    block: string
    reason: string
    hours?: number | null
    status?: string
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    originalStaff?: StaffCreateNestedOneWithoutOriginalOverridesInput
    originalClient?: ClientCreateNestedOneWithoutOriginalOverridesInput
    newStaff?: StaffCreateNestedOneWithoutNewOverridesInput
  }

  export type DailyOverrideUncheckedCreateWithoutNewClientInput = {
    id?: number
    date: Date | string
    type: string
    day: string
    block: string
    originalStaffId?: number | null
    originalClientId?: number | null
    newStaffId?: number | null
    reason: string
    hours?: number | null
    status?: string
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyOverrideCreateOrConnectWithoutNewClientInput = {
    where: DailyOverrideWhereUniqueInput
    create: XOR<DailyOverrideCreateWithoutNewClientInput, DailyOverrideUncheckedCreateWithoutNewClientInput>
  }

  export type DailyOverrideCreateManyNewClientInputEnvelope = {
    data: DailyOverrideCreateManyNewClientInput | DailyOverrideCreateManyNewClientInput[]
    skipDuplicates?: boolean
  }

  export type ClientSupervisorCreateWithoutClientInput = {
    supervisorName: string
    effectiveDate: Date | string
    endDate?: Date | string | null
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientSupervisorUncheckedCreateWithoutClientInput = {
    id?: number
    supervisorName: string
    effectiveDate: Date | string
    endDate?: Date | string | null
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientSupervisorCreateOrConnectWithoutClientInput = {
    where: ClientSupervisorWhereUniqueInput
    create: XOR<ClientSupervisorCreateWithoutClientInput, ClientSupervisorUncheckedCreateWithoutClientInput>
  }

  export type ClientSupervisorCreateManyClientInputEnvelope = {
    data: ClientSupervisorCreateManyClientInput | ClientSupervisorCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentUpsertWithWhereUniqueWithoutClientInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutClientInput, AssignmentUncheckedUpdateWithoutClientInput>
    create: XOR<AssignmentCreateWithoutClientInput, AssignmentUncheckedCreateWithoutClientInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutClientInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutClientInput, AssignmentUncheckedUpdateWithoutClientInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutClientInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutClientInput>
  }

  export type GroupSessionClientUpsertWithWhereUniqueWithoutClientInput = {
    where: GroupSessionClientWhereUniqueInput
    update: XOR<GroupSessionClientUpdateWithoutClientInput, GroupSessionClientUncheckedUpdateWithoutClientInput>
    create: XOR<GroupSessionClientCreateWithoutClientInput, GroupSessionClientUncheckedCreateWithoutClientInput>
  }

  export type GroupSessionClientUpdateWithWhereUniqueWithoutClientInput = {
    where: GroupSessionClientWhereUniqueInput
    data: XOR<GroupSessionClientUpdateWithoutClientInput, GroupSessionClientUncheckedUpdateWithoutClientInput>
  }

  export type GroupSessionClientUpdateManyWithWhereWithoutClientInput = {
    where: GroupSessionClientScalarWhereInput
    data: XOR<GroupSessionClientUpdateManyMutationInput, GroupSessionClientUncheckedUpdateManyWithoutClientInput>
  }

  export type GroupSessionClientScalarWhereInput = {
    AND?: GroupSessionClientScalarWhereInput | GroupSessionClientScalarWhereInput[]
    OR?: GroupSessionClientScalarWhereInput[]
    NOT?: GroupSessionClientScalarWhereInput | GroupSessionClientScalarWhereInput[]
    id?: IntFilter<"GroupSessionClient"> | number
    groupSessionId?: IntFilter<"GroupSessionClient"> | number
    clientId?: IntFilter<"GroupSessionClient"> | number
  }

  export type ChangeLogUpsertWithWhereUniqueWithoutClientInput = {
    where: ChangeLogWhereUniqueInput
    update: XOR<ChangeLogUpdateWithoutClientInput, ChangeLogUncheckedUpdateWithoutClientInput>
    create: XOR<ChangeLogCreateWithoutClientInput, ChangeLogUncheckedCreateWithoutClientInput>
  }

  export type ChangeLogUpdateWithWhereUniqueWithoutClientInput = {
    where: ChangeLogWhereUniqueInput
    data: XOR<ChangeLogUpdateWithoutClientInput, ChangeLogUncheckedUpdateWithoutClientInput>
  }

  export type ChangeLogUpdateManyWithWhereWithoutClientInput = {
    where: ChangeLogScalarWhereInput
    data: XOR<ChangeLogUpdateManyMutationInput, ChangeLogUncheckedUpdateManyWithoutClientInput>
  }

  export type DailyOverrideUpsertWithWhereUniqueWithoutOriginalClientInput = {
    where: DailyOverrideWhereUniqueInput
    update: XOR<DailyOverrideUpdateWithoutOriginalClientInput, DailyOverrideUncheckedUpdateWithoutOriginalClientInput>
    create: XOR<DailyOverrideCreateWithoutOriginalClientInput, DailyOverrideUncheckedCreateWithoutOriginalClientInput>
  }

  export type DailyOverrideUpdateWithWhereUniqueWithoutOriginalClientInput = {
    where: DailyOverrideWhereUniqueInput
    data: XOR<DailyOverrideUpdateWithoutOriginalClientInput, DailyOverrideUncheckedUpdateWithoutOriginalClientInput>
  }

  export type DailyOverrideUpdateManyWithWhereWithoutOriginalClientInput = {
    where: DailyOverrideScalarWhereInput
    data: XOR<DailyOverrideUpdateManyMutationInput, DailyOverrideUncheckedUpdateManyWithoutOriginalClientInput>
  }

  export type DailyOverrideUpsertWithWhereUniqueWithoutNewClientInput = {
    where: DailyOverrideWhereUniqueInput
    update: XOR<DailyOverrideUpdateWithoutNewClientInput, DailyOverrideUncheckedUpdateWithoutNewClientInput>
    create: XOR<DailyOverrideCreateWithoutNewClientInput, DailyOverrideUncheckedCreateWithoutNewClientInput>
  }

  export type DailyOverrideUpdateWithWhereUniqueWithoutNewClientInput = {
    where: DailyOverrideWhereUniqueInput
    data: XOR<DailyOverrideUpdateWithoutNewClientInput, DailyOverrideUncheckedUpdateWithoutNewClientInput>
  }

  export type DailyOverrideUpdateManyWithWhereWithoutNewClientInput = {
    where: DailyOverrideScalarWhereInput
    data: XOR<DailyOverrideUpdateManyMutationInput, DailyOverrideUncheckedUpdateManyWithoutNewClientInput>
  }

  export type ClientSupervisorUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientSupervisorWhereUniqueInput
    update: XOR<ClientSupervisorUpdateWithoutClientInput, ClientSupervisorUncheckedUpdateWithoutClientInput>
    create: XOR<ClientSupervisorCreateWithoutClientInput, ClientSupervisorUncheckedCreateWithoutClientInput>
  }

  export type ClientSupervisorUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientSupervisorWhereUniqueInput
    data: XOR<ClientSupervisorUpdateWithoutClientInput, ClientSupervisorUncheckedUpdateWithoutClientInput>
  }

  export type ClientSupervisorUpdateManyWithWhereWithoutClientInput = {
    where: ClientSupervisorScalarWhereInput
    data: XOR<ClientSupervisorUpdateManyMutationInput, ClientSupervisorUncheckedUpdateManyWithoutClientInput>
  }

  export type ClientSupervisorScalarWhereInput = {
    AND?: ClientSupervisorScalarWhereInput | ClientSupervisorScalarWhereInput[]
    OR?: ClientSupervisorScalarWhereInput[]
    NOT?: ClientSupervisorScalarWhereInput | ClientSupervisorScalarWhereInput[]
    id?: IntFilter<"ClientSupervisor"> | number
    clientId?: IntFilter<"ClientSupervisor"> | number
    supervisorName?: StringFilter<"ClientSupervisor"> | string
    effectiveDate?: DateTimeFilter<"ClientSupervisor"> | Date | string
    endDate?: DateTimeNullableFilter<"ClientSupervisor"> | Date | string | null
    createdBy?: StringFilter<"ClientSupervisor"> | string
    createdAt?: DateTimeFilter<"ClientSupervisor"> | Date | string
    updatedAt?: DateTimeFilter<"ClientSupervisor"> | Date | string
  }

  export type AssignmentCreateWithoutVersionInput = {
    day: string
    block: string
    isGroup?: boolean
    plannedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffCreateNestedOneWithoutAssignmentsInput
    client: ClientCreateNestedOneWithoutAssignmentsInput
    groupSession?: GroupSessionCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentUncheckedCreateWithoutVersionInput = {
    id?: number
    day: string
    block: string
    staffId: number
    clientId: number
    isGroup?: boolean
    groupSessionId?: number | null
    plannedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateOrConnectWithoutVersionInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutVersionInput, AssignmentUncheckedCreateWithoutVersionInput>
  }

  export type AssignmentCreateManyVersionInputEnvelope = {
    data: AssignmentCreateManyVersionInput | AssignmentCreateManyVersionInput[]
    skipDuplicates?: boolean
  }

  export type GroupSessionCreateWithoutVersionInput = {
    day: string
    block: string
    location: string
    maxSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffCreateNestedOneWithoutGroupSessionsInput
    clients?: GroupSessionClientCreateNestedManyWithoutGroupSessionInput
    assignments?: AssignmentCreateNestedManyWithoutGroupSessionInput
  }

  export type GroupSessionUncheckedCreateWithoutVersionInput = {
    id?: number
    day: string
    block: string
    staffId: number
    location: string
    maxSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: GroupSessionClientUncheckedCreateNestedManyWithoutGroupSessionInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutGroupSessionInput
  }

  export type GroupSessionCreateOrConnectWithoutVersionInput = {
    where: GroupSessionWhereUniqueInput
    create: XOR<GroupSessionCreateWithoutVersionInput, GroupSessionUncheckedCreateWithoutVersionInput>
  }

  export type GroupSessionCreateManyVersionInputEnvelope = {
    data: GroupSessionCreateManyVersionInput | GroupSessionCreateManyVersionInput[]
    skipDuplicates?: boolean
  }

  export type ChangeLogCreateWithoutVersionInput = {
    changeType: string
    entityType: string
    entityId?: number | null
    day?: string | null
    block?: string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: boolean
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    committedToMain?: boolean
    committedAt?: Date | string | null
    createdBy?: string
    createdAt?: Date | string
    notes?: string | null
    staff?: StaffCreateNestedOneWithoutChangeLogsInput
    client?: ClientCreateNestedOneWithoutChangeLogsInput
  }

  export type ChangeLogUncheckedCreateWithoutVersionInput = {
    id?: number
    changeType: string
    entityType: string
    entityId?: number | null
    day?: string | null
    block?: string | null
    staffId?: number | null
    clientId?: number | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: boolean
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    committedToMain?: boolean
    committedAt?: Date | string | null
    createdBy?: string
    createdAt?: Date | string
    notes?: string | null
  }

  export type ChangeLogCreateOrConnectWithoutVersionInput = {
    where: ChangeLogWhereUniqueInput
    create: XOR<ChangeLogCreateWithoutVersionInput, ChangeLogUncheckedCreateWithoutVersionInput>
  }

  export type ChangeLogCreateManyVersionInputEnvelope = {
    data: ChangeLogCreateManyVersionInput | ChangeLogCreateManyVersionInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentUpsertWithWhereUniqueWithoutVersionInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutVersionInput, AssignmentUncheckedUpdateWithoutVersionInput>
    create: XOR<AssignmentCreateWithoutVersionInput, AssignmentUncheckedCreateWithoutVersionInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutVersionInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutVersionInput, AssignmentUncheckedUpdateWithoutVersionInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutVersionInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutVersionInput>
  }

  export type GroupSessionUpsertWithWhereUniqueWithoutVersionInput = {
    where: GroupSessionWhereUniqueInput
    update: XOR<GroupSessionUpdateWithoutVersionInput, GroupSessionUncheckedUpdateWithoutVersionInput>
    create: XOR<GroupSessionCreateWithoutVersionInput, GroupSessionUncheckedCreateWithoutVersionInput>
  }

  export type GroupSessionUpdateWithWhereUniqueWithoutVersionInput = {
    where: GroupSessionWhereUniqueInput
    data: XOR<GroupSessionUpdateWithoutVersionInput, GroupSessionUncheckedUpdateWithoutVersionInput>
  }

  export type GroupSessionUpdateManyWithWhereWithoutVersionInput = {
    where: GroupSessionScalarWhereInput
    data: XOR<GroupSessionUpdateManyMutationInput, GroupSessionUncheckedUpdateManyWithoutVersionInput>
  }

  export type ChangeLogUpsertWithWhereUniqueWithoutVersionInput = {
    where: ChangeLogWhereUniqueInput
    update: XOR<ChangeLogUpdateWithoutVersionInput, ChangeLogUncheckedUpdateWithoutVersionInput>
    create: XOR<ChangeLogCreateWithoutVersionInput, ChangeLogUncheckedCreateWithoutVersionInput>
  }

  export type ChangeLogUpdateWithWhereUniqueWithoutVersionInput = {
    where: ChangeLogWhereUniqueInput
    data: XOR<ChangeLogUpdateWithoutVersionInput, ChangeLogUncheckedUpdateWithoutVersionInput>
  }

  export type ChangeLogUpdateManyWithWhereWithoutVersionInput = {
    where: ChangeLogScalarWhereInput
    data: XOR<ChangeLogUpdateManyMutationInput, ChangeLogUncheckedUpdateManyWithoutVersionInput>
  }

  export type StaffCreateWithoutAssignmentsInput = {
    name: string
    locations?: StaffCreatelocationsInput | string[]
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    groupSessions?: GroupSessionCreateNestedManyWithoutStaffInput
    changeLogs?: ChangeLogCreateNestedManyWithoutStaffInput
    originalOverrides?: DailyOverrideCreateNestedManyWithoutOriginalStaffInput
    newOverrides?: DailyOverrideCreateNestedManyWithoutNewStaffInput
  }

  export type StaffUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    name: string
    locations?: StaffCreatelocationsInput | string[]
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    groupSessions?: GroupSessionUncheckedCreateNestedManyWithoutStaffInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutStaffInput
    originalOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutOriginalStaffInput
    newOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutNewStaffInput
  }

  export type StaffCreateOrConnectWithoutAssignmentsInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutAssignmentsInput, StaffUncheckedCreateWithoutAssignmentsInput>
  }

  export type ClientCreateWithoutAssignmentsInput = {
    name: string
    locations?: ClientCreatelocationsInput | string[]
    authorizedHours?: number
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    groupSessionClients?: GroupSessionClientCreateNestedManyWithoutClientInput
    changeLogs?: ChangeLogCreateNestedManyWithoutClientInput
    originalOverrides?: DailyOverrideCreateNestedManyWithoutOriginalClientInput
    newOverrides?: DailyOverrideCreateNestedManyWithoutNewClientInput
    supervisorHistory?: ClientSupervisorCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    name: string
    locations?: ClientCreatelocationsInput | string[]
    authorizedHours?: number
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    groupSessionClients?: GroupSessionClientUncheckedCreateNestedManyWithoutClientInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutClientInput
    originalOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutOriginalClientInput
    newOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutNewClientInput
    supervisorHistory?: ClientSupervisorUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutAssignmentsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAssignmentsInput, ClientUncheckedCreateWithoutAssignmentsInput>
  }

  export type ScheduleVersionCreateWithoutAssignmentsInput = {
    name: string
    type: string
    status?: string
    startDate?: Date | string | null
    description?: string | null
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    groupSessions?: GroupSessionCreateNestedManyWithoutVersionInput
    changeLogs?: ChangeLogCreateNestedManyWithoutVersionInput
  }

  export type ScheduleVersionUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    name: string
    type: string
    status?: string
    startDate?: Date | string | null
    description?: string | null
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    groupSessions?: GroupSessionUncheckedCreateNestedManyWithoutVersionInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutVersionInput
  }

  export type ScheduleVersionCreateOrConnectWithoutAssignmentsInput = {
    where: ScheduleVersionWhereUniqueInput
    create: XOR<ScheduleVersionCreateWithoutAssignmentsInput, ScheduleVersionUncheckedCreateWithoutAssignmentsInput>
  }

  export type GroupSessionCreateWithoutAssignmentsInput = {
    day: string
    block: string
    location: string
    maxSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffCreateNestedOneWithoutGroupSessionsInput
    version?: ScheduleVersionCreateNestedOneWithoutGroupSessionsInput
    clients?: GroupSessionClientCreateNestedManyWithoutGroupSessionInput
  }

  export type GroupSessionUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    day: string
    block: string
    staffId: number
    versionId?: number
    location: string
    maxSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    clients?: GroupSessionClientUncheckedCreateNestedManyWithoutGroupSessionInput
  }

  export type GroupSessionCreateOrConnectWithoutAssignmentsInput = {
    where: GroupSessionWhereUniqueInput
    create: XOR<GroupSessionCreateWithoutAssignmentsInput, GroupSessionUncheckedCreateWithoutAssignmentsInput>
  }

  export type StaffUpsertWithoutAssignmentsInput = {
    update: XOR<StaffUpdateWithoutAssignmentsInput, StaffUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<StaffCreateWithoutAssignmentsInput, StaffUncheckedCreateWithoutAssignmentsInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutAssignmentsInput, StaffUncheckedUpdateWithoutAssignmentsInput>
  }

  export type StaffUpdateWithoutAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    locations?: StaffUpdatelocationsInput | string[]
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupSessions?: GroupSessionUpdateManyWithoutStaffNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutStaffNestedInput
    originalOverrides?: DailyOverrideUpdateManyWithoutOriginalStaffNestedInput
    newOverrides?: DailyOverrideUpdateManyWithoutNewStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: StaffUpdatelocationsInput | string[]
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupSessions?: GroupSessionUncheckedUpdateManyWithoutStaffNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutStaffNestedInput
    originalOverrides?: DailyOverrideUncheckedUpdateManyWithoutOriginalStaffNestedInput
    newOverrides?: DailyOverrideUncheckedUpdateManyWithoutNewStaffNestedInput
  }

  export type ClientUpsertWithoutAssignmentsInput = {
    update: XOR<ClientUpdateWithoutAssignmentsInput, ClientUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<ClientCreateWithoutAssignmentsInput, ClientUncheckedCreateWithoutAssignmentsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutAssignmentsInput, ClientUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ClientUpdateWithoutAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    locations?: ClientUpdatelocationsInput | string[]
    authorizedHours?: FloatFieldUpdateOperationsInput | number
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupSessionClients?: GroupSessionClientUpdateManyWithoutClientNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutClientNestedInput
    originalOverrides?: DailyOverrideUpdateManyWithoutOriginalClientNestedInput
    newOverrides?: DailyOverrideUpdateManyWithoutNewClientNestedInput
    supervisorHistory?: ClientSupervisorUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: ClientUpdatelocationsInput | string[]
    authorizedHours?: FloatFieldUpdateOperationsInput | number
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupSessionClients?: GroupSessionClientUncheckedUpdateManyWithoutClientNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutClientNestedInput
    originalOverrides?: DailyOverrideUncheckedUpdateManyWithoutOriginalClientNestedInput
    newOverrides?: DailyOverrideUncheckedUpdateManyWithoutNewClientNestedInput
    supervisorHistory?: ClientSupervisorUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ScheduleVersionUpsertWithoutAssignmentsInput = {
    update: XOR<ScheduleVersionUpdateWithoutAssignmentsInput, ScheduleVersionUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<ScheduleVersionCreateWithoutAssignmentsInput, ScheduleVersionUncheckedCreateWithoutAssignmentsInput>
    where?: ScheduleVersionWhereInput
  }

  export type ScheduleVersionUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: ScheduleVersionWhereInput
    data: XOR<ScheduleVersionUpdateWithoutAssignmentsInput, ScheduleVersionUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ScheduleVersionUpdateWithoutAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupSessions?: GroupSessionUpdateManyWithoutVersionNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutVersionNestedInput
  }

  export type ScheduleVersionUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupSessions?: GroupSessionUncheckedUpdateManyWithoutVersionNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type GroupSessionUpsertWithoutAssignmentsInput = {
    update: XOR<GroupSessionUpdateWithoutAssignmentsInput, GroupSessionUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<GroupSessionCreateWithoutAssignmentsInput, GroupSessionUncheckedCreateWithoutAssignmentsInput>
    where?: GroupSessionWhereInput
  }

  export type GroupSessionUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: GroupSessionWhereInput
    data: XOR<GroupSessionUpdateWithoutAssignmentsInput, GroupSessionUncheckedUpdateWithoutAssignmentsInput>
  }

  export type GroupSessionUpdateWithoutAssignmentsInput = {
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    maxSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneRequiredWithoutGroupSessionsNestedInput
    version?: ScheduleVersionUpdateOneRequiredWithoutGroupSessionsNestedInput
    clients?: GroupSessionClientUpdateManyWithoutGroupSessionNestedInput
  }

  export type GroupSessionUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    maxSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: GroupSessionClientUncheckedUpdateManyWithoutGroupSessionNestedInput
  }

  export type StaffCreateWithoutGroupSessionsInput = {
    name: string
    locations?: StaffCreatelocationsInput | string[]
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutStaffInput
    changeLogs?: ChangeLogCreateNestedManyWithoutStaffInput
    originalOverrides?: DailyOverrideCreateNestedManyWithoutOriginalStaffInput
    newOverrides?: DailyOverrideCreateNestedManyWithoutNewStaffInput
  }

  export type StaffUncheckedCreateWithoutGroupSessionsInput = {
    id?: number
    name: string
    locations?: StaffCreatelocationsInput | string[]
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutStaffInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutStaffInput
    originalOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutOriginalStaffInput
    newOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutNewStaffInput
  }

  export type StaffCreateOrConnectWithoutGroupSessionsInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutGroupSessionsInput, StaffUncheckedCreateWithoutGroupSessionsInput>
  }

  export type ScheduleVersionCreateWithoutGroupSessionsInput = {
    name: string
    type: string
    status?: string
    startDate?: Date | string | null
    description?: string | null
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutVersionInput
    changeLogs?: ChangeLogCreateNestedManyWithoutVersionInput
  }

  export type ScheduleVersionUncheckedCreateWithoutGroupSessionsInput = {
    id?: number
    name: string
    type: string
    status?: string
    startDate?: Date | string | null
    description?: string | null
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutVersionInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutVersionInput
  }

  export type ScheduleVersionCreateOrConnectWithoutGroupSessionsInput = {
    where: ScheduleVersionWhereUniqueInput
    create: XOR<ScheduleVersionCreateWithoutGroupSessionsInput, ScheduleVersionUncheckedCreateWithoutGroupSessionsInput>
  }

  export type GroupSessionClientCreateWithoutGroupSessionInput = {
    client: ClientCreateNestedOneWithoutGroupSessionClientsInput
  }

  export type GroupSessionClientUncheckedCreateWithoutGroupSessionInput = {
    id?: number
    clientId: number
  }

  export type GroupSessionClientCreateOrConnectWithoutGroupSessionInput = {
    where: GroupSessionClientWhereUniqueInput
    create: XOR<GroupSessionClientCreateWithoutGroupSessionInput, GroupSessionClientUncheckedCreateWithoutGroupSessionInput>
  }

  export type GroupSessionClientCreateManyGroupSessionInputEnvelope = {
    data: GroupSessionClientCreateManyGroupSessionInput | GroupSessionClientCreateManyGroupSessionInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentCreateWithoutGroupSessionInput = {
    day: string
    block: string
    isGroup?: boolean
    plannedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffCreateNestedOneWithoutAssignmentsInput
    client: ClientCreateNestedOneWithoutAssignmentsInput
    version?: ScheduleVersionCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentUncheckedCreateWithoutGroupSessionInput = {
    id?: number
    day: string
    block: string
    staffId: number
    clientId: number
    versionId?: number
    isGroup?: boolean
    plannedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateOrConnectWithoutGroupSessionInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutGroupSessionInput, AssignmentUncheckedCreateWithoutGroupSessionInput>
  }

  export type AssignmentCreateManyGroupSessionInputEnvelope = {
    data: AssignmentCreateManyGroupSessionInput | AssignmentCreateManyGroupSessionInput[]
    skipDuplicates?: boolean
  }

  export type StaffUpsertWithoutGroupSessionsInput = {
    update: XOR<StaffUpdateWithoutGroupSessionsInput, StaffUncheckedUpdateWithoutGroupSessionsInput>
    create: XOR<StaffCreateWithoutGroupSessionsInput, StaffUncheckedCreateWithoutGroupSessionsInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutGroupSessionsInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutGroupSessionsInput, StaffUncheckedUpdateWithoutGroupSessionsInput>
  }

  export type StaffUpdateWithoutGroupSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    locations?: StaffUpdatelocationsInput | string[]
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutStaffNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutStaffNestedInput
    originalOverrides?: DailyOverrideUpdateManyWithoutOriginalStaffNestedInput
    newOverrides?: DailyOverrideUpdateManyWithoutNewStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutGroupSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: StaffUpdatelocationsInput | string[]
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutStaffNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutStaffNestedInput
    originalOverrides?: DailyOverrideUncheckedUpdateManyWithoutOriginalStaffNestedInput
    newOverrides?: DailyOverrideUncheckedUpdateManyWithoutNewStaffNestedInput
  }

  export type ScheduleVersionUpsertWithoutGroupSessionsInput = {
    update: XOR<ScheduleVersionUpdateWithoutGroupSessionsInput, ScheduleVersionUncheckedUpdateWithoutGroupSessionsInput>
    create: XOR<ScheduleVersionCreateWithoutGroupSessionsInput, ScheduleVersionUncheckedCreateWithoutGroupSessionsInput>
    where?: ScheduleVersionWhereInput
  }

  export type ScheduleVersionUpdateToOneWithWhereWithoutGroupSessionsInput = {
    where?: ScheduleVersionWhereInput
    data: XOR<ScheduleVersionUpdateWithoutGroupSessionsInput, ScheduleVersionUncheckedUpdateWithoutGroupSessionsInput>
  }

  export type ScheduleVersionUpdateWithoutGroupSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutVersionNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutVersionNestedInput
  }

  export type ScheduleVersionUncheckedUpdateWithoutGroupSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutVersionNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type GroupSessionClientUpsertWithWhereUniqueWithoutGroupSessionInput = {
    where: GroupSessionClientWhereUniqueInput
    update: XOR<GroupSessionClientUpdateWithoutGroupSessionInput, GroupSessionClientUncheckedUpdateWithoutGroupSessionInput>
    create: XOR<GroupSessionClientCreateWithoutGroupSessionInput, GroupSessionClientUncheckedCreateWithoutGroupSessionInput>
  }

  export type GroupSessionClientUpdateWithWhereUniqueWithoutGroupSessionInput = {
    where: GroupSessionClientWhereUniqueInput
    data: XOR<GroupSessionClientUpdateWithoutGroupSessionInput, GroupSessionClientUncheckedUpdateWithoutGroupSessionInput>
  }

  export type GroupSessionClientUpdateManyWithWhereWithoutGroupSessionInput = {
    where: GroupSessionClientScalarWhereInput
    data: XOR<GroupSessionClientUpdateManyMutationInput, GroupSessionClientUncheckedUpdateManyWithoutGroupSessionInput>
  }

  export type AssignmentUpsertWithWhereUniqueWithoutGroupSessionInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutGroupSessionInput, AssignmentUncheckedUpdateWithoutGroupSessionInput>
    create: XOR<AssignmentCreateWithoutGroupSessionInput, AssignmentUncheckedCreateWithoutGroupSessionInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutGroupSessionInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutGroupSessionInput, AssignmentUncheckedUpdateWithoutGroupSessionInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutGroupSessionInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutGroupSessionInput>
  }

  export type GroupSessionCreateWithoutClientsInput = {
    day: string
    block: string
    location: string
    maxSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffCreateNestedOneWithoutGroupSessionsInput
    version?: ScheduleVersionCreateNestedOneWithoutGroupSessionsInput
    assignments?: AssignmentCreateNestedManyWithoutGroupSessionInput
  }

  export type GroupSessionUncheckedCreateWithoutClientsInput = {
    id?: number
    day: string
    block: string
    staffId: number
    versionId?: number
    location: string
    maxSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutGroupSessionInput
  }

  export type GroupSessionCreateOrConnectWithoutClientsInput = {
    where: GroupSessionWhereUniqueInput
    create: XOR<GroupSessionCreateWithoutClientsInput, GroupSessionUncheckedCreateWithoutClientsInput>
  }

  export type ClientCreateWithoutGroupSessionClientsInput = {
    name: string
    locations?: ClientCreatelocationsInput | string[]
    authorizedHours?: number
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutClientInput
    changeLogs?: ChangeLogCreateNestedManyWithoutClientInput
    originalOverrides?: DailyOverrideCreateNestedManyWithoutOriginalClientInput
    newOverrides?: DailyOverrideCreateNestedManyWithoutNewClientInput
    supervisorHistory?: ClientSupervisorCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutGroupSessionClientsInput = {
    id?: number
    name: string
    locations?: ClientCreatelocationsInput | string[]
    authorizedHours?: number
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutClientInput
    originalOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutOriginalClientInput
    newOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutNewClientInput
    supervisorHistory?: ClientSupervisorUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutGroupSessionClientsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutGroupSessionClientsInput, ClientUncheckedCreateWithoutGroupSessionClientsInput>
  }

  export type GroupSessionUpsertWithoutClientsInput = {
    update: XOR<GroupSessionUpdateWithoutClientsInput, GroupSessionUncheckedUpdateWithoutClientsInput>
    create: XOR<GroupSessionCreateWithoutClientsInput, GroupSessionUncheckedCreateWithoutClientsInput>
    where?: GroupSessionWhereInput
  }

  export type GroupSessionUpdateToOneWithWhereWithoutClientsInput = {
    where?: GroupSessionWhereInput
    data: XOR<GroupSessionUpdateWithoutClientsInput, GroupSessionUncheckedUpdateWithoutClientsInput>
  }

  export type GroupSessionUpdateWithoutClientsInput = {
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    maxSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneRequiredWithoutGroupSessionsNestedInput
    version?: ScheduleVersionUpdateOneRequiredWithoutGroupSessionsNestedInput
    assignments?: AssignmentUpdateManyWithoutGroupSessionNestedInput
  }

  export type GroupSessionUncheckedUpdateWithoutClientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    maxSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutGroupSessionNestedInput
  }

  export type ClientUpsertWithoutGroupSessionClientsInput = {
    update: XOR<ClientUpdateWithoutGroupSessionClientsInput, ClientUncheckedUpdateWithoutGroupSessionClientsInput>
    create: XOR<ClientCreateWithoutGroupSessionClientsInput, ClientUncheckedCreateWithoutGroupSessionClientsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutGroupSessionClientsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutGroupSessionClientsInput, ClientUncheckedUpdateWithoutGroupSessionClientsInput>
  }

  export type ClientUpdateWithoutGroupSessionClientsInput = {
    name?: StringFieldUpdateOperationsInput | string
    locations?: ClientUpdatelocationsInput | string[]
    authorizedHours?: FloatFieldUpdateOperationsInput | number
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutClientNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutClientNestedInput
    originalOverrides?: DailyOverrideUpdateManyWithoutOriginalClientNestedInput
    newOverrides?: DailyOverrideUpdateManyWithoutNewClientNestedInput
    supervisorHistory?: ClientSupervisorUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutGroupSessionClientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: ClientUpdatelocationsInput | string[]
    authorizedHours?: FloatFieldUpdateOperationsInput | number
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutClientNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutClientNestedInput
    originalOverrides?: DailyOverrideUncheckedUpdateManyWithoutOriginalClientNestedInput
    newOverrides?: DailyOverrideUncheckedUpdateManyWithoutNewClientNestedInput
    supervisorHistory?: ClientSupervisorUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ScheduleVersionCreateWithoutChangeLogsInput = {
    name: string
    type: string
    status?: string
    startDate?: Date | string | null
    description?: string | null
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutVersionInput
    groupSessions?: GroupSessionCreateNestedManyWithoutVersionInput
  }

  export type ScheduleVersionUncheckedCreateWithoutChangeLogsInput = {
    id?: number
    name: string
    type: string
    status?: string
    startDate?: Date | string | null
    description?: string | null
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutVersionInput
    groupSessions?: GroupSessionUncheckedCreateNestedManyWithoutVersionInput
  }

  export type ScheduleVersionCreateOrConnectWithoutChangeLogsInput = {
    where: ScheduleVersionWhereUniqueInput
    create: XOR<ScheduleVersionCreateWithoutChangeLogsInput, ScheduleVersionUncheckedCreateWithoutChangeLogsInput>
  }

  export type StaffCreateWithoutChangeLogsInput = {
    name: string
    locations?: StaffCreatelocationsInput | string[]
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutStaffInput
    groupSessions?: GroupSessionCreateNestedManyWithoutStaffInput
    originalOverrides?: DailyOverrideCreateNestedManyWithoutOriginalStaffInput
    newOverrides?: DailyOverrideCreateNestedManyWithoutNewStaffInput
  }

  export type StaffUncheckedCreateWithoutChangeLogsInput = {
    id?: number
    name: string
    locations?: StaffCreatelocationsInput | string[]
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutStaffInput
    groupSessions?: GroupSessionUncheckedCreateNestedManyWithoutStaffInput
    originalOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutOriginalStaffInput
    newOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutNewStaffInput
  }

  export type StaffCreateOrConnectWithoutChangeLogsInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutChangeLogsInput, StaffUncheckedCreateWithoutChangeLogsInput>
  }

  export type ClientCreateWithoutChangeLogsInput = {
    name: string
    locations?: ClientCreatelocationsInput | string[]
    authorizedHours?: number
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutClientInput
    groupSessionClients?: GroupSessionClientCreateNestedManyWithoutClientInput
    originalOverrides?: DailyOverrideCreateNestedManyWithoutOriginalClientInput
    newOverrides?: DailyOverrideCreateNestedManyWithoutNewClientInput
    supervisorHistory?: ClientSupervisorCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutChangeLogsInput = {
    id?: number
    name: string
    locations?: ClientCreatelocationsInput | string[]
    authorizedHours?: number
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientInput
    groupSessionClients?: GroupSessionClientUncheckedCreateNestedManyWithoutClientInput
    originalOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutOriginalClientInput
    newOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutNewClientInput
    supervisorHistory?: ClientSupervisorUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutChangeLogsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutChangeLogsInput, ClientUncheckedCreateWithoutChangeLogsInput>
  }

  export type ScheduleVersionUpsertWithoutChangeLogsInput = {
    update: XOR<ScheduleVersionUpdateWithoutChangeLogsInput, ScheduleVersionUncheckedUpdateWithoutChangeLogsInput>
    create: XOR<ScheduleVersionCreateWithoutChangeLogsInput, ScheduleVersionUncheckedCreateWithoutChangeLogsInput>
    where?: ScheduleVersionWhereInput
  }

  export type ScheduleVersionUpdateToOneWithWhereWithoutChangeLogsInput = {
    where?: ScheduleVersionWhereInput
    data: XOR<ScheduleVersionUpdateWithoutChangeLogsInput, ScheduleVersionUncheckedUpdateWithoutChangeLogsInput>
  }

  export type ScheduleVersionUpdateWithoutChangeLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutVersionNestedInput
    groupSessions?: GroupSessionUpdateManyWithoutVersionNestedInput
  }

  export type ScheduleVersionUncheckedUpdateWithoutChangeLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutVersionNestedInput
    groupSessions?: GroupSessionUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type StaffUpsertWithoutChangeLogsInput = {
    update: XOR<StaffUpdateWithoutChangeLogsInput, StaffUncheckedUpdateWithoutChangeLogsInput>
    create: XOR<StaffCreateWithoutChangeLogsInput, StaffUncheckedCreateWithoutChangeLogsInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutChangeLogsInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutChangeLogsInput, StaffUncheckedUpdateWithoutChangeLogsInput>
  }

  export type StaffUpdateWithoutChangeLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    locations?: StaffUpdatelocationsInput | string[]
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutStaffNestedInput
    groupSessions?: GroupSessionUpdateManyWithoutStaffNestedInput
    originalOverrides?: DailyOverrideUpdateManyWithoutOriginalStaffNestedInput
    newOverrides?: DailyOverrideUpdateManyWithoutNewStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutChangeLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: StaffUpdatelocationsInput | string[]
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutStaffNestedInput
    groupSessions?: GroupSessionUncheckedUpdateManyWithoutStaffNestedInput
    originalOverrides?: DailyOverrideUncheckedUpdateManyWithoutOriginalStaffNestedInput
    newOverrides?: DailyOverrideUncheckedUpdateManyWithoutNewStaffNestedInput
  }

  export type ClientUpsertWithoutChangeLogsInput = {
    update: XOR<ClientUpdateWithoutChangeLogsInput, ClientUncheckedUpdateWithoutChangeLogsInput>
    create: XOR<ClientCreateWithoutChangeLogsInput, ClientUncheckedCreateWithoutChangeLogsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutChangeLogsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutChangeLogsInput, ClientUncheckedUpdateWithoutChangeLogsInput>
  }

  export type ClientUpdateWithoutChangeLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    locations?: ClientUpdatelocationsInput | string[]
    authorizedHours?: FloatFieldUpdateOperationsInput | number
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutClientNestedInput
    groupSessionClients?: GroupSessionClientUpdateManyWithoutClientNestedInput
    originalOverrides?: DailyOverrideUpdateManyWithoutOriginalClientNestedInput
    newOverrides?: DailyOverrideUpdateManyWithoutNewClientNestedInput
    supervisorHistory?: ClientSupervisorUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutChangeLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: ClientUpdatelocationsInput | string[]
    authorizedHours?: FloatFieldUpdateOperationsInput | number
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutClientNestedInput
    groupSessionClients?: GroupSessionClientUncheckedUpdateManyWithoutClientNestedInput
    originalOverrides?: DailyOverrideUncheckedUpdateManyWithoutOriginalClientNestedInput
    newOverrides?: DailyOverrideUncheckedUpdateManyWithoutNewClientNestedInput
    supervisorHistory?: ClientSupervisorUncheckedUpdateManyWithoutClientNestedInput
  }

  export type StaffCreateWithoutOriginalOverridesInput = {
    name: string
    locations?: StaffCreatelocationsInput | string[]
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutStaffInput
    groupSessions?: GroupSessionCreateNestedManyWithoutStaffInput
    changeLogs?: ChangeLogCreateNestedManyWithoutStaffInput
    newOverrides?: DailyOverrideCreateNestedManyWithoutNewStaffInput
  }

  export type StaffUncheckedCreateWithoutOriginalOverridesInput = {
    id?: number
    name: string
    locations?: StaffCreatelocationsInput | string[]
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutStaffInput
    groupSessions?: GroupSessionUncheckedCreateNestedManyWithoutStaffInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutStaffInput
    newOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutNewStaffInput
  }

  export type StaffCreateOrConnectWithoutOriginalOverridesInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutOriginalOverridesInput, StaffUncheckedCreateWithoutOriginalOverridesInput>
  }

  export type ClientCreateWithoutOriginalOverridesInput = {
    name: string
    locations?: ClientCreatelocationsInput | string[]
    authorizedHours?: number
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutClientInput
    groupSessionClients?: GroupSessionClientCreateNestedManyWithoutClientInput
    changeLogs?: ChangeLogCreateNestedManyWithoutClientInput
    newOverrides?: DailyOverrideCreateNestedManyWithoutNewClientInput
    supervisorHistory?: ClientSupervisorCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutOriginalOverridesInput = {
    id?: number
    name: string
    locations?: ClientCreatelocationsInput | string[]
    authorizedHours?: number
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientInput
    groupSessionClients?: GroupSessionClientUncheckedCreateNestedManyWithoutClientInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutClientInput
    newOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutNewClientInput
    supervisorHistory?: ClientSupervisorUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutOriginalOverridesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutOriginalOverridesInput, ClientUncheckedCreateWithoutOriginalOverridesInput>
  }

  export type StaffCreateWithoutNewOverridesInput = {
    name: string
    locations?: StaffCreatelocationsInput | string[]
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutStaffInput
    groupSessions?: GroupSessionCreateNestedManyWithoutStaffInput
    changeLogs?: ChangeLogCreateNestedManyWithoutStaffInput
    originalOverrides?: DailyOverrideCreateNestedManyWithoutOriginalStaffInput
  }

  export type StaffUncheckedCreateWithoutNewOverridesInput = {
    id?: number
    name: string
    locations?: StaffCreatelocationsInput | string[]
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutStaffInput
    groupSessions?: GroupSessionUncheckedCreateNestedManyWithoutStaffInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutStaffInput
    originalOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutOriginalStaffInput
  }

  export type StaffCreateOrConnectWithoutNewOverridesInput = {
    where: StaffWhereUniqueInput
    create: XOR<StaffCreateWithoutNewOverridesInput, StaffUncheckedCreateWithoutNewOverridesInput>
  }

  export type ClientCreateWithoutNewOverridesInput = {
    name: string
    locations?: ClientCreatelocationsInput | string[]
    authorizedHours?: number
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutClientInput
    groupSessionClients?: GroupSessionClientCreateNestedManyWithoutClientInput
    changeLogs?: ChangeLogCreateNestedManyWithoutClientInput
    originalOverrides?: DailyOverrideCreateNestedManyWithoutOriginalClientInput
    supervisorHistory?: ClientSupervisorCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutNewOverridesInput = {
    id?: number
    name: string
    locations?: ClientCreatelocationsInput | string[]
    authorizedHours?: number
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientInput
    groupSessionClients?: GroupSessionClientUncheckedCreateNestedManyWithoutClientInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutClientInput
    originalOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutOriginalClientInput
    supervisorHistory?: ClientSupervisorUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutNewOverridesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutNewOverridesInput, ClientUncheckedCreateWithoutNewOverridesInput>
  }

  export type StaffUpsertWithoutOriginalOverridesInput = {
    update: XOR<StaffUpdateWithoutOriginalOverridesInput, StaffUncheckedUpdateWithoutOriginalOverridesInput>
    create: XOR<StaffCreateWithoutOriginalOverridesInput, StaffUncheckedCreateWithoutOriginalOverridesInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutOriginalOverridesInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutOriginalOverridesInput, StaffUncheckedUpdateWithoutOriginalOverridesInput>
  }

  export type StaffUpdateWithoutOriginalOverridesInput = {
    name?: StringFieldUpdateOperationsInput | string
    locations?: StaffUpdatelocationsInput | string[]
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutStaffNestedInput
    groupSessions?: GroupSessionUpdateManyWithoutStaffNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutStaffNestedInput
    newOverrides?: DailyOverrideUpdateManyWithoutNewStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutOriginalOverridesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: StaffUpdatelocationsInput | string[]
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutStaffNestedInput
    groupSessions?: GroupSessionUncheckedUpdateManyWithoutStaffNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutStaffNestedInput
    newOverrides?: DailyOverrideUncheckedUpdateManyWithoutNewStaffNestedInput
  }

  export type ClientUpsertWithoutOriginalOverridesInput = {
    update: XOR<ClientUpdateWithoutOriginalOverridesInput, ClientUncheckedUpdateWithoutOriginalOverridesInput>
    create: XOR<ClientCreateWithoutOriginalOverridesInput, ClientUncheckedCreateWithoutOriginalOverridesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutOriginalOverridesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutOriginalOverridesInput, ClientUncheckedUpdateWithoutOriginalOverridesInput>
  }

  export type ClientUpdateWithoutOriginalOverridesInput = {
    name?: StringFieldUpdateOperationsInput | string
    locations?: ClientUpdatelocationsInput | string[]
    authorizedHours?: FloatFieldUpdateOperationsInput | number
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutClientNestedInput
    groupSessionClients?: GroupSessionClientUpdateManyWithoutClientNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutClientNestedInput
    newOverrides?: DailyOverrideUpdateManyWithoutNewClientNestedInput
    supervisorHistory?: ClientSupervisorUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutOriginalOverridesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: ClientUpdatelocationsInput | string[]
    authorizedHours?: FloatFieldUpdateOperationsInput | number
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutClientNestedInput
    groupSessionClients?: GroupSessionClientUncheckedUpdateManyWithoutClientNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutClientNestedInput
    newOverrides?: DailyOverrideUncheckedUpdateManyWithoutNewClientNestedInput
    supervisorHistory?: ClientSupervisorUncheckedUpdateManyWithoutClientNestedInput
  }

  export type StaffUpsertWithoutNewOverridesInput = {
    update: XOR<StaffUpdateWithoutNewOverridesInput, StaffUncheckedUpdateWithoutNewOverridesInput>
    create: XOR<StaffCreateWithoutNewOverridesInput, StaffUncheckedCreateWithoutNewOverridesInput>
    where?: StaffWhereInput
  }

  export type StaffUpdateToOneWithWhereWithoutNewOverridesInput = {
    where?: StaffWhereInput
    data: XOR<StaffUpdateWithoutNewOverridesInput, StaffUncheckedUpdateWithoutNewOverridesInput>
  }

  export type StaffUpdateWithoutNewOverridesInput = {
    name?: StringFieldUpdateOperationsInput | string
    locations?: StaffUpdatelocationsInput | string[]
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutStaffNestedInput
    groupSessions?: GroupSessionUpdateManyWithoutStaffNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutStaffNestedInput
    originalOverrides?: DailyOverrideUpdateManyWithoutOriginalStaffNestedInput
  }

  export type StaffUncheckedUpdateWithoutNewOverridesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: StaffUpdatelocationsInput | string[]
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutStaffNestedInput
    groupSessions?: GroupSessionUncheckedUpdateManyWithoutStaffNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutStaffNestedInput
    originalOverrides?: DailyOverrideUncheckedUpdateManyWithoutOriginalStaffNestedInput
  }

  export type ClientUpsertWithoutNewOverridesInput = {
    update: XOR<ClientUpdateWithoutNewOverridesInput, ClientUncheckedUpdateWithoutNewOverridesInput>
    create: XOR<ClientCreateWithoutNewOverridesInput, ClientUncheckedCreateWithoutNewOverridesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutNewOverridesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutNewOverridesInput, ClientUncheckedUpdateWithoutNewOverridesInput>
  }

  export type ClientUpdateWithoutNewOverridesInput = {
    name?: StringFieldUpdateOperationsInput | string
    locations?: ClientUpdatelocationsInput | string[]
    authorizedHours?: FloatFieldUpdateOperationsInput | number
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutClientNestedInput
    groupSessionClients?: GroupSessionClientUpdateManyWithoutClientNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutClientNestedInput
    originalOverrides?: DailyOverrideUpdateManyWithoutOriginalClientNestedInput
    supervisorHistory?: ClientSupervisorUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutNewOverridesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: ClientUpdatelocationsInput | string[]
    authorizedHours?: FloatFieldUpdateOperationsInput | number
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutClientNestedInput
    groupSessionClients?: GroupSessionClientUncheckedUpdateManyWithoutClientNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutClientNestedInput
    originalOverrides?: DailyOverrideUncheckedUpdateManyWithoutOriginalClientNestedInput
    supervisorHistory?: ClientSupervisorUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutSupervisorHistoryInput = {
    name: string
    locations?: ClientCreatelocationsInput | string[]
    authorizedHours?: number
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentCreateNestedManyWithoutClientInput
    groupSessionClients?: GroupSessionClientCreateNestedManyWithoutClientInput
    changeLogs?: ChangeLogCreateNestedManyWithoutClientInput
    originalOverrides?: DailyOverrideCreateNestedManyWithoutOriginalClientInput
    newOverrides?: DailyOverrideCreateNestedManyWithoutNewClientInput
  }

  export type ClientUncheckedCreateWithoutSupervisorHistoryInput = {
    id?: number
    name: string
    locations?: ClientCreatelocationsInput | string[]
    authorizedHours?: number
    availability: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: AssignmentUncheckedCreateNestedManyWithoutClientInput
    groupSessionClients?: GroupSessionClientUncheckedCreateNestedManyWithoutClientInput
    changeLogs?: ChangeLogUncheckedCreateNestedManyWithoutClientInput
    originalOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutOriginalClientInput
    newOverrides?: DailyOverrideUncheckedCreateNestedManyWithoutNewClientInput
  }

  export type ClientCreateOrConnectWithoutSupervisorHistoryInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutSupervisorHistoryInput, ClientUncheckedCreateWithoutSupervisorHistoryInput>
  }

  export type ClientUpsertWithoutSupervisorHistoryInput = {
    update: XOR<ClientUpdateWithoutSupervisorHistoryInput, ClientUncheckedUpdateWithoutSupervisorHistoryInput>
    create: XOR<ClientCreateWithoutSupervisorHistoryInput, ClientUncheckedCreateWithoutSupervisorHistoryInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutSupervisorHistoryInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutSupervisorHistoryInput, ClientUncheckedUpdateWithoutSupervisorHistoryInput>
  }

  export type ClientUpdateWithoutSupervisorHistoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    locations?: ClientUpdatelocationsInput | string[]
    authorizedHours?: FloatFieldUpdateOperationsInput | number
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUpdateManyWithoutClientNestedInput
    groupSessionClients?: GroupSessionClientUpdateManyWithoutClientNestedInput
    changeLogs?: ChangeLogUpdateManyWithoutClientNestedInput
    originalOverrides?: DailyOverrideUpdateManyWithoutOriginalClientNestedInput
    newOverrides?: DailyOverrideUpdateManyWithoutNewClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutSupervisorHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: ClientUpdatelocationsInput | string[]
    authorizedHours?: FloatFieldUpdateOperationsInput | number
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: AssignmentUncheckedUpdateManyWithoutClientNestedInput
    groupSessionClients?: GroupSessionClientUncheckedUpdateManyWithoutClientNestedInput
    changeLogs?: ChangeLogUncheckedUpdateManyWithoutClientNestedInput
    originalOverrides?: DailyOverrideUncheckedUpdateManyWithoutOriginalClientNestedInput
    newOverrides?: DailyOverrideUncheckedUpdateManyWithoutNewClientNestedInput
  }

  export type AssignmentCreateManyStaffInput = {
    id?: number
    day: string
    block: string
    clientId: number
    versionId?: number
    isGroup?: boolean
    groupSessionId?: number | null
    plannedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupSessionCreateManyStaffInput = {
    id?: number
    day: string
    block: string
    versionId?: number
    location: string
    maxSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChangeLogCreateManyStaffInput = {
    id?: number
    versionId: number
    changeType: string
    entityType: string
    entityId?: number | null
    day?: string | null
    block?: string | null
    clientId?: number | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: boolean
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    committedToMain?: boolean
    committedAt?: Date | string | null
    createdBy?: string
    createdAt?: Date | string
    notes?: string | null
  }

  export type DailyOverrideCreateManyOriginalStaffInput = {
    id?: number
    date: Date | string
    type: string
    day: string
    block: string
    originalClientId?: number | null
    newStaffId?: number | null
    newClientId?: number | null
    reason: string
    hours?: number | null
    status?: string
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyOverrideCreateManyNewStaffInput = {
    id?: number
    date: Date | string
    type: string
    day: string
    block: string
    originalStaffId?: number | null
    originalClientId?: number | null
    newClientId?: number | null
    reason: string
    hours?: number | null
    status?: string
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentUpdateWithoutStaffInput = {
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutAssignmentsNestedInput
    version?: ScheduleVersionUpdateOneRequiredWithoutAssignmentsNestedInput
    groupSession?: GroupSessionUpdateOneWithoutAssignmentsNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    clientId?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUncheckedUpdateManyWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    clientId?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupSessionUpdateWithoutStaffInput = {
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    maxSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: ScheduleVersionUpdateOneRequiredWithoutGroupSessionsNestedInput
    clients?: GroupSessionClientUpdateManyWithoutGroupSessionNestedInput
    assignments?: AssignmentUpdateManyWithoutGroupSessionNestedInput
  }

  export type GroupSessionUncheckedUpdateWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    versionId?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    maxSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: GroupSessionClientUncheckedUpdateManyWithoutGroupSessionNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutGroupSessionNestedInput
  }

  export type GroupSessionUncheckedUpdateManyWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    versionId?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    maxSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeLogUpdateWithoutStaffInput = {
    changeType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    committedToMain?: BoolFieldUpdateOperationsInput | boolean
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    version?: ScheduleVersionUpdateOneRequiredWithoutChangeLogsNestedInput
    client?: ClientUpdateOneWithoutChangeLogsNestedInput
  }

  export type ChangeLogUncheckedUpdateWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    changeType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    committedToMain?: BoolFieldUpdateOperationsInput | boolean
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeLogUncheckedUpdateManyWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    changeType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    committedToMain?: BoolFieldUpdateOperationsInput | boolean
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DailyOverrideUpdateWithoutOriginalStaffInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalClient?: ClientUpdateOneWithoutOriginalOverridesNestedInput
    newStaff?: StaffUpdateOneWithoutNewOverridesNestedInput
    newClient?: ClientUpdateOneWithoutNewOverridesNestedInput
  }

  export type DailyOverrideUncheckedUpdateWithoutOriginalStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    originalClientId?: NullableIntFieldUpdateOperationsInput | number | null
    newStaffId?: NullableIntFieldUpdateOperationsInput | number | null
    newClientId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyOverrideUncheckedUpdateManyWithoutOriginalStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    originalClientId?: NullableIntFieldUpdateOperationsInput | number | null
    newStaffId?: NullableIntFieldUpdateOperationsInput | number | null
    newClientId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyOverrideUpdateWithoutNewStaffInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalStaff?: StaffUpdateOneWithoutOriginalOverridesNestedInput
    originalClient?: ClientUpdateOneWithoutOriginalOverridesNestedInput
    newClient?: ClientUpdateOneWithoutNewOverridesNestedInput
  }

  export type DailyOverrideUncheckedUpdateWithoutNewStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    originalStaffId?: NullableIntFieldUpdateOperationsInput | number | null
    originalClientId?: NullableIntFieldUpdateOperationsInput | number | null
    newClientId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyOverrideUncheckedUpdateManyWithoutNewStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    originalStaffId?: NullableIntFieldUpdateOperationsInput | number | null
    originalClientId?: NullableIntFieldUpdateOperationsInput | number | null
    newClientId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentCreateManyClientInput = {
    id?: number
    day: string
    block: string
    staffId: number
    versionId?: number
    isGroup?: boolean
    groupSessionId?: number | null
    plannedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupSessionClientCreateManyClientInput = {
    id?: number
    groupSessionId: number
  }

  export type ChangeLogCreateManyClientInput = {
    id?: number
    versionId: number
    changeType: string
    entityType: string
    entityId?: number | null
    day?: string | null
    block?: string | null
    staffId?: number | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: boolean
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    committedToMain?: boolean
    committedAt?: Date | string | null
    createdBy?: string
    createdAt?: Date | string
    notes?: string | null
  }

  export type DailyOverrideCreateManyOriginalClientInput = {
    id?: number
    date: Date | string
    type: string
    day: string
    block: string
    originalStaffId?: number | null
    newStaffId?: number | null
    newClientId?: number | null
    reason: string
    hours?: number | null
    status?: string
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyOverrideCreateManyNewClientInput = {
    id?: number
    date: Date | string
    type: string
    day: string
    block: string
    originalStaffId?: number | null
    originalClientId?: number | null
    newStaffId?: number | null
    reason: string
    hours?: number | null
    status?: string
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientSupervisorCreateManyClientInput = {
    id?: number
    supervisorName: string
    effectiveDate: Date | string
    endDate?: Date | string | null
    createdBy?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentUpdateWithoutClientInput = {
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneRequiredWithoutAssignmentsNestedInput
    version?: ScheduleVersionUpdateOneRequiredWithoutAssignmentsNestedInput
    groupSession?: GroupSessionUpdateOneWithoutAssignmentsNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupSessionClientUpdateWithoutClientInput = {
    groupSession?: GroupSessionUpdateOneRequiredWithoutClientsNestedInput
  }

  export type GroupSessionClientUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupSessionId?: IntFieldUpdateOperationsInput | number
  }

  export type GroupSessionClientUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    groupSessionId?: IntFieldUpdateOperationsInput | number
  }

  export type ChangeLogUpdateWithoutClientInput = {
    changeType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    committedToMain?: BoolFieldUpdateOperationsInput | boolean
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    version?: ScheduleVersionUpdateOneRequiredWithoutChangeLogsNestedInput
    staff?: StaffUpdateOneWithoutChangeLogsNestedInput
  }

  export type ChangeLogUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    changeType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    committedToMain?: BoolFieldUpdateOperationsInput | boolean
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeLogUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    changeType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    committedToMain?: BoolFieldUpdateOperationsInput | boolean
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DailyOverrideUpdateWithoutOriginalClientInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalStaff?: StaffUpdateOneWithoutOriginalOverridesNestedInput
    newStaff?: StaffUpdateOneWithoutNewOverridesNestedInput
    newClient?: ClientUpdateOneWithoutNewOverridesNestedInput
  }

  export type DailyOverrideUncheckedUpdateWithoutOriginalClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    originalStaffId?: NullableIntFieldUpdateOperationsInput | number | null
    newStaffId?: NullableIntFieldUpdateOperationsInput | number | null
    newClientId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyOverrideUncheckedUpdateManyWithoutOriginalClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    originalStaffId?: NullableIntFieldUpdateOperationsInput | number | null
    newStaffId?: NullableIntFieldUpdateOperationsInput | number | null
    newClientId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyOverrideUpdateWithoutNewClientInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalStaff?: StaffUpdateOneWithoutOriginalOverridesNestedInput
    originalClient?: ClientUpdateOneWithoutOriginalOverridesNestedInput
    newStaff?: StaffUpdateOneWithoutNewOverridesNestedInput
  }

  export type DailyOverrideUncheckedUpdateWithoutNewClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    originalStaffId?: NullableIntFieldUpdateOperationsInput | number | null
    originalClientId?: NullableIntFieldUpdateOperationsInput | number | null
    newStaffId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyOverrideUncheckedUpdateManyWithoutNewClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    originalStaffId?: NullableIntFieldUpdateOperationsInput | number | null
    originalClientId?: NullableIntFieldUpdateOperationsInput | number | null
    newStaffId?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: StringFieldUpdateOperationsInput | string
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSupervisorUpdateWithoutClientInput = {
    supervisorName?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSupervisorUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    supervisorName?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientSupervisorUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    supervisorName?: StringFieldUpdateOperationsInput | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentCreateManyVersionInput = {
    id?: number
    day: string
    block: string
    staffId: number
    clientId: number
    isGroup?: boolean
    groupSessionId?: number | null
    plannedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupSessionCreateManyVersionInput = {
    id?: number
    day: string
    block: string
    staffId: number
    location: string
    maxSize?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChangeLogCreateManyVersionInput = {
    id?: number
    changeType: string
    entityType: string
    entityId?: number | null
    day?: string | null
    block?: string | null
    staffId?: number | null
    clientId?: number | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: boolean
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    committedToMain?: boolean
    committedAt?: Date | string | null
    createdBy?: string
    createdAt?: Date | string
    notes?: string | null
  }

  export type AssignmentUpdateWithoutVersionInput = {
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneRequiredWithoutAssignmentsNestedInput
    client?: ClientUpdateOneRequiredWithoutAssignmentsNestedInput
    groupSession?: GroupSessionUpdateOneWithoutAssignmentsNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUncheckedUpdateManyWithoutVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    groupSessionId?: NullableIntFieldUpdateOperationsInput | number | null
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupSessionUpdateWithoutVersionInput = {
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    maxSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneRequiredWithoutGroupSessionsNestedInput
    clients?: GroupSessionClientUpdateManyWithoutGroupSessionNestedInput
    assignments?: AssignmentUpdateManyWithoutGroupSessionNestedInput
  }

  export type GroupSessionUncheckedUpdateWithoutVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    maxSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clients?: GroupSessionClientUncheckedUpdateManyWithoutGroupSessionNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutGroupSessionNestedInput
  }

  export type GroupSessionUncheckedUpdateManyWithoutVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    location?: StringFieldUpdateOperationsInput | string
    maxSize?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeLogUpdateWithoutVersionInput = {
    changeType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    committedToMain?: BoolFieldUpdateOperationsInput | boolean
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: StaffUpdateOneWithoutChangeLogsNestedInput
    client?: ClientUpdateOneWithoutChangeLogsNestedInput
  }

  export type ChangeLogUncheckedUpdateWithoutVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    changeType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    committedToMain?: BoolFieldUpdateOperationsInput | boolean
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChangeLogUncheckedUpdateManyWithoutVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    changeType?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableIntFieldUpdateOperationsInput | number | null
    day?: NullableStringFieldUpdateOperationsInput | string | null
    block?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    previousValue?: NullableJsonNullValueInput | InputJsonValue
    newValue?: NullableJsonNullValueInput | InputJsonValue
    reviewed?: BoolFieldUpdateOperationsInput | boolean
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    committedToMain?: BoolFieldUpdateOperationsInput | boolean
    committedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GroupSessionClientCreateManyGroupSessionInput = {
    id?: number
    clientId: number
  }

  export type AssignmentCreateManyGroupSessionInput = {
    id?: number
    day: string
    block: string
    staffId: number
    clientId: number
    versionId?: number
    isGroup?: boolean
    plannedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupSessionClientUpdateWithoutGroupSessionInput = {
    client?: ClientUpdateOneRequiredWithoutGroupSessionClientsNestedInput
  }

  export type GroupSessionClientUncheckedUpdateWithoutGroupSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
  }

  export type GroupSessionClientUncheckedUpdateManyWithoutGroupSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
  }

  export type AssignmentUpdateWithoutGroupSessionInput = {
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffUpdateOneRequiredWithoutAssignmentsNestedInput
    client?: ClientUpdateOneRequiredWithoutAssignmentsNestedInput
    version?: ScheduleVersionUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutGroupSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUncheckedUpdateManyWithoutGroupSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    block?: StringFieldUpdateOperationsInput | string
    staffId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    versionId?: IntFieldUpdateOperationsInput | number
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    plannedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}